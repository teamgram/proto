/*
 * WARNING! All changes made in this file will be lost!
 * Created from 'scheme.tl' by 'mtprotoc'
 *
 * Copyright (c) 2025-present,  Teamgram Authors.
 *  All rights reserved.
 *
 * Author: Benqi (wubenqi@gmail.com)
 */

package tg

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/teamgram/proto/v2/bin"
	"github.com/teamgram/proto/v2/iface"
)

var (
	_ iface.TLObject
	_ context.Context
)

// TLInvokeAfterMsg <--
type TLInvokeAfterMsg struct {
	ClazzID uint32 `json:"_id"`
	MsgId   int64  `json:"msg_id"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeAfterMsg) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeAfterMsg) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcb9f372d: func() error {
			x.PutClazzID(0xcb9f372d)

			x.PutInt64(m.MsgId)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeAfterMsg, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeAfterMsg, layer)
	}
}

// Decode <--
func (m *TLInvokeAfterMsg) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcb9f372d: func() (err error) {
			m.MsgId, err = d.Int64()
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeAfterMsgs <--
type TLInvokeAfterMsgs struct {
	ClazzID uint32  `json:"_id"`
	MsgIds  []int64 `json:"msg_ids"`
	Query   []byte  `json:"query"`
}

func (m *TLInvokeAfterMsgs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeAfterMsgs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3dc4b4f0: func() error {
			x.PutClazzID(0x3dc4b4f0)

			iface.EncodeInt64List(x, m.MsgIds)

			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeAfterMsgs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeAfterMsgs, layer)
	}
}

// Decode <--
func (m *TLInvokeAfterMsgs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3dc4b4f0: func() (err error) {

			m.MsgIds, err = iface.DecodeInt64List(d)

			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInitConnection <--
type TLInitConnection struct {
	ClazzID        uint32                `json:"_id"`
	ApiId          int32                 `json:"api_id"`
	DeviceModel    string                `json:"device_model"`
	SystemVersion  string                `json:"system_version"`
	AppVersion     string                `json:"app_version"`
	SystemLangCode string                `json:"system_lang_code"`
	LangPack       string                `json:"lang_pack"`
	LangCode       string                `json:"lang_code"`
	Proxy          InputClientProxyClazz `json:"proxy"`
	Params         JSONValueClazz        `json:"params"`
	Query          []byte                `json:"query"`
}

func (m *TLInitConnection) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInitConnection) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc1cd5ea9: func() error {
			x.PutClazzID(0xc1cd5ea9)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Proxy != nil {
					flags |= 1 << 0
				}
				if m.Params != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.ApiId)
			x.PutString(m.DeviceModel)
			x.PutString(m.SystemVersion)
			x.PutString(m.AppVersion)
			x.PutString(m.SystemLangCode)
			x.PutString(m.LangPack)
			x.PutString(m.LangCode)
			if m.Proxy != nil {
				_ = m.Proxy.Encode(x, layer)
			}

			if m.Params != nil {
				_ = m.Params.Encode(x, layer)
			}

			// template Debug by @benqi

			return nil
		},
		0x785188b8: func() error {
			x.PutClazzID(0x785188b8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Proxy != nil {
					flags |= 1 << 0
				}
				if m.Params != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.ApiId)
			x.PutString(m.DeviceModel)
			x.PutString(m.SystemVersion)
			x.PutString(m.AppVersion)
			x.PutString(m.SystemLangCode)
			x.PutString(m.LangPack)
			x.PutString(m.LangCode)
			if m.Proxy != nil {
				_ = m.Proxy.Encode(x, layer)
			}

			if m.Params != nil {
				_ = m.Params.Encode(x, layer)
			}

			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_initConnection, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_initConnection, layer)
	}
}

// Decode <--
func (m *TLInitConnection) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc1cd5ea9: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.ApiId, err = d.Int32()
			m.DeviceModel, err = d.String()
			m.SystemVersion, err = d.String()
			m.AppVersion, err = d.String()
			m.SystemLangCode, err = d.String()
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()
			if (flags & (1 << 0)) != 0 {
				// m9 := &InputClientProxy{}
				// _ = m9.Decode(d)
				// m.Proxy = m9
				m.Proxy, _ = DecodeInputClientProxyClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				// m10 := &JSONValue{}
				// _ = m10.Decode(d)
				// m.Params = m10
				m.Params, _ = DecodeJSONValueClazz(d)
			}
			m.Query = d.Raw()

			return nil
		},
		0x785188b8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.ApiId, err = d.Int32()
			m.DeviceModel, err = d.String()
			m.SystemVersion, err = d.String()
			m.AppVersion, err = d.String()
			m.SystemLangCode, err = d.String()
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()
			if (flags & (1 << 0)) != 0 {
				// m9 := &InputClientProxy{}
				// _ = m9.Decode(d)
				// m.Proxy = m9
				m.Proxy, _ = DecodeInputClientProxyClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				// m10 := &JSONValue{}
				// _ = m10.Decode(d)
				// m.Params = m10
				m.Params, _ = DecodeJSONValueClazz(d)
			}
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithLayer <--
type TLInvokeWithLayer struct {
	ClazzID uint32 `json:"_id"`
	Layer   int32  `json:"layer"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeWithLayer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithLayer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xda9b0d0d: func() error {
			x.PutClazzID(0xda9b0d0d)

			x.PutInt32(m.Layer)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithLayer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithLayer, layer)
	}
}

// Decode <--
func (m *TLInvokeWithLayer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xda9b0d0d: func() (err error) {
			m.Layer, err = d.Int32()
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithoutUpdates <--
type TLInvokeWithoutUpdates struct {
	ClazzID uint32 `json:"_id"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeWithoutUpdates) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithoutUpdates) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbf9459b7: func() error {
			x.PutClazzID(0xbf9459b7)

			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithoutUpdates, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithoutUpdates, layer)
	}
}

// Decode <--
func (m *TLInvokeWithoutUpdates) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbf9459b7: func() (err error) {
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithMessagesRange <--
type TLInvokeWithMessagesRange struct {
	ClazzID uint32            `json:"_id"`
	Range   MessageRangeClazz `json:"range"`
	Query   []byte            `json:"query"`
}

func (m *TLInvokeWithMessagesRange) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithMessagesRange) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x365275f2: func() error {
			x.PutClazzID(0x365275f2)

			_ = m.Range.Encode(x, layer)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithMessagesRange, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithMessagesRange, layer)
	}
}

// Decode <--
func (m *TLInvokeWithMessagesRange) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x365275f2: func() (err error) {

			// m1 := &MessageRange{}
			// _ = m1.Decode(d)
			// m.Range = m1
			m.Range, _ = DecodeMessageRangeClazz(d)

			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithTakeout <--
type TLInvokeWithTakeout struct {
	ClazzID   uint32 `json:"_id"`
	TakeoutId int64  `json:"takeout_id"`
	Query     []byte `json:"query"`
}

func (m *TLInvokeWithTakeout) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithTakeout) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaca9fd2e: func() error {
			x.PutClazzID(0xaca9fd2e)

			x.PutInt64(m.TakeoutId)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithTakeout, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithTakeout, layer)
	}
}

// Decode <--
func (m *TLInvokeWithTakeout) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaca9fd2e: func() (err error) {
			m.TakeoutId, err = d.Int64()
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithBusinessConnection <--
type TLInvokeWithBusinessConnection struct {
	ClazzID      uint32 `json:"_id"`
	ConnectionId string `json:"connection_id"`
	Query        []byte `json:"query"`
}

func (m *TLInvokeWithBusinessConnection) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithBusinessConnection) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdd289f8e: func() error {
			x.PutClazzID(0xdd289f8e)

			x.PutString(m.ConnectionId)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithBusinessConnection, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithBusinessConnection, layer)
	}
}

// Decode <--
func (m *TLInvokeWithBusinessConnection) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdd289f8e: func() (err error) {
			m.ConnectionId, err = d.String()
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithGooglePlayIntegrity <--
type TLInvokeWithGooglePlayIntegrity struct {
	ClazzID uint32 `json:"_id"`
	Nonce   string `json:"nonce"`
	Token   string `json:"token"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeWithGooglePlayIntegrity) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithGooglePlayIntegrity) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1df92984: func() error {
			x.PutClazzID(0x1df92984)

			x.PutString(m.Nonce)
			x.PutString(m.Token)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithGooglePlayIntegrity, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithGooglePlayIntegrity, layer)
	}
}

// Decode <--
func (m *TLInvokeWithGooglePlayIntegrity) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1df92984: func() (err error) {
			m.Nonce, err = d.String()
			m.Token, err = d.String()
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithApnsSecret <--
type TLInvokeWithApnsSecret struct {
	ClazzID uint32 `json:"_id"`
	Nonce   string `json:"nonce"`
	Secret  string `json:"secret"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeWithApnsSecret) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithApnsSecret) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdae54f8: func() error {
			x.PutClazzID(0xdae54f8)

			x.PutString(m.Nonce)
			x.PutString(m.Secret)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithApnsSecret, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithApnsSecret, layer)
	}
}

// Decode <--
func (m *TLInvokeWithApnsSecret) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdae54f8: func() (err error) {
			m.Nonce, err = d.String()
			m.Secret, err = d.String()
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithReCaptcha <--
type TLInvokeWithReCaptcha struct {
	ClazzID uint32 `json:"_id"`
	Token   string `json:"token"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeWithReCaptcha) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithReCaptcha) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xadbb0f94: func() error {
			x.PutClazzID(0xadbb0f94)

			x.PutString(m.Token)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithReCaptcha, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithReCaptcha, layer)
	}
}

// Decode <--
func (m *TLInvokeWithReCaptcha) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xadbb0f94: func() (err error) {
			m.Token, err = d.String()
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthSendCode <--
type TLAuthSendCode struct {
	ClazzID     uint32            `json:"_id"`
	PhoneNumber string            `json:"phone_number"`
	ApiId       int32             `json:"api_id"`
	ApiHash     string            `json:"api_hash"`
	Settings    CodeSettingsClazz `json:"settings"`
}

func (m *TLAuthSendCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthSendCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa677244f: func() error {
			x.PutClazzID(0xa677244f)

			x.PutString(m.PhoneNumber)
			x.PutInt32(m.ApiId)
			x.PutString(m.ApiHash)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_sendCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_sendCode, layer)
	}
}

// Decode <--
func (m *TLAuthSendCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa677244f: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.ApiId, err = d.Int32()
			m.ApiHash, err = d.String()

			// m4 := &CodeSettings{}
			// _ = m4.Decode(d)
			// m.Settings = m4
			m.Settings, _ = DecodeCodeSettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthSignUp <--
type TLAuthSignUp struct {
	ClazzID               uint32 `json:"_id"`
	NoJoinedNotifications bool   `json:"no_joined_notifications"`
	PhoneNumber           string `json:"phone_number"`
	PhoneCodeHash         string `json:"phone_code_hash"`
	FirstName             string `json:"first_name"`
	LastName              string `json:"last_name"`
}

func (m *TLAuthSignUp) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthSignUp) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaac7b717: func() error {
			x.PutClazzID(0xaac7b717)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoJoinedNotifications == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			x.PutString(m.FirstName)
			x.PutString(m.LastName)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_signUp, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_signUp, layer)
	}
}

// Decode <--
func (m *TLAuthSignUp) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaac7b717: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.NoJoinedNotifications = true
			}
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			m.FirstName, err = d.String()
			m.LastName, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthSignIn <--
type TLAuthSignIn struct {
	ClazzID           uint32                 `json:"_id"`
	PhoneNumber       string                 `json:"phone_number"`
	PhoneCodeHash     string                 `json:"phone_code_hash"`
	PhoneCode         *string                `json:"phone_code"`
	EmailVerification EmailVerificationClazz `json:"email_verification"`
}

func (m *TLAuthSignIn) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthSignIn) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8d52a951: func() error {
			x.PutClazzID(0x8d52a951)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.PhoneCode != nil {
					flags |= 1 << 0
				}
				if m.EmailVerification != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			if m.PhoneCode != nil {
				x.PutString(*m.PhoneCode)
			}

			if m.EmailVerification != nil {
				_ = m.EmailVerification.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_signIn, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_signIn, layer)
	}
}

// Decode <--
func (m *TLAuthSignIn) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8d52a951: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.PhoneCode = new(string)
				*m.PhoneCode, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				// m5 := &EmailVerification{}
				// _ = m5.Decode(d)
				// m.EmailVerification = m5
				m.EmailVerification, _ = DecodeEmailVerificationClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthLogOut <--
type TLAuthLogOut struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAuthLogOut) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthLogOut) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3e72ba19: func() error {
			x.PutClazzID(0x3e72ba19)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_logOut, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_logOut, layer)
	}
}

// Decode <--
func (m *TLAuthLogOut) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3e72ba19: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthResetAuthorizations <--
type TLAuthResetAuthorizations struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAuthResetAuthorizations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthResetAuthorizations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9fab0d1a: func() error {
			x.PutClazzID(0x9fab0d1a)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_resetAuthorizations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_resetAuthorizations, layer)
	}
}

// Decode <--
func (m *TLAuthResetAuthorizations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9fab0d1a: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthExportAuthorization <--
type TLAuthExportAuthorization struct {
	ClazzID uint32 `json:"_id"`
	DcId    int32  `json:"dc_id"`
}

func (m *TLAuthExportAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthExportAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe5bfffcd: func() error {
			x.PutClazzID(0xe5bfffcd)

			x.PutInt32(m.DcId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_exportAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_exportAuthorization, layer)
	}
}

// Decode <--
func (m *TLAuthExportAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe5bfffcd: func() (err error) {
			m.DcId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthImportAuthorization <--
type TLAuthImportAuthorization struct {
	ClazzID uint32 `json:"_id"`
	Id      int64  `json:"id"`
	Bytes   []byte `json:"bytes"`
}

func (m *TLAuthImportAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthImportAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa57a7dad: func() error {
			x.PutClazzID(0xa57a7dad)

			x.PutInt64(m.Id)
			x.PutBytes(m.Bytes)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_importAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_importAuthorization, layer)
	}
}

// Decode <--
func (m *TLAuthImportAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa57a7dad: func() (err error) {
			m.Id, err = d.Int64()
			m.Bytes, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthBindTempAuthKey <--
type TLAuthBindTempAuthKey struct {
	ClazzID          uint32 `json:"_id"`
	PermAuthKeyId    int64  `json:"perm_auth_key_id"`
	Nonce            int64  `json:"nonce"`
	ExpiresAt        int32  `json:"expires_at"`
	EncryptedMessage []byte `json:"encrypted_message"`
}

func (m *TLAuthBindTempAuthKey) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthBindTempAuthKey) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcdd42a05: func() error {
			x.PutClazzID(0xcdd42a05)

			x.PutInt64(m.PermAuthKeyId)
			x.PutInt64(m.Nonce)
			x.PutInt32(m.ExpiresAt)
			x.PutBytes(m.EncryptedMessage)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_bindTempAuthKey, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_bindTempAuthKey, layer)
	}
}

// Decode <--
func (m *TLAuthBindTempAuthKey) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcdd42a05: func() (err error) {
			m.PermAuthKeyId, err = d.Int64()
			m.Nonce, err = d.Int64()
			m.ExpiresAt, err = d.Int32()
			m.EncryptedMessage, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthImportBotAuthorization <--
type TLAuthImportBotAuthorization struct {
	ClazzID      uint32 `json:"_id"`
	Flags        int32  `json:"flags"`
	ApiId        int32  `json:"api_id"`
	ApiHash      string `json:"api_hash"`
	BotAuthToken string `json:"bot_auth_token"`
}

func (m *TLAuthImportBotAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthImportBotAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x67a3ff2c: func() error {
			x.PutClazzID(0x67a3ff2c)

			x.PutInt32(m.Flags)
			x.PutInt32(m.ApiId)
			x.PutString(m.ApiHash)
			x.PutString(m.BotAuthToken)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_importBotAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_importBotAuthorization, layer)
	}
}

// Decode <--
func (m *TLAuthImportBotAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x67a3ff2c: func() (err error) {
			m.Flags, err = d.Int32()
			m.ApiId, err = d.Int32()
			m.ApiHash, err = d.String()
			m.BotAuthToken, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthCheckPassword <--
type TLAuthCheckPassword struct {
	ClazzID  uint32                     `json:"_id"`
	Password InputCheckPasswordSRPClazz `json:"password"`
}

func (m *TLAuthCheckPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthCheckPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd18b4d16: func() error {
			x.PutClazzID(0xd18b4d16)

			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_checkPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_checkPassword, layer)
	}
}

// Decode <--
func (m *TLAuthCheckPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd18b4d16: func() (err error) {

			// m1 := &InputCheckPasswordSRP{}
			// _ = m1.Decode(d)
			// m.Password = m1
			m.Password, _ = DecodeInputCheckPasswordSRPClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthRequestPasswordRecovery <--
type TLAuthRequestPasswordRecovery struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAuthRequestPasswordRecovery) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthRequestPasswordRecovery) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd897bc66: func() error {
			x.PutClazzID(0xd897bc66)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_requestPasswordRecovery, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_requestPasswordRecovery, layer)
	}
}

// Decode <--
func (m *TLAuthRequestPasswordRecovery) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd897bc66: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthRecoverPassword <--
type TLAuthRecoverPassword struct {
	ClazzID     uint32                            `json:"_id"`
	Code        string                            `json:"code"`
	NewSettings AccountPasswordInputSettingsClazz `json:"new_settings"`
}

func (m *TLAuthRecoverPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthRecoverPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x37096c70: func() error {
			x.PutClazzID(0x37096c70)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NewSettings != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Code)
			if m.NewSettings != nil {
				_ = m.NewSettings.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_recoverPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_recoverPassword, layer)
	}
}

// Decode <--
func (m *TLAuthRecoverPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x37096c70: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Code, err = d.String()
			if (flags & (1 << 0)) != 0 {
				// m3 := &AccountPasswordInputSettings{}
				// _ = m3.Decode(d)
				// m.NewSettings = m3
				m.NewSettings, _ = DecodeAccountPasswordInputSettingsClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthResendCode <--
type TLAuthResendCode struct {
	ClazzID       uint32  `json:"_id"`
	PhoneNumber   string  `json:"phone_number"`
	PhoneCodeHash string  `json:"phone_code_hash"`
	Reason        *string `json:"reason"`
}

func (m *TLAuthResendCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthResendCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcae47523: func() error {
			x.PutClazzID(0xcae47523)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Reason != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			if m.Reason != nil {
				x.PutString(*m.Reason)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_resendCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_resendCode, layer)
	}
}

// Decode <--
func (m *TLAuthResendCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcae47523: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.Reason = new(string)
				*m.Reason, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthCancelCode <--
type TLAuthCancelCode struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
}

func (m *TLAuthCancelCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthCancelCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1f040578: func() error {
			x.PutClazzID(0x1f040578)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_cancelCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_cancelCode, layer)
	}
}

// Decode <--
func (m *TLAuthCancelCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1f040578: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthDropTempAuthKeys <--
type TLAuthDropTempAuthKeys struct {
	ClazzID        uint32  `json:"_id"`
	ExceptAuthKeys []int64 `json:"except_auth_keys"`
}

func (m *TLAuthDropTempAuthKeys) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthDropTempAuthKeys) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8e48a188: func() error {
			x.PutClazzID(0x8e48a188)

			iface.EncodeInt64List(x, m.ExceptAuthKeys)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_dropTempAuthKeys, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_dropTempAuthKeys, layer)
	}
}

// Decode <--
func (m *TLAuthDropTempAuthKeys) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8e48a188: func() (err error) {

			m.ExceptAuthKeys, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthExportLoginToken <--
type TLAuthExportLoginToken struct {
	ClazzID   uint32  `json:"_id"`
	ApiId     int32   `json:"api_id"`
	ApiHash   string  `json:"api_hash"`
	ExceptIds []int64 `json:"except_ids"`
}

func (m *TLAuthExportLoginToken) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthExportLoginToken) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb7e085fe: func() error {
			x.PutClazzID(0xb7e085fe)

			x.PutInt32(m.ApiId)
			x.PutString(m.ApiHash)

			iface.EncodeInt64List(x, m.ExceptIds)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_exportLoginToken, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_exportLoginToken, layer)
	}
}

// Decode <--
func (m *TLAuthExportLoginToken) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb7e085fe: func() (err error) {
			m.ApiId, err = d.Int32()
			m.ApiHash, err = d.String()

			m.ExceptIds, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthImportLoginToken <--
type TLAuthImportLoginToken struct {
	ClazzID uint32 `json:"_id"`
	Token   []byte `json:"token"`
}

func (m *TLAuthImportLoginToken) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthImportLoginToken) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x95ac5ce4: func() error {
			x.PutClazzID(0x95ac5ce4)

			x.PutBytes(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_importLoginToken, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_importLoginToken, layer)
	}
}

// Decode <--
func (m *TLAuthImportLoginToken) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x95ac5ce4: func() (err error) {
			m.Token, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthAcceptLoginToken <--
type TLAuthAcceptLoginToken struct {
	ClazzID uint32 `json:"_id"`
	Token   []byte `json:"token"`
}

func (m *TLAuthAcceptLoginToken) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthAcceptLoginToken) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe894ad4d: func() error {
			x.PutClazzID(0xe894ad4d)

			x.PutBytes(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_acceptLoginToken, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_acceptLoginToken, layer)
	}
}

// Decode <--
func (m *TLAuthAcceptLoginToken) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe894ad4d: func() (err error) {
			m.Token, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthCheckRecoveryPassword <--
type TLAuthCheckRecoveryPassword struct {
	ClazzID uint32 `json:"_id"`
	Code    string `json:"code"`
}

func (m *TLAuthCheckRecoveryPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthCheckRecoveryPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd36bf79: func() error {
			x.PutClazzID(0xd36bf79)

			x.PutString(m.Code)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_checkRecoveryPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_checkRecoveryPassword, layer)
	}
}

// Decode <--
func (m *TLAuthCheckRecoveryPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd36bf79: func() (err error) {
			m.Code, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthImportWebTokenAuthorization <--
type TLAuthImportWebTokenAuthorization struct {
	ClazzID      uint32 `json:"_id"`
	ApiId        int32  `json:"api_id"`
	ApiHash      string `json:"api_hash"`
	WebAuthToken string `json:"web_auth_token"`
}

func (m *TLAuthImportWebTokenAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthImportWebTokenAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2db873a9: func() error {
			x.PutClazzID(0x2db873a9)

			x.PutInt32(m.ApiId)
			x.PutString(m.ApiHash)
			x.PutString(m.WebAuthToken)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_importWebTokenAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_importWebTokenAuthorization, layer)
	}
}

// Decode <--
func (m *TLAuthImportWebTokenAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2db873a9: func() (err error) {
			m.ApiId, err = d.Int32()
			m.ApiHash, err = d.String()
			m.WebAuthToken, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthRequestFirebaseSms <--
type TLAuthRequestFirebaseSms struct {
	ClazzID            uint32  `json:"_id"`
	PhoneNumber        string  `json:"phone_number"`
	PhoneCodeHash      string  `json:"phone_code_hash"`
	SafetyNetToken     *string `json:"safety_net_token"`
	PlayIntegrityToken *string `json:"play_integrity_token"`
	IosPushSecret      *string `json:"ios_push_secret"`
}

func (m *TLAuthRequestFirebaseSms) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthRequestFirebaseSms) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8e39261e: func() error {
			x.PutClazzID(0x8e39261e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SafetyNetToken != nil {
					flags |= 1 << 0
				}
				if m.PlayIntegrityToken != nil {
					flags |= 1 << 2
				}
				if m.IosPushSecret != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			if m.SafetyNetToken != nil {
				x.PutString(*m.SafetyNetToken)
			}

			if m.PlayIntegrityToken != nil {
				x.PutString(*m.PlayIntegrityToken)
			}

			if m.IosPushSecret != nil {
				x.PutString(*m.IosPushSecret)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_requestFirebaseSms, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_requestFirebaseSms, layer)
	}
}

// Decode <--
func (m *TLAuthRequestFirebaseSms) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8e39261e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.SafetyNetToken = new(string)
				*m.SafetyNetToken, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.PlayIntegrityToken = new(string)
				*m.PlayIntegrityToken, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.IosPushSecret = new(string)
				*m.IosPushSecret, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthResetLoginEmail <--
type TLAuthResetLoginEmail struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
}

func (m *TLAuthResetLoginEmail) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthResetLoginEmail) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7e960193: func() error {
			x.PutClazzID(0x7e960193)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_resetLoginEmail, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_resetLoginEmail, layer)
	}
}

// Decode <--
func (m *TLAuthResetLoginEmail) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7e960193: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthReportMissingCode <--
type TLAuthReportMissingCode struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
	Mnc           string `json:"mnc"`
}

func (m *TLAuthReportMissingCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthReportMissingCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcb9deff6: func() error {
			x.PutClazzID(0xcb9deff6)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			x.PutString(m.Mnc)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_reportMissingCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_reportMissingCode, layer)
	}
}

// Decode <--
func (m *TLAuthReportMissingCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcb9deff6: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			m.Mnc, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthCheckPaidAuth <--
type TLAuthCheckPaidAuth struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
	FormId        int64  `json:"form_id"`
}

func (m *TLAuthCheckPaidAuth) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthCheckPaidAuth) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x56e59f9c: func() error {
			x.PutClazzID(0x56e59f9c)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			x.PutInt64(m.FormId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_checkPaidAuth, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_checkPaidAuth, layer)
	}
}

// Decode <--
func (m *TLAuthCheckPaidAuth) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x56e59f9c: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			m.FormId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountRegisterDevice <--
type TLAccountRegisterDevice struct {
	ClazzID    uint32    `json:"_id"`
	NoMuted    bool      `json:"no_muted"`
	TokenType  int32     `json:"token_type"`
	Token      string    `json:"token"`
	AppSandbox BoolClazz `json:"app_sandbox"`
	Secret     []byte    `json:"secret"`
	OtherUids  []int64   `json:"other_uids"`
}

func (m *TLAccountRegisterDevice) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountRegisterDevice) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xec86017a: func() error {
			x.PutClazzID(0xec86017a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoMuted == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.TokenType)
			x.PutString(m.Token)
			_ = m.AppSandbox.Encode(x, layer)
			x.PutBytes(m.Secret)

			iface.EncodeInt64List(x, m.OtherUids)

			return nil
		},
		0x637ea878: func() error {
			x.PutClazzID(0x637ea878)

			x.PutInt32(m.TokenType)
			x.PutString(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_registerDevice, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_registerDevice, layer)
	}
}

// Decode <--
func (m *TLAccountRegisterDevice) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xec86017a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.NoMuted = true
			}
			m.TokenType, err = d.Int32()
			m.Token, err = d.String()

			// m5 := &Bool{}
			// _ = m5.Decode(d)
			// m.AppSandbox = m5
			m.AppSandbox, _ = DecodeBoolClazz(d)

			m.Secret, err = d.Bytes()

			m.OtherUids, err = iface.DecodeInt64List(d)

			return nil
		},
		0x637ea878: func() (err error) {
			m.TokenType, err = d.Int32()
			m.Token, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUnregisterDevice <--
type TLAccountUnregisterDevice struct {
	ClazzID   uint32  `json:"_id"`
	TokenType int32   `json:"token_type"`
	Token     string  `json:"token"`
	OtherUids []int64 `json:"other_uids"`
}

func (m *TLAccountUnregisterDevice) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUnregisterDevice) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6a0d3206: func() error {
			x.PutClazzID(0x6a0d3206)

			x.PutInt32(m.TokenType)
			x.PutString(m.Token)

			iface.EncodeInt64List(x, m.OtherUids)

			return nil
		},
		0x65c55b40: func() error {
			x.PutClazzID(0x65c55b40)

			x.PutInt32(m.TokenType)
			x.PutString(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_unregisterDevice, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_unregisterDevice, layer)
	}
}

// Decode <--
func (m *TLAccountUnregisterDevice) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6a0d3206: func() (err error) {
			m.TokenType, err = d.Int32()
			m.Token, err = d.String()

			m.OtherUids, err = iface.DecodeInt64List(d)

			return nil
		},
		0x65c55b40: func() (err error) {
			m.TokenType, err = d.Int32()
			m.Token, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateNotifySettings <--
type TLAccountUpdateNotifySettings struct {
	ClazzID  uint32                       `json:"_id"`
	Peer     InputNotifyPeerClazz         `json:"peer"`
	Settings InputPeerNotifySettingsClazz `json:"settings"`
}

func (m *TLAccountUpdateNotifySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateNotifySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x84be5b93: func() error {
			x.PutClazzID(0x84be5b93)

			_ = m.Peer.Encode(x, layer)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateNotifySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateNotifySettings, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateNotifySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x84be5b93: func() (err error) {

			// m1 := &InputNotifyPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputNotifyPeerClazz(d)

			// m2 := &InputPeerNotifySettings{}
			// _ = m2.Decode(d)
			// m.Settings = m2
			m.Settings, _ = DecodeInputPeerNotifySettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetNotifySettings <--
type TLAccountGetNotifySettings struct {
	ClazzID uint32               `json:"_id"`
	Peer    InputNotifyPeerClazz `json:"peer"`
}

func (m *TLAccountGetNotifySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetNotifySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x12b3ad31: func() error {
			x.PutClazzID(0x12b3ad31)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getNotifySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getNotifySettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetNotifySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x12b3ad31: func() (err error) {

			// m1 := &InputNotifyPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputNotifyPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetNotifySettings <--
type TLAccountResetNotifySettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountResetNotifySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetNotifySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdb7e1747: func() error {
			x.PutClazzID(0xdb7e1747)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetNotifySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetNotifySettings, layer)
	}
}

// Decode <--
func (m *TLAccountResetNotifySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdb7e1747: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateProfile <--
type TLAccountUpdateProfile struct {
	ClazzID   uint32  `json:"_id"`
	FirstName *string `json:"first_name"`
	LastName  *string `json:"last_name"`
	About     *string `json:"about"`
}

func (m *TLAccountUpdateProfile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateProfile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x78515775: func() error {
			x.PutClazzID(0x78515775)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FirstName != nil {
					flags |= 1 << 0
				}
				if m.LastName != nil {
					flags |= 1 << 1
				}
				if m.About != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.FirstName != nil {
				x.PutString(*m.FirstName)
			}

			if m.LastName != nil {
				x.PutString(*m.LastName)
			}

			if m.About != nil {
				x.PutString(*m.About)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateProfile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateProfile, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateProfile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x78515775: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.FirstName = new(string)
				*m.FirstName, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.LastName = new(string)
				*m.LastName, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.About = new(string)
				*m.About, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateStatus <--
type TLAccountUpdateStatus struct {
	ClazzID uint32    `json:"_id"`
	Offline BoolClazz `json:"offline"`
}

func (m *TLAccountUpdateStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6628562c: func() error {
			x.PutClazzID(0x6628562c)

			_ = m.Offline.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateStatus, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6628562c: func() (err error) {

			// m1 := &Bool{}
			// _ = m1.Decode(d)
			// m.Offline = m1
			m.Offline, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetWallPapers <--
type TLAccountGetWallPapers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetWallPapers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetWallPapers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7967d36: func() error {
			x.PutClazzID(0x7967d36)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getWallPapers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getWallPapers, layer)
	}
}

// Decode <--
func (m *TLAccountGetWallPapers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7967d36: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountReportPeer <--
type TLAccountReportPeer struct {
	ClazzID uint32            `json:"_id"`
	Peer    InputPeerClazz    `json:"peer"`
	Reason  ReportReasonClazz `json:"reason"`
	Message string            `json:"message"`
}

func (m *TLAccountReportPeer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountReportPeer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc5ba3d86: func() error {
			x.PutClazzID(0xc5ba3d86)

			_ = m.Peer.Encode(x, layer)
			_ = m.Reason.Encode(x, layer)
			x.PutString(m.Message)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_reportPeer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_reportPeer, layer)
	}
}

// Decode <--
func (m *TLAccountReportPeer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc5ba3d86: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &ReportReason{}
			// _ = m2.Decode(d)
			// m.Reason = m2
			m.Reason, _ = DecodeReportReasonClazz(d)

			m.Message, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountCheckUsername <--
type TLAccountCheckUsername struct {
	ClazzID  uint32 `json:"_id"`
	Username string `json:"username"`
}

func (m *TLAccountCheckUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountCheckUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2714d86c: func() error {
			x.PutClazzID(0x2714d86c)

			x.PutString(m.Username)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_checkUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_checkUsername, layer)
	}
}

// Decode <--
func (m *TLAccountCheckUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2714d86c: func() (err error) {
			m.Username, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateUsername <--
type TLAccountUpdateUsername struct {
	ClazzID  uint32 `json:"_id"`
	Username string `json:"username"`
}

func (m *TLAccountUpdateUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3e0bdd7c: func() error {
			x.PutClazzID(0x3e0bdd7c)

			x.PutString(m.Username)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateUsername, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3e0bdd7c: func() (err error) {
			m.Username, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetPrivacy <--
type TLAccountGetPrivacy struct {
	ClazzID uint32               `json:"_id"`
	Key     InputPrivacyKeyClazz `json:"key"`
}

func (m *TLAccountGetPrivacy) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetPrivacy) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdadbc950: func() error {
			x.PutClazzID(0xdadbc950)

			_ = m.Key.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getPrivacy, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getPrivacy, layer)
	}
}

// Decode <--
func (m *TLAccountGetPrivacy) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdadbc950: func() (err error) {

			// m1 := &InputPrivacyKey{}
			// _ = m1.Decode(d)
			// m.Key = m1
			m.Key, _ = DecodeInputPrivacyKeyClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetPrivacy <--
type TLAccountSetPrivacy struct {
	ClazzID uint32                  `json:"_id"`
	Key     InputPrivacyKeyClazz    `json:"key"`
	Rules   []InputPrivacyRuleClazz `json:"rules"`
}

func (m *TLAccountSetPrivacy) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetPrivacy) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc9f81ce8: func() error {
			x.PutClazzID(0xc9f81ce8)

			_ = m.Key.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Rules, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setPrivacy, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setPrivacy, layer)
	}
}

// Decode <--
func (m *TLAccountSetPrivacy) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc9f81ce8: func() (err error) {

			// m1 := &InputPrivacyKey{}
			// _ = m1.Decode(d)
			// m.Key = m1
			m.Key, _ = DecodeInputPrivacyKeyClazz(d)

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputPrivacyRule, l2)
			v2 := make([]InputPrivacyRuleClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputPrivacyRule)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputPrivacyRuleClazz(d)
				_ = err3
			}
			m.Rules = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDeleteAccount <--
type TLAccountDeleteAccount struct {
	ClazzID  uint32                     `json:"_id"`
	Reason   string                     `json:"reason"`
	Password InputCheckPasswordSRPClazz `json:"password"`
}

func (m *TLAccountDeleteAccount) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDeleteAccount) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa2c0cf74: func() error {
			x.PutClazzID(0xa2c0cf74)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Password != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Reason)
			if m.Password != nil {
				_ = m.Password.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_deleteAccount, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_deleteAccount, layer)
	}
}

// Decode <--
func (m *TLAccountDeleteAccount) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa2c0cf74: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Reason, err = d.String()
			if (flags & (1 << 0)) != 0 {
				// m3 := &InputCheckPasswordSRP{}
				// _ = m3.Decode(d)
				// m.Password = m3
				m.Password, _ = DecodeInputCheckPasswordSRPClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAccountTTL <--
type TLAccountGetAccountTTL struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetAccountTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAccountTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8fc711d: func() error {
			x.PutClazzID(0x8fc711d)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAccountTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAccountTTL, layer)
	}
}

// Decode <--
func (m *TLAccountGetAccountTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8fc711d: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetAccountTTL <--
type TLAccountSetAccountTTL struct {
	ClazzID uint32              `json:"_id"`
	Ttl     AccountDaysTTLClazz `json:"ttl"`
}

func (m *TLAccountSetAccountTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetAccountTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2442485e: func() error {
			x.PutClazzID(0x2442485e)

			_ = m.Ttl.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setAccountTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setAccountTTL, layer)
	}
}

// Decode <--
func (m *TLAccountSetAccountTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2442485e: func() (err error) {

			// m1 := &AccountDaysTTL{}
			// _ = m1.Decode(d)
			// m.Ttl = m1
			m.Ttl, _ = DecodeAccountDaysTTLClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSendChangePhoneCode <--
type TLAccountSendChangePhoneCode struct {
	ClazzID     uint32            `json:"_id"`
	PhoneNumber string            `json:"phone_number"`
	Settings    CodeSettingsClazz `json:"settings"`
}

func (m *TLAccountSendChangePhoneCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSendChangePhoneCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x82574ae5: func() error {
			x.PutClazzID(0x82574ae5)

			x.PutString(m.PhoneNumber)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_sendChangePhoneCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_sendChangePhoneCode, layer)
	}
}

// Decode <--
func (m *TLAccountSendChangePhoneCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x82574ae5: func() (err error) {
			m.PhoneNumber, err = d.String()

			// m2 := &CodeSettings{}
			// _ = m2.Decode(d)
			// m.Settings = m2
			m.Settings, _ = DecodeCodeSettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountChangePhone <--
type TLAccountChangePhone struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
	PhoneCode     string `json:"phone_code"`
}

func (m *TLAccountChangePhone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountChangePhone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x70c32edb: func() error {
			x.PutClazzID(0x70c32edb)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			x.PutString(m.PhoneCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_changePhone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_changePhone, layer)
	}
}

// Decode <--
func (m *TLAccountChangePhone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x70c32edb: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			m.PhoneCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateDeviceLocked <--
type TLAccountUpdateDeviceLocked struct {
	ClazzID uint32 `json:"_id"`
	Period  int32  `json:"period"`
}

func (m *TLAccountUpdateDeviceLocked) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateDeviceLocked) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x38df3532: func() error {
			x.PutClazzID(0x38df3532)

			x.PutInt32(m.Period)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateDeviceLocked, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateDeviceLocked, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateDeviceLocked) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x38df3532: func() (err error) {
			m.Period, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAuthorizations <--
type TLAccountGetAuthorizations struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetAuthorizations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAuthorizations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe320c158: func() error {
			x.PutClazzID(0xe320c158)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAuthorizations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAuthorizations, layer)
	}
}

// Decode <--
func (m *TLAccountGetAuthorizations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe320c158: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetAuthorization <--
type TLAccountResetAuthorization struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountResetAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdf77f3bc: func() error {
			x.PutClazzID(0xdf77f3bc)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetAuthorization, layer)
	}
}

// Decode <--
func (m *TLAccountResetAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdf77f3bc: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetPassword <--
type TLAccountGetPassword struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x548a30f5: func() error {
			x.PutClazzID(0x548a30f5)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getPassword, layer)
	}
}

// Decode <--
func (m *TLAccountGetPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x548a30f5: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetPasswordSettings <--
type TLAccountGetPasswordSettings struct {
	ClazzID  uint32                     `json:"_id"`
	Password InputCheckPasswordSRPClazz `json:"password"`
}

func (m *TLAccountGetPasswordSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetPasswordSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9cd4eaf9: func() error {
			x.PutClazzID(0x9cd4eaf9)

			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getPasswordSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getPasswordSettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetPasswordSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9cd4eaf9: func() (err error) {

			// m1 := &InputCheckPasswordSRP{}
			// _ = m1.Decode(d)
			// m.Password = m1
			m.Password, _ = DecodeInputCheckPasswordSRPClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdatePasswordSettings <--
type TLAccountUpdatePasswordSettings struct {
	ClazzID     uint32                            `json:"_id"`
	Password    InputCheckPasswordSRPClazz        `json:"password"`
	NewSettings AccountPasswordInputSettingsClazz `json:"new_settings"`
}

func (m *TLAccountUpdatePasswordSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdatePasswordSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa59b102f: func() error {
			x.PutClazzID(0xa59b102f)

			_ = m.Password.Encode(x, layer)
			_ = m.NewSettings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updatePasswordSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updatePasswordSettings, layer)
	}
}

// Decode <--
func (m *TLAccountUpdatePasswordSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa59b102f: func() (err error) {

			// m1 := &InputCheckPasswordSRP{}
			// _ = m1.Decode(d)
			// m.Password = m1
			m.Password, _ = DecodeInputCheckPasswordSRPClazz(d)

			// m2 := &AccountPasswordInputSettings{}
			// _ = m2.Decode(d)
			// m.NewSettings = m2
			m.NewSettings, _ = DecodeAccountPasswordInputSettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSendConfirmPhoneCode <--
type TLAccountSendConfirmPhoneCode struct {
	ClazzID  uint32            `json:"_id"`
	Hash     string            `json:"hash"`
	Settings CodeSettingsClazz `json:"settings"`
}

func (m *TLAccountSendConfirmPhoneCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSendConfirmPhoneCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1b3faa88: func() error {
			x.PutClazzID(0x1b3faa88)

			x.PutString(m.Hash)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_sendConfirmPhoneCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_sendConfirmPhoneCode, layer)
	}
}

// Decode <--
func (m *TLAccountSendConfirmPhoneCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1b3faa88: func() (err error) {
			m.Hash, err = d.String()

			// m2 := &CodeSettings{}
			// _ = m2.Decode(d)
			// m.Settings = m2
			m.Settings, _ = DecodeCodeSettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountConfirmPhone <--
type TLAccountConfirmPhone struct {
	ClazzID       uint32 `json:"_id"`
	PhoneCodeHash string `json:"phone_code_hash"`
	PhoneCode     string `json:"phone_code"`
}

func (m *TLAccountConfirmPhone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountConfirmPhone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5f2178c3: func() error {
			x.PutClazzID(0x5f2178c3)

			x.PutString(m.PhoneCodeHash)
			x.PutString(m.PhoneCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_confirmPhone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_confirmPhone, layer)
	}
}

// Decode <--
func (m *TLAccountConfirmPhone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5f2178c3: func() (err error) {
			m.PhoneCodeHash, err = d.String()
			m.PhoneCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetTmpPassword <--
type TLAccountGetTmpPassword struct {
	ClazzID  uint32                     `json:"_id"`
	Password InputCheckPasswordSRPClazz `json:"password"`
	Period   int32                      `json:"period"`
}

func (m *TLAccountGetTmpPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetTmpPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x449e0b51: func() error {
			x.PutClazzID(0x449e0b51)

			_ = m.Password.Encode(x, layer)
			x.PutInt32(m.Period)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getTmpPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getTmpPassword, layer)
	}
}

// Decode <--
func (m *TLAccountGetTmpPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x449e0b51: func() (err error) {

			// m1 := &InputCheckPasswordSRP{}
			// _ = m1.Decode(d)
			// m.Password = m1
			m.Password, _ = DecodeInputCheckPasswordSRPClazz(d)

			m.Period, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetWebAuthorizations <--
type TLAccountGetWebAuthorizations struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetWebAuthorizations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetWebAuthorizations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x182e6d6f: func() error {
			x.PutClazzID(0x182e6d6f)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getWebAuthorizations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getWebAuthorizations, layer)
	}
}

// Decode <--
func (m *TLAccountGetWebAuthorizations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x182e6d6f: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetWebAuthorization <--
type TLAccountResetWebAuthorization struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountResetWebAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetWebAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2d01b9ef: func() error {
			x.PutClazzID(0x2d01b9ef)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetWebAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetWebAuthorization, layer)
	}
}

// Decode <--
func (m *TLAccountResetWebAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2d01b9ef: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetWebAuthorizations <--
type TLAccountResetWebAuthorizations struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountResetWebAuthorizations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetWebAuthorizations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x682d2594: func() error {
			x.PutClazzID(0x682d2594)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetWebAuthorizations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetWebAuthorizations, layer)
	}
}

// Decode <--
func (m *TLAccountResetWebAuthorizations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x682d2594: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAllSecureValues <--
type TLAccountGetAllSecureValues struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetAllSecureValues) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAllSecureValues) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb288bc7d: func() error {
			x.PutClazzID(0xb288bc7d)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAllSecureValues, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAllSecureValues, layer)
	}
}

// Decode <--
func (m *TLAccountGetAllSecureValues) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb288bc7d: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetSecureValue <--
type TLAccountGetSecureValue struct {
	ClazzID uint32                 `json:"_id"`
	Types   []SecureValueTypeClazz `json:"types"`
}

func (m *TLAccountGetSecureValue) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetSecureValue) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x73665bc2: func() error {
			x.PutClazzID(0x73665bc2)

			_ = iface.EncodeObjectList(x, m.Types, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getSecureValue, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getSecureValue, layer)
	}
}

// Decode <--
func (m *TLAccountGetSecureValue) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x73665bc2: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*SecureValueType, l1)
			v1 := make([]SecureValueTypeClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(SecureValueType)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeSecureValueTypeClazz(d)
				_ = err3
			}
			m.Types = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveSecureValue <--
type TLAccountSaveSecureValue struct {
	ClazzID        uint32                `json:"_id"`
	Value          InputSecureValueClazz `json:"value"`
	SecureSecretId int64                 `json:"secure_secret_id"`
}

func (m *TLAccountSaveSecureValue) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveSecureValue) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x899fe31d: func() error {
			x.PutClazzID(0x899fe31d)

			_ = m.Value.Encode(x, layer)
			x.PutInt64(m.SecureSecretId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveSecureValue, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveSecureValue, layer)
	}
}

// Decode <--
func (m *TLAccountSaveSecureValue) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x899fe31d: func() (err error) {

			// m1 := &InputSecureValue{}
			// _ = m1.Decode(d)
			// m.Value = m1
			m.Value, _ = DecodeInputSecureValueClazz(d)

			m.SecureSecretId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDeleteSecureValue <--
type TLAccountDeleteSecureValue struct {
	ClazzID uint32                 `json:"_id"`
	Types   []SecureValueTypeClazz `json:"types"`
}

func (m *TLAccountDeleteSecureValue) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDeleteSecureValue) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb880bc4b: func() error {
			x.PutClazzID(0xb880bc4b)

			_ = iface.EncodeObjectList(x, m.Types, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_deleteSecureValue, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_deleteSecureValue, layer)
	}
}

// Decode <--
func (m *TLAccountDeleteSecureValue) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb880bc4b: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*SecureValueType, l1)
			v1 := make([]SecureValueTypeClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(SecureValueType)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeSecureValueTypeClazz(d)
				_ = err3
			}
			m.Types = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAuthorizationForm <--
type TLAccountGetAuthorizationForm struct {
	ClazzID   uint32 `json:"_id"`
	BotId     int64  `json:"bot_id"`
	Scope     string `json:"scope"`
	PublicKey string `json:"public_key"`
}

func (m *TLAccountGetAuthorizationForm) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAuthorizationForm) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa929597a: func() error {
			x.PutClazzID(0xa929597a)

			x.PutInt64(m.BotId)
			x.PutString(m.Scope)
			x.PutString(m.PublicKey)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAuthorizationForm, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAuthorizationForm, layer)
	}
}

// Decode <--
func (m *TLAccountGetAuthorizationForm) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa929597a: func() (err error) {
			m.BotId, err = d.Int64()
			m.Scope, err = d.String()
			m.PublicKey, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountAcceptAuthorization <--
type TLAccountAcceptAuthorization struct {
	ClazzID     uint32                          `json:"_id"`
	BotId       int64                           `json:"bot_id"`
	Scope       string                          `json:"scope"`
	PublicKey   string                          `json:"public_key"`
	ValueHashes []SecureValueHashClazz          `json:"value_hashes"`
	Credentials SecureCredentialsEncryptedClazz `json:"credentials"`
}

func (m *TLAccountAcceptAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountAcceptAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf3ed4c73: func() error {
			x.PutClazzID(0xf3ed4c73)

			x.PutInt64(m.BotId)
			x.PutString(m.Scope)
			x.PutString(m.PublicKey)

			_ = iface.EncodeObjectList(x, m.ValueHashes, layer)

			_ = m.Credentials.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_acceptAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_acceptAuthorization, layer)
	}
}

// Decode <--
func (m *TLAccountAcceptAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf3ed4c73: func() (err error) {
			m.BotId, err = d.Int64()
			m.Scope, err = d.String()
			m.PublicKey, err = d.String()
			c4, err2 := d.ClazzID()
			if c4 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
				return err2
			}
			l4, err3 := d.Int()
			// v4 := make([]*SecureValueHash, l4)
			v4 := make([]SecureValueHashClazz, l4)
			for i := 0; i < l4; i++ {
				// vv := new(SecureValueHash)
				// err3 = vv.Decode(d)
				// _ = err3
				// v4[i] = vv
				v4[i], _ = DecodeSecureValueHashClazz(d)
				_ = err3
			}
			m.ValueHashes = v4

			// m5 := &SecureCredentialsEncrypted{}
			// _ = m5.Decode(d)
			// m.Credentials = m5
			m.Credentials, _ = DecodeSecureCredentialsEncryptedClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSendVerifyPhoneCode <--
type TLAccountSendVerifyPhoneCode struct {
	ClazzID     uint32            `json:"_id"`
	PhoneNumber string            `json:"phone_number"`
	Settings    CodeSettingsClazz `json:"settings"`
}

func (m *TLAccountSendVerifyPhoneCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSendVerifyPhoneCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa5a356f9: func() error {
			x.PutClazzID(0xa5a356f9)

			x.PutString(m.PhoneNumber)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_sendVerifyPhoneCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_sendVerifyPhoneCode, layer)
	}
}

// Decode <--
func (m *TLAccountSendVerifyPhoneCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa5a356f9: func() (err error) {
			m.PhoneNumber, err = d.String()

			// m2 := &CodeSettings{}
			// _ = m2.Decode(d)
			// m.Settings = m2
			m.Settings, _ = DecodeCodeSettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountVerifyPhone <--
type TLAccountVerifyPhone struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
	PhoneCode     string `json:"phone_code"`
}

func (m *TLAccountVerifyPhone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountVerifyPhone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4dd3a7f6: func() error {
			x.PutClazzID(0x4dd3a7f6)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			x.PutString(m.PhoneCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_verifyPhone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_verifyPhone, layer)
	}
}

// Decode <--
func (m *TLAccountVerifyPhone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4dd3a7f6: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			m.PhoneCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSendVerifyEmailCode <--
type TLAccountSendVerifyEmailCode struct {
	ClazzID uint32                  `json:"_id"`
	Purpose EmailVerifyPurposeClazz `json:"purpose"`
	Email   string                  `json:"email"`
}

func (m *TLAccountSendVerifyEmailCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSendVerifyEmailCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x98e037bb: func() error {
			x.PutClazzID(0x98e037bb)

			_ = m.Purpose.Encode(x, layer)
			x.PutString(m.Email)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_sendVerifyEmailCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_sendVerifyEmailCode, layer)
	}
}

// Decode <--
func (m *TLAccountSendVerifyEmailCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x98e037bb: func() (err error) {

			// m1 := &EmailVerifyPurpose{}
			// _ = m1.Decode(d)
			// m.Purpose = m1
			m.Purpose, _ = DecodeEmailVerifyPurposeClazz(d)

			m.Email, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountVerifyEmail <--
type TLAccountVerifyEmail struct {
	ClazzID      uint32                  `json:"_id"`
	Purpose      EmailVerifyPurposeClazz `json:"purpose"`
	Verification EmailVerificationClazz  `json:"verification"`
}

func (m *TLAccountVerifyEmail) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountVerifyEmail) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x32da4cf: func() error {
			x.PutClazzID(0x32da4cf)

			_ = m.Purpose.Encode(x, layer)
			_ = m.Verification.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_verifyEmail, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_verifyEmail, layer)
	}
}

// Decode <--
func (m *TLAccountVerifyEmail) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x32da4cf: func() (err error) {

			// m1 := &EmailVerifyPurpose{}
			// _ = m1.Decode(d)
			// m.Purpose = m1
			m.Purpose, _ = DecodeEmailVerifyPurposeClazz(d)

			// m2 := &EmailVerification{}
			// _ = m2.Decode(d)
			// m.Verification = m2
			m.Verification, _ = DecodeEmailVerificationClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountInitTakeoutSession <--
type TLAccountInitTakeoutSession struct {
	ClazzID           uint32 `json:"_id"`
	Contacts          bool   `json:"contacts"`
	MessageUsers      bool   `json:"message_users"`
	MessageChats      bool   `json:"message_chats"`
	MessageMegagroups bool   `json:"message_megagroups"`
	MessageChannels   bool   `json:"message_channels"`
	Files             bool   `json:"files"`
	FileMaxSize       *int64 `json:"file_max_size"`
}

func (m *TLAccountInitTakeoutSession) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountInitTakeoutSession) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8ef3eab0: func() error {
			x.PutClazzID(0x8ef3eab0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Contacts == true {
					flags |= 1 << 0
				}
				if m.MessageUsers == true {
					flags |= 1 << 1
				}
				if m.MessageChats == true {
					flags |= 1 << 2
				}
				if m.MessageMegagroups == true {
					flags |= 1 << 3
				}
				if m.MessageChannels == true {
					flags |= 1 << 4
				}
				if m.Files == true {
					flags |= 1 << 5
				}
				if m.FileMaxSize != nil {
					flags |= 1 << 5
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.FileMaxSize != nil {
				x.PutInt64(*m.FileMaxSize)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_initTakeoutSession, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_initTakeoutSession, layer)
	}
}

// Decode <--
func (m *TLAccountInitTakeoutSession) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8ef3eab0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Contacts = true
			}
			if (flags & (1 << 1)) != 0 {
				m.MessageUsers = true
			}
			if (flags & (1 << 2)) != 0 {
				m.MessageChats = true
			}
			if (flags & (1 << 3)) != 0 {
				m.MessageMegagroups = true
			}
			if (flags & (1 << 4)) != 0 {
				m.MessageChannels = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Files = true
			}
			if (flags & (1 << 5)) != 0 {
				m.FileMaxSize = new(int64)
				*m.FileMaxSize, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountFinishTakeoutSession <--
type TLAccountFinishTakeoutSession struct {
	ClazzID uint32 `json:"_id"`
	Success bool   `json:"success"`
}

func (m *TLAccountFinishTakeoutSession) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountFinishTakeoutSession) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1d2652ee: func() error {
			x.PutClazzID(0x1d2652ee)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Success == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_finishTakeoutSession, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_finishTakeoutSession, layer)
	}
}

// Decode <--
func (m *TLAccountFinishTakeoutSession) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1d2652ee: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Success = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountConfirmPasswordEmail <--
type TLAccountConfirmPasswordEmail struct {
	ClazzID uint32 `json:"_id"`
	Code    string `json:"code"`
}

func (m *TLAccountConfirmPasswordEmail) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountConfirmPasswordEmail) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8fdf1920: func() error {
			x.PutClazzID(0x8fdf1920)

			x.PutString(m.Code)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_confirmPasswordEmail, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_confirmPasswordEmail, layer)
	}
}

// Decode <--
func (m *TLAccountConfirmPasswordEmail) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8fdf1920: func() (err error) {
			m.Code, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResendPasswordEmail <--
type TLAccountResendPasswordEmail struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountResendPasswordEmail) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResendPasswordEmail) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7a7f2a15: func() error {
			x.PutClazzID(0x7a7f2a15)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resendPasswordEmail, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resendPasswordEmail, layer)
	}
}

// Decode <--
func (m *TLAccountResendPasswordEmail) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7a7f2a15: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountCancelPasswordEmail <--
type TLAccountCancelPasswordEmail struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountCancelPasswordEmail) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountCancelPasswordEmail) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc1cbd5b6: func() error {
			x.PutClazzID(0xc1cbd5b6)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_cancelPasswordEmail, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_cancelPasswordEmail, layer)
	}
}

// Decode <--
func (m *TLAccountCancelPasswordEmail) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc1cbd5b6: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetContactSignUpNotification <--
type TLAccountGetContactSignUpNotification struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetContactSignUpNotification) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetContactSignUpNotification) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9f07c728: func() error {
			x.PutClazzID(0x9f07c728)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getContactSignUpNotification, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getContactSignUpNotification, layer)
	}
}

// Decode <--
func (m *TLAccountGetContactSignUpNotification) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9f07c728: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetContactSignUpNotification <--
type TLAccountSetContactSignUpNotification struct {
	ClazzID uint32    `json:"_id"`
	Silent  BoolClazz `json:"silent"`
}

func (m *TLAccountSetContactSignUpNotification) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetContactSignUpNotification) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcff43f61: func() error {
			x.PutClazzID(0xcff43f61)

			_ = m.Silent.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setContactSignUpNotification, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setContactSignUpNotification, layer)
	}
}

// Decode <--
func (m *TLAccountSetContactSignUpNotification) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcff43f61: func() (err error) {

			// m1 := &Bool{}
			// _ = m1.Decode(d)
			// m.Silent = m1
			m.Silent, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetNotifyExceptions <--
type TLAccountGetNotifyExceptions struct {
	ClazzID        uint32               `json:"_id"`
	CompareSound   bool                 `json:"compare_sound"`
	CompareStories bool                 `json:"compare_stories"`
	Peer           InputNotifyPeerClazz `json:"peer"`
}

func (m *TLAccountGetNotifyExceptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetNotifyExceptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x53577479: func() error {
			x.PutClazzID(0x53577479)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.CompareSound == true {
					flags |= 1 << 1
				}
				if m.CompareStories == true {
					flags |= 1 << 2
				}
				if m.Peer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getNotifyExceptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getNotifyExceptions, layer)
	}
}

// Decode <--
func (m *TLAccountGetNotifyExceptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x53577479: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.CompareSound = true
			}
			if (flags & (1 << 2)) != 0 {
				m.CompareStories = true
			}
			if (flags & (1 << 0)) != 0 {
				// m4 := &InputNotifyPeer{}
				// _ = m4.Decode(d)
				// m.Peer = m4
				m.Peer, _ = DecodeInputNotifyPeerClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetWallPaper <--
type TLAccountGetWallPaper struct {
	ClazzID   uint32              `json:"_id"`
	Wallpaper InputWallPaperClazz `json:"wallpaper"`
}

func (m *TLAccountGetWallPaper) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetWallPaper) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfc8ddbea: func() error {
			x.PutClazzID(0xfc8ddbea)

			_ = m.Wallpaper.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getWallPaper, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getWallPaper, layer)
	}
}

// Decode <--
func (m *TLAccountGetWallPaper) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfc8ddbea: func() (err error) {

			// m1 := &InputWallPaper{}
			// _ = m1.Decode(d)
			// m.Wallpaper = m1
			m.Wallpaper, _ = DecodeInputWallPaperClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUploadWallPaper <--
type TLAccountUploadWallPaper struct {
	ClazzID  uint32                 `json:"_id"`
	ForChat  bool                   `json:"for_chat"`
	File     InputFileClazz         `json:"file"`
	MimeType string                 `json:"mime_type"`
	Settings WallPaperSettingsClazz `json:"settings"`
}

func (m *TLAccountUploadWallPaper) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUploadWallPaper) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe39a8f03: func() error {
			x.PutClazzID(0xe39a8f03)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForChat == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.File.Encode(x, layer)
			x.PutString(m.MimeType)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_uploadWallPaper, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_uploadWallPaper, layer)
	}
}

// Decode <--
func (m *TLAccountUploadWallPaper) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe39a8f03: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ForChat = true
			}

			// m3 := &InputFile{}
			// _ = m3.Decode(d)
			// m.File = m3
			m.File, _ = DecodeInputFileClazz(d)

			m.MimeType, err = d.String()

			// m5 := &WallPaperSettings{}
			// _ = m5.Decode(d)
			// m.Settings = m5
			m.Settings, _ = DecodeWallPaperSettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveWallPaper <--
type TLAccountSaveWallPaper struct {
	ClazzID   uint32                 `json:"_id"`
	Wallpaper InputWallPaperClazz    `json:"wallpaper"`
	Unsave    BoolClazz              `json:"unsave"`
	Settings  WallPaperSettingsClazz `json:"settings"`
}

func (m *TLAccountSaveWallPaper) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveWallPaper) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6c5a5b37: func() error {
			x.PutClazzID(0x6c5a5b37)

			_ = m.Wallpaper.Encode(x, layer)
			_ = m.Unsave.Encode(x, layer)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveWallPaper, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveWallPaper, layer)
	}
}

// Decode <--
func (m *TLAccountSaveWallPaper) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6c5a5b37: func() (err error) {

			// m1 := &InputWallPaper{}
			// _ = m1.Decode(d)
			// m.Wallpaper = m1
			m.Wallpaper, _ = DecodeInputWallPaperClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Unsave = m2
			m.Unsave, _ = DecodeBoolClazz(d)

			// m3 := &WallPaperSettings{}
			// _ = m3.Decode(d)
			// m.Settings = m3
			m.Settings, _ = DecodeWallPaperSettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountInstallWallPaper <--
type TLAccountInstallWallPaper struct {
	ClazzID   uint32                 `json:"_id"`
	Wallpaper InputWallPaperClazz    `json:"wallpaper"`
	Settings  WallPaperSettingsClazz `json:"settings"`
}

func (m *TLAccountInstallWallPaper) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountInstallWallPaper) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfeed5769: func() error {
			x.PutClazzID(0xfeed5769)

			_ = m.Wallpaper.Encode(x, layer)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_installWallPaper, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_installWallPaper, layer)
	}
}

// Decode <--
func (m *TLAccountInstallWallPaper) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfeed5769: func() (err error) {

			// m1 := &InputWallPaper{}
			// _ = m1.Decode(d)
			// m.Wallpaper = m1
			m.Wallpaper, _ = DecodeInputWallPaperClazz(d)

			// m2 := &WallPaperSettings{}
			// _ = m2.Decode(d)
			// m.Settings = m2
			m.Settings, _ = DecodeWallPaperSettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetWallPapers <--
type TLAccountResetWallPapers struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountResetWallPapers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetWallPapers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbb3b9804: func() error {
			x.PutClazzID(0xbb3b9804)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetWallPapers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetWallPapers, layer)
	}
}

// Decode <--
func (m *TLAccountResetWallPapers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbb3b9804: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAutoDownloadSettings <--
type TLAccountGetAutoDownloadSettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetAutoDownloadSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAutoDownloadSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x56da0b3f: func() error {
			x.PutClazzID(0x56da0b3f)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAutoDownloadSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAutoDownloadSettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetAutoDownloadSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x56da0b3f: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveAutoDownloadSettings <--
type TLAccountSaveAutoDownloadSettings struct {
	ClazzID  uint32                    `json:"_id"`
	Low      bool                      `json:"low"`
	High     bool                      `json:"high"`
	Settings AutoDownloadSettingsClazz `json:"settings"`
}

func (m *TLAccountSaveAutoDownloadSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveAutoDownloadSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x76f36233: func() error {
			x.PutClazzID(0x76f36233)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Low == true {
					flags |= 1 << 0
				}
				if m.High == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveAutoDownloadSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveAutoDownloadSettings, layer)
	}
}

// Decode <--
func (m *TLAccountSaveAutoDownloadSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x76f36233: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Low = true
			}
			if (flags & (1 << 1)) != 0 {
				m.High = true
			}

			// m4 := &AutoDownloadSettings{}
			// _ = m4.Decode(d)
			// m.Settings = m4
			m.Settings, _ = DecodeAutoDownloadSettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUploadTheme <--
type TLAccountUploadTheme struct {
	ClazzID  uint32         `json:"_id"`
	File     InputFileClazz `json:"file"`
	Thumb    InputFileClazz `json:"thumb"`
	FileName string         `json:"file_name"`
	MimeType string         `json:"mime_type"`
}

func (m *TLAccountUploadTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUploadTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1c3db333: func() error {
			x.PutClazzID(0x1c3db333)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Thumb != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.File.Encode(x, layer)
			if m.Thumb != nil {
				_ = m.Thumb.Encode(x, layer)
			}

			x.PutString(m.FileName)
			x.PutString(m.MimeType)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_uploadTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_uploadTheme, layer)
	}
}

// Decode <--
func (m *TLAccountUploadTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1c3db333: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputFile{}
			// _ = m2.Decode(d)
			// m.File = m2
			m.File, _ = DecodeInputFileClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m3 := &InputFile{}
				// _ = m3.Decode(d)
				// m.Thumb = m3
				m.Thumb, _ = DecodeInputFileClazz(d)
			}
			m.FileName, err = d.String()
			m.MimeType, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountCreateTheme <--
type TLAccountCreateTheme struct {
	ClazzID  uint32                    `json:"_id"`
	Slug     string                    `json:"slug"`
	Title    string                    `json:"title"`
	Document InputDocumentClazz        `json:"document"`
	Settings []InputThemeSettingsClazz `json:"settings"`
}

func (m *TLAccountCreateTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountCreateTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x652e4400: func() error {
			x.PutClazzID(0x652e4400)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Document != nil {
					flags |= 1 << 2
				}
				if m.Settings != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Slug)
			x.PutString(m.Title)
			if m.Document != nil {
				_ = m.Document.Encode(x, layer)
			}

			if m.Settings != nil {
				_ = iface.EncodeObjectList(x, m.Settings, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_createTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_createTheme, layer)
	}
}

// Decode <--
func (m *TLAccountCreateTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x652e4400: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Slug, err = d.String()
			m.Title, err = d.String()
			if (flags & (1 << 2)) != 0 {
				// m4 := &InputDocument{}
				// _ = m4.Decode(d)
				// m.Document = m4
				m.Document, _ = DecodeInputDocumentClazz(d)
			}
			if (flags & (1 << 3)) != 0 {
				c5, err2 := d.ClazzID()
				if c5 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
					return err2
				}
				l5, err3 := d.Int()
				// v5 := make([]*InputThemeSettings, l5)
				v5 := make([]InputThemeSettingsClazz, l5)
				for i := 0; i < l5; i++ {
					// vv := new(InputThemeSettings)
					// err3 = vv.Decode(d)
					// _ = err3
					// v5[i] = vv
					v5[i], _ = DecodeInputThemeSettingsClazz(d)
					_ = err3
				}
				m.Settings = v5
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateTheme <--
type TLAccountUpdateTheme struct {
	ClazzID  uint32                    `json:"_id"`
	Format   string                    `json:"format"`
	Theme    InputThemeClazz           `json:"theme"`
	Slug     *string                   `json:"slug"`
	Title    *string                   `json:"title"`
	Document InputDocumentClazz        `json:"document"`
	Settings []InputThemeSettingsClazz `json:"settings"`
}

func (m *TLAccountUpdateTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2bf40ccc: func() error {
			x.PutClazzID(0x2bf40ccc)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Slug != nil {
					flags |= 1 << 0
				}
				if m.Title != nil {
					flags |= 1 << 1
				}
				if m.Document != nil {
					flags |= 1 << 2
				}
				if m.Settings != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Format)
			_ = m.Theme.Encode(x, layer)
			if m.Slug != nil {
				x.PutString(*m.Slug)
			}

			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.Document != nil {
				_ = m.Document.Encode(x, layer)
			}

			if m.Settings != nil {
				_ = iface.EncodeObjectList(x, m.Settings, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateTheme, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2bf40ccc: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Format, err = d.String()

			// m3 := &InputTheme{}
			// _ = m3.Decode(d)
			// m.Theme = m3
			m.Theme, _ = DecodeInputThemeClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.Slug = new(string)
				*m.Slug, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				// m6 := &InputDocument{}
				// _ = m6.Decode(d)
				// m.Document = m6
				m.Document, _ = DecodeInputDocumentClazz(d)
			}
			if (flags & (1 << 3)) != 0 {
				c7, err2 := d.ClazzID()
				if c7 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 7, c7)
					return err2
				}
				l7, err3 := d.Int()
				// v7 := make([]*InputThemeSettings, l7)
				v7 := make([]InputThemeSettingsClazz, l7)
				for i := 0; i < l7; i++ {
					// vv := new(InputThemeSettings)
					// err3 = vv.Decode(d)
					// _ = err3
					// v7[i] = vv
					v7[i], _ = DecodeInputThemeSettingsClazz(d)
					_ = err3
				}
				m.Settings = v7
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveTheme <--
type TLAccountSaveTheme struct {
	ClazzID uint32          `json:"_id"`
	Theme   InputThemeClazz `json:"theme"`
	Unsave  BoolClazz       `json:"unsave"`
}

func (m *TLAccountSaveTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf257106c: func() error {
			x.PutClazzID(0xf257106c)

			_ = m.Theme.Encode(x, layer)
			_ = m.Unsave.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveTheme, layer)
	}
}

// Decode <--
func (m *TLAccountSaveTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf257106c: func() (err error) {

			// m1 := &InputTheme{}
			// _ = m1.Decode(d)
			// m.Theme = m1
			m.Theme, _ = DecodeInputThemeClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Unsave = m2
			m.Unsave, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountInstallTheme <--
type TLAccountInstallTheme struct {
	ClazzID   uint32          `json:"_id"`
	Dark      bool            `json:"dark"`
	Theme     InputThemeClazz `json:"theme"`
	Format    *string         `json:"format"`
	BaseTheme BaseThemeClazz  `json:"base_theme"`
}

func (m *TLAccountInstallTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountInstallTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc727bb3b: func() error {
			x.PutClazzID(0xc727bb3b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}
				if m.Theme != nil {
					flags |= 1 << 1
				}
				if m.Format != nil {
					flags |= 1 << 2
				}
				if m.BaseTheme != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Theme != nil {
				_ = m.Theme.Encode(x, layer)
			}

			if m.Format != nil {
				x.PutString(*m.Format)
			}

			if m.BaseTheme != nil {
				_ = m.BaseTheme.Encode(x, layer)
			}

			return nil
		},
		0x7ae43737: func() error {
			x.PutClazzID(0x7ae43737)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}
				if m.Format != nil {
					flags |= 1 << 1
				}
				if m.Theme != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Format != nil {
				x.PutString(*m.Format)
			}

			if m.Theme != nil {
				_ = m.Theme.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_installTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_installTheme, layer)
	}
}

// Decode <--
func (m *TLAccountInstallTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc727bb3b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}
			if (flags & (1 << 1)) != 0 {
				// m3 := &InputTheme{}
				// _ = m3.Decode(d)
				// m.Theme = m3
				m.Theme, _ = DecodeInputThemeClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				m.Format = new(string)
				*m.Format, err = d.String()
			}

			if (flags & (1 << 3)) != 0 {
				// m5 := &BaseTheme{}
				// _ = m5.Decode(d)
				// m.BaseTheme = m5
				m.BaseTheme, _ = DecodeBaseThemeClazz(d)
			}

			return nil
		},
		0x7ae43737: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Format = new(string)
				*m.Format, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				// m4 := &InputTheme{}
				// _ = m4.Decode(d)
				// m.Theme = m4
				m.Theme, _ = DecodeInputThemeClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetTheme <--
type TLAccountGetTheme struct {
	ClazzID uint32          `json:"_id"`
	Format  string          `json:"format"`
	Theme   InputThemeClazz `json:"theme"`
}

func (m *TLAccountGetTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3a5869ec: func() error {
			x.PutClazzID(0x3a5869ec)

			x.PutString(m.Format)
			_ = m.Theme.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getTheme, layer)
	}
}

// Decode <--
func (m *TLAccountGetTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3a5869ec: func() (err error) {
			m.Format, err = d.String()

			// m2 := &InputTheme{}
			// _ = m2.Decode(d)
			// m.Theme = m2
			m.Theme, _ = DecodeInputThemeClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetThemes <--
type TLAccountGetThemes struct {
	ClazzID uint32 `json:"_id"`
	Format  string `json:"format"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetThemes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetThemes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7206e458: func() error {
			x.PutClazzID(0x7206e458)

			x.PutString(m.Format)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getThemes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getThemes, layer)
	}
}

// Decode <--
func (m *TLAccountGetThemes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7206e458: func() (err error) {
			m.Format, err = d.String()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetContentSettings <--
type TLAccountSetContentSettings struct {
	ClazzID          uint32 `json:"_id"`
	SensitiveEnabled bool   `json:"sensitive_enabled"`
}

func (m *TLAccountSetContentSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetContentSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb574b16b: func() error {
			x.PutClazzID(0xb574b16b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SensitiveEnabled == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setContentSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setContentSettings, layer)
	}
}

// Decode <--
func (m *TLAccountSetContentSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb574b16b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.SensitiveEnabled = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetContentSettings <--
type TLAccountGetContentSettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetContentSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetContentSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8b9b4dae: func() error {
			x.PutClazzID(0x8b9b4dae)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getContentSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getContentSettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetContentSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8b9b4dae: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetMultiWallPapers <--
type TLAccountGetMultiWallPapers struct {
	ClazzID    uint32                `json:"_id"`
	Wallpapers []InputWallPaperClazz `json:"wallpapers"`
}

func (m *TLAccountGetMultiWallPapers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetMultiWallPapers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x65ad71dc: func() error {
			x.PutClazzID(0x65ad71dc)

			_ = iface.EncodeObjectList(x, m.Wallpapers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getMultiWallPapers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getMultiWallPapers, layer)
	}
}

// Decode <--
func (m *TLAccountGetMultiWallPapers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x65ad71dc: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputWallPaper, l1)
			v1 := make([]InputWallPaperClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputWallPaper)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputWallPaperClazz(d)
				_ = err3
			}
			m.Wallpapers = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetGlobalPrivacySettings <--
type TLAccountGetGlobalPrivacySettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetGlobalPrivacySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetGlobalPrivacySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xeb2b4cf6: func() error {
			x.PutClazzID(0xeb2b4cf6)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getGlobalPrivacySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getGlobalPrivacySettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetGlobalPrivacySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xeb2b4cf6: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetGlobalPrivacySettings <--
type TLAccountSetGlobalPrivacySettings struct {
	ClazzID  uint32                     `json:"_id"`
	Settings GlobalPrivacySettingsClazz `json:"settings"`
}

func (m *TLAccountSetGlobalPrivacySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetGlobalPrivacySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1edaaac2: func() error {
			x.PutClazzID(0x1edaaac2)

			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setGlobalPrivacySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setGlobalPrivacySettings, layer)
	}
}

// Decode <--
func (m *TLAccountSetGlobalPrivacySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1edaaac2: func() (err error) {

			// m1 := &GlobalPrivacySettings{}
			// _ = m1.Decode(d)
			// m.Settings = m1
			m.Settings, _ = DecodeGlobalPrivacySettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountReportProfilePhoto <--
type TLAccountReportProfilePhoto struct {
	ClazzID uint32            `json:"_id"`
	Peer    InputPeerClazz    `json:"peer"`
	PhotoId InputPhotoClazz   `json:"photo_id"`
	Reason  ReportReasonClazz `json:"reason"`
	Message string            `json:"message"`
}

func (m *TLAccountReportProfilePhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountReportProfilePhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfa8cc6f5: func() error {
			x.PutClazzID(0xfa8cc6f5)

			_ = m.Peer.Encode(x, layer)
			_ = m.PhotoId.Encode(x, layer)
			_ = m.Reason.Encode(x, layer)
			x.PutString(m.Message)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_reportProfilePhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_reportProfilePhoto, layer)
	}
}

// Decode <--
func (m *TLAccountReportProfilePhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfa8cc6f5: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputPhoto{}
			// _ = m2.Decode(d)
			// m.PhotoId = m2
			m.PhotoId, _ = DecodeInputPhotoClazz(d)

			// m3 := &ReportReason{}
			// _ = m3.Decode(d)
			// m.Reason = m3
			m.Reason, _ = DecodeReportReasonClazz(d)

			m.Message, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetPassword <--
type TLAccountResetPassword struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountResetPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9308ce1b: func() error {
			x.PutClazzID(0x9308ce1b)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetPassword, layer)
	}
}

// Decode <--
func (m *TLAccountResetPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9308ce1b: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDeclinePasswordReset <--
type TLAccountDeclinePasswordReset struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountDeclinePasswordReset) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDeclinePasswordReset) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4c9409f6: func() error {
			x.PutClazzID(0x4c9409f6)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_declinePasswordReset, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_declinePasswordReset, layer)
	}
}

// Decode <--
func (m *TLAccountDeclinePasswordReset) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4c9409f6: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetChatThemes <--
type TLAccountGetChatThemes struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetChatThemes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetChatThemes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd638de89: func() error {
			x.PutClazzID(0xd638de89)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getChatThemes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getChatThemes, layer)
	}
}

// Decode <--
func (m *TLAccountGetChatThemes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd638de89: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetAuthorizationTTL <--
type TLAccountSetAuthorizationTTL struct {
	ClazzID              uint32 `json:"_id"`
	AuthorizationTtlDays int32  `json:"authorization_ttl_days"`
}

func (m *TLAccountSetAuthorizationTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetAuthorizationTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbf899aa0: func() error {
			x.PutClazzID(0xbf899aa0)

			x.PutInt32(m.AuthorizationTtlDays)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setAuthorizationTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setAuthorizationTTL, layer)
	}
}

// Decode <--
func (m *TLAccountSetAuthorizationTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbf899aa0: func() (err error) {
			m.AuthorizationTtlDays, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountChangeAuthorizationSettings <--
type TLAccountChangeAuthorizationSettings struct {
	ClazzID                   uint32    `json:"_id"`
	Confirmed                 bool      `json:"confirmed"`
	Hash                      int64     `json:"hash"`
	EncryptedRequestsDisabled BoolClazz `json:"encrypted_requests_disabled"`
	CallRequestsDisabled      BoolClazz `json:"call_requests_disabled"`
}

func (m *TLAccountChangeAuthorizationSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountChangeAuthorizationSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x40f48462: func() error {
			x.PutClazzID(0x40f48462)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Confirmed == true {
					flags |= 1 << 3
				}

				if m.EncryptedRequestsDisabled != nil {
					flags |= 1 << 0
				}
				if m.CallRequestsDisabled != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.Hash)
			if m.EncryptedRequestsDisabled != nil {
				_ = m.EncryptedRequestsDisabled.Encode(x, layer)
			}

			if m.CallRequestsDisabled != nil {
				_ = m.CallRequestsDisabled.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_changeAuthorizationSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_changeAuthorizationSettings, layer)
	}
}

// Decode <--
func (m *TLAccountChangeAuthorizationSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x40f48462: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 3)) != 0 {
				m.Confirmed = true
			}
			m.Hash, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				// m4 := &Bool{}
				// _ = m4.Decode(d)
				// m.EncryptedRequestsDisabled = m4
				m.EncryptedRequestsDisabled, _ = DecodeBoolClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				// m5 := &Bool{}
				// _ = m5.Decode(d)
				// m.CallRequestsDisabled = m5
				m.CallRequestsDisabled, _ = DecodeBoolClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetSavedRingtones <--
type TLAccountGetSavedRingtones struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetSavedRingtones) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetSavedRingtones) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe1902288: func() error {
			x.PutClazzID(0xe1902288)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getSavedRingtones, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getSavedRingtones, layer)
	}
}

// Decode <--
func (m *TLAccountGetSavedRingtones) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe1902288: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveRingtone <--
type TLAccountSaveRingtone struct {
	ClazzID uint32             `json:"_id"`
	Id      InputDocumentClazz `json:"id"`
	Unsave  BoolClazz          `json:"unsave"`
}

func (m *TLAccountSaveRingtone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveRingtone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3dea5b03: func() error {
			x.PutClazzID(0x3dea5b03)

			_ = m.Id.Encode(x, layer)
			_ = m.Unsave.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveRingtone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveRingtone, layer)
	}
}

// Decode <--
func (m *TLAccountSaveRingtone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3dea5b03: func() (err error) {

			// m1 := &InputDocument{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputDocumentClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Unsave = m2
			m.Unsave, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUploadRingtone <--
type TLAccountUploadRingtone struct {
	ClazzID  uint32         `json:"_id"`
	File     InputFileClazz `json:"file"`
	FileName string         `json:"file_name"`
	MimeType string         `json:"mime_type"`
}

func (m *TLAccountUploadRingtone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUploadRingtone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x831a83a2: func() error {
			x.PutClazzID(0x831a83a2)

			_ = m.File.Encode(x, layer)
			x.PutString(m.FileName)
			x.PutString(m.MimeType)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_uploadRingtone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_uploadRingtone, layer)
	}
}

// Decode <--
func (m *TLAccountUploadRingtone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x831a83a2: func() (err error) {

			// m1 := &InputFile{}
			// _ = m1.Decode(d)
			// m.File = m1
			m.File, _ = DecodeInputFileClazz(d)

			m.FileName, err = d.String()
			m.MimeType, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateEmojiStatus <--
type TLAccountUpdateEmojiStatus struct {
	ClazzID     uint32           `json:"_id"`
	EmojiStatus EmojiStatusClazz `json:"emoji_status"`
}

func (m *TLAccountUpdateEmojiStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateEmojiStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfbd3de6b: func() error {
			x.PutClazzID(0xfbd3de6b)

			_ = m.EmojiStatus.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateEmojiStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateEmojiStatus, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateEmojiStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfbd3de6b: func() (err error) {

			// m1 := &EmojiStatus{}
			// _ = m1.Decode(d)
			// m.EmojiStatus = m1
			m.EmojiStatus, _ = DecodeEmojiStatusClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetDefaultEmojiStatuses <--
type TLAccountGetDefaultEmojiStatuses struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetDefaultEmojiStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetDefaultEmojiStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd6753386: func() error {
			x.PutClazzID(0xd6753386)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getDefaultEmojiStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getDefaultEmojiStatuses, layer)
	}
}

// Decode <--
func (m *TLAccountGetDefaultEmojiStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd6753386: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetRecentEmojiStatuses <--
type TLAccountGetRecentEmojiStatuses struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetRecentEmojiStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetRecentEmojiStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf578105: func() error {
			x.PutClazzID(0xf578105)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getRecentEmojiStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getRecentEmojiStatuses, layer)
	}
}

// Decode <--
func (m *TLAccountGetRecentEmojiStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf578105: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountClearRecentEmojiStatuses <--
type TLAccountClearRecentEmojiStatuses struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountClearRecentEmojiStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountClearRecentEmojiStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x18201aae: func() error {
			x.PutClazzID(0x18201aae)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_clearRecentEmojiStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_clearRecentEmojiStatuses, layer)
	}
}

// Decode <--
func (m *TLAccountClearRecentEmojiStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x18201aae: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountReorderUsernames <--
type TLAccountReorderUsernames struct {
	ClazzID uint32   `json:"_id"`
	Order   []string `json:"order"`
}

func (m *TLAccountReorderUsernames) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountReorderUsernames) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xef500eab: func() error {
			x.PutClazzID(0xef500eab)

			iface.EncodeStringList(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_reorderUsernames, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_reorderUsernames, layer)
	}
}

// Decode <--
func (m *TLAccountReorderUsernames) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xef500eab: func() (err error) {

			m.Order, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountToggleUsername <--
type TLAccountToggleUsername struct {
	ClazzID  uint32    `json:"_id"`
	Username string    `json:"username"`
	Active   BoolClazz `json:"active"`
}

func (m *TLAccountToggleUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountToggleUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x58d6b376: func() error {
			x.PutClazzID(0x58d6b376)

			x.PutString(m.Username)
			_ = m.Active.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_toggleUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_toggleUsername, layer)
	}
}

// Decode <--
func (m *TLAccountToggleUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x58d6b376: func() (err error) {
			m.Username, err = d.String()

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Active = m2
			m.Active, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetDefaultProfilePhotoEmojis <--
type TLAccountGetDefaultProfilePhotoEmojis struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetDefaultProfilePhotoEmojis) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetDefaultProfilePhotoEmojis) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe2750328: func() error {
			x.PutClazzID(0xe2750328)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getDefaultProfilePhotoEmojis, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getDefaultProfilePhotoEmojis, layer)
	}
}

// Decode <--
func (m *TLAccountGetDefaultProfilePhotoEmojis) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe2750328: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetDefaultGroupPhotoEmojis <--
type TLAccountGetDefaultGroupPhotoEmojis struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetDefaultGroupPhotoEmojis) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetDefaultGroupPhotoEmojis) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x915860ae: func() error {
			x.PutClazzID(0x915860ae)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getDefaultGroupPhotoEmojis, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getDefaultGroupPhotoEmojis, layer)
	}
}

// Decode <--
func (m *TLAccountGetDefaultGroupPhotoEmojis) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x915860ae: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAutoSaveSettings <--
type TLAccountGetAutoSaveSettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetAutoSaveSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAutoSaveSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xadcbbcda: func() error {
			x.PutClazzID(0xadcbbcda)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAutoSaveSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAutoSaveSettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetAutoSaveSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xadcbbcda: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveAutoSaveSettings <--
type TLAccountSaveAutoSaveSettings struct {
	ClazzID    uint32                `json:"_id"`
	Users      bool                  `json:"users"`
	Chats      bool                  `json:"chats"`
	Broadcasts bool                  `json:"broadcasts"`
	Peer       InputPeerClazz        `json:"peer"`
	Settings   AutoSaveSettingsClazz `json:"settings"`
}

func (m *TLAccountSaveAutoSaveSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveAutoSaveSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd69b8361: func() error {
			x.PutClazzID(0xd69b8361)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Users == true {
					flags |= 1 << 0
				}
				if m.Chats == true {
					flags |= 1 << 1
				}
				if m.Broadcasts == true {
					flags |= 1 << 2
				}
				if m.Peer != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveAutoSaveSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveAutoSaveSettings, layer)
	}
}

// Decode <--
func (m *TLAccountSaveAutoSaveSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd69b8361: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Users = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Chats = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Broadcasts = true
			}
			if (flags & (1 << 3)) != 0 {
				// m5 := &InputPeer{}
				// _ = m5.Decode(d)
				// m.Peer = m5
				m.Peer, _ = DecodeInputPeerClazz(d)
			}

			// m6 := &AutoSaveSettings{}
			// _ = m6.Decode(d)
			// m.Settings = m6
			m.Settings, _ = DecodeAutoSaveSettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDeleteAutoSaveExceptions <--
type TLAccountDeleteAutoSaveExceptions struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountDeleteAutoSaveExceptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDeleteAutoSaveExceptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x53bc0020: func() error {
			x.PutClazzID(0x53bc0020)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_deleteAutoSaveExceptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_deleteAutoSaveExceptions, layer)
	}
}

// Decode <--
func (m *TLAccountDeleteAutoSaveExceptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x53bc0020: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountInvalidateSignInCodes <--
type TLAccountInvalidateSignInCodes struct {
	ClazzID uint32   `json:"_id"`
	Codes   []string `json:"codes"`
}

func (m *TLAccountInvalidateSignInCodes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountInvalidateSignInCodes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xca8ae8ba: func() error {
			x.PutClazzID(0xca8ae8ba)

			iface.EncodeStringList(x, m.Codes)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_invalidateSignInCodes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_invalidateSignInCodes, layer)
	}
}

// Decode <--
func (m *TLAccountInvalidateSignInCodes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xca8ae8ba: func() (err error) {

			m.Codes, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateColor <--
type TLAccountUpdateColor struct {
	ClazzID    uint32         `json:"_id"`
	ForProfile bool           `json:"for_profile"`
	Color      PeerColorClazz `json:"color"`
}

func (m *TLAccountUpdateColor) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateColor) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x684d214e: func() error {
			x.PutClazzID(0x684d214e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForProfile == true {
					flags |= 1 << 1
				}
				if m.Color != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Color != nil {
				_ = m.Color.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateColor, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateColor, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateColor) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x684d214e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.ForProfile = true
			}
			if (flags & (1 << 2)) != 0 {
				// m3 := &PeerColor{}
				// _ = m3.Decode(d)
				// m.Color = m3
				m.Color, _ = DecodePeerColorClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetDefaultBackgroundEmojis <--
type TLAccountGetDefaultBackgroundEmojis struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetDefaultBackgroundEmojis) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetDefaultBackgroundEmojis) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa60ab9ce: func() error {
			x.PutClazzID(0xa60ab9ce)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getDefaultBackgroundEmojis, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getDefaultBackgroundEmojis, layer)
	}
}

// Decode <--
func (m *TLAccountGetDefaultBackgroundEmojis) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa60ab9ce: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetChannelDefaultEmojiStatuses <--
type TLAccountGetChannelDefaultEmojiStatuses struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetChannelDefaultEmojiStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetChannelDefaultEmojiStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7727a7d5: func() error {
			x.PutClazzID(0x7727a7d5)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getChannelDefaultEmojiStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getChannelDefaultEmojiStatuses, layer)
	}
}

// Decode <--
func (m *TLAccountGetChannelDefaultEmojiStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7727a7d5: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetChannelRestrictedStatusEmojis <--
type TLAccountGetChannelRestrictedStatusEmojis struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetChannelRestrictedStatusEmojis) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetChannelRestrictedStatusEmojis) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x35a9e0d5: func() error {
			x.PutClazzID(0x35a9e0d5)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getChannelRestrictedStatusEmojis, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getChannelRestrictedStatusEmojis, layer)
	}
}

// Decode <--
func (m *TLAccountGetChannelRestrictedStatusEmojis) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x35a9e0d5: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBusinessWorkHours <--
type TLAccountUpdateBusinessWorkHours struct {
	ClazzID           uint32                 `json:"_id"`
	BusinessWorkHours BusinessWorkHoursClazz `json:"business_work_hours"`
}

func (m *TLAccountUpdateBusinessWorkHours) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBusinessWorkHours) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4b00e066: func() error {
			x.PutClazzID(0x4b00e066)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.BusinessWorkHours != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.BusinessWorkHours != nil {
				_ = m.BusinessWorkHours.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBusinessWorkHours, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBusinessWorkHours, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBusinessWorkHours) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4b00e066: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &BusinessWorkHours{}
				// _ = m2.Decode(d)
				// m.BusinessWorkHours = m2
				m.BusinessWorkHours, _ = DecodeBusinessWorkHoursClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBusinessLocation <--
type TLAccountUpdateBusinessLocation struct {
	ClazzID  uint32             `json:"_id"`
	GeoPoint InputGeoPointClazz `json:"geo_point"`
	Address  *string            `json:"address"`
}

func (m *TLAccountUpdateBusinessLocation) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBusinessLocation) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9e6b131a: func() error {
			x.PutClazzID(0x9e6b131a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.GeoPoint != nil {
					flags |= 1 << 1
				}
				if m.Address != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.GeoPoint != nil {
				_ = m.GeoPoint.Encode(x, layer)
			}

			if m.Address != nil {
				x.PutString(*m.Address)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBusinessLocation, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBusinessLocation, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBusinessLocation) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9e6b131a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				// m2 := &InputGeoPoint{}
				// _ = m2.Decode(d)
				// m.GeoPoint = m2
				m.GeoPoint, _ = DecodeInputGeoPointClazz(d)
			}
			if (flags & (1 << 0)) != 0 {
				m.Address = new(string)
				*m.Address, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBusinessGreetingMessage <--
type TLAccountUpdateBusinessGreetingMessage struct {
	ClazzID uint32                            `json:"_id"`
	Message InputBusinessGreetingMessageClazz `json:"message"`
}

func (m *TLAccountUpdateBusinessGreetingMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBusinessGreetingMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x66cdafc4: func() error {
			x.PutClazzID(0x66cdafc4)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Message != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Message != nil {
				_ = m.Message.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBusinessGreetingMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBusinessGreetingMessage, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBusinessGreetingMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x66cdafc4: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputBusinessGreetingMessage{}
				// _ = m2.Decode(d)
				// m.Message = m2
				m.Message, _ = DecodeInputBusinessGreetingMessageClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBusinessAwayMessage <--
type TLAccountUpdateBusinessAwayMessage struct {
	ClazzID uint32                        `json:"_id"`
	Message InputBusinessAwayMessageClazz `json:"message"`
}

func (m *TLAccountUpdateBusinessAwayMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBusinessAwayMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa26a7fa5: func() error {
			x.PutClazzID(0xa26a7fa5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Message != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Message != nil {
				_ = m.Message.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBusinessAwayMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBusinessAwayMessage, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBusinessAwayMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa26a7fa5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputBusinessAwayMessage{}
				// _ = m2.Decode(d)
				// m.Message = m2
				m.Message, _ = DecodeInputBusinessAwayMessageClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateConnectedBot <--
type TLAccountUpdateConnectedBot struct {
	ClazzID    uint32                          `json:"_id"`
	Deleted    bool                            `json:"deleted"`
	Rights     BusinessBotRightsClazz          `json:"rights"`
	Bot        InputUserClazz                  `json:"bot"`
	Recipients InputBusinessBotRecipientsClazz `json:"recipients"`
}

func (m *TLAccountUpdateConnectedBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateConnectedBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x66a08c7e: func() error {
			x.PutClazzID(0x66a08c7e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Deleted == true {
					flags |= 1 << 1
				}
				if m.Rights != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Rights != nil {
				_ = m.Rights.Encode(x, layer)
			}

			_ = m.Bot.Encode(x, layer)
			_ = m.Recipients.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateConnectedBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateConnectedBot, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateConnectedBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x66a08c7e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Deleted = true
			}
			if (flags & (1 << 0)) != 0 {
				// m3 := &BusinessBotRights{}
				// _ = m3.Decode(d)
				// m.Rights = m3
				m.Rights, _ = DecodeBusinessBotRightsClazz(d)
			}

			// m4 := &InputUser{}
			// _ = m4.Decode(d)
			// m.Bot = m4
			m.Bot, _ = DecodeInputUserClazz(d)

			// m5 := &InputBusinessBotRecipients{}
			// _ = m5.Decode(d)
			// m.Recipients = m5
			m.Recipients, _ = DecodeInputBusinessBotRecipientsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetConnectedBots <--
type TLAccountGetConnectedBots struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetConnectedBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetConnectedBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4ea4c80f: func() error {
			x.PutClazzID(0x4ea4c80f)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getConnectedBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getConnectedBots, layer)
	}
}

// Decode <--
func (m *TLAccountGetConnectedBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4ea4c80f: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetBotBusinessConnection <--
type TLAccountGetBotBusinessConnection struct {
	ClazzID      uint32 `json:"_id"`
	ConnectionId string `json:"connection_id"`
}

func (m *TLAccountGetBotBusinessConnection) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetBotBusinessConnection) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x76a86270: func() error {
			x.PutClazzID(0x76a86270)

			x.PutString(m.ConnectionId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getBotBusinessConnection, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getBotBusinessConnection, layer)
	}
}

// Decode <--
func (m *TLAccountGetBotBusinessConnection) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x76a86270: func() (err error) {
			m.ConnectionId, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBusinessIntro <--
type TLAccountUpdateBusinessIntro struct {
	ClazzID uint32                  `json:"_id"`
	Intro   InputBusinessIntroClazz `json:"intro"`
}

func (m *TLAccountUpdateBusinessIntro) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBusinessIntro) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa614d034: func() error {
			x.PutClazzID(0xa614d034)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Intro != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Intro != nil {
				_ = m.Intro.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBusinessIntro, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBusinessIntro, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBusinessIntro) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa614d034: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputBusinessIntro{}
				// _ = m2.Decode(d)
				// m.Intro = m2
				m.Intro, _ = DecodeInputBusinessIntroClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountToggleConnectedBotPaused <--
type TLAccountToggleConnectedBotPaused struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Paused  BoolClazz      `json:"paused"`
}

func (m *TLAccountToggleConnectedBotPaused) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountToggleConnectedBotPaused) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x646e1097: func() error {
			x.PutClazzID(0x646e1097)

			_ = m.Peer.Encode(x, layer)
			_ = m.Paused.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_toggleConnectedBotPaused, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_toggleConnectedBotPaused, layer)
	}
}

// Decode <--
func (m *TLAccountToggleConnectedBotPaused) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x646e1097: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Paused = m2
			m.Paused, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDisablePeerConnectedBot <--
type TLAccountDisablePeerConnectedBot struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLAccountDisablePeerConnectedBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDisablePeerConnectedBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5e437ed9: func() error {
			x.PutClazzID(0x5e437ed9)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_disablePeerConnectedBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_disablePeerConnectedBot, layer)
	}
}

// Decode <--
func (m *TLAccountDisablePeerConnectedBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5e437ed9: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBirthday <--
type TLAccountUpdateBirthday struct {
	ClazzID  uint32        `json:"_id"`
	Birthday BirthdayClazz `json:"birthday"`
}

func (m *TLAccountUpdateBirthday) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBirthday) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcc6e0c11: func() error {
			x.PutClazzID(0xcc6e0c11)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Birthday != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Birthday != nil {
				_ = m.Birthday.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBirthday, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBirthday, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBirthday) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcc6e0c11: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &Birthday{}
				// _ = m2.Decode(d)
				// m.Birthday = m2
				m.Birthday, _ = DecodeBirthdayClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountCreateBusinessChatLink <--
type TLAccountCreateBusinessChatLink struct {
	ClazzID uint32                     `json:"_id"`
	Link    InputBusinessChatLinkClazz `json:"link"`
}

func (m *TLAccountCreateBusinessChatLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountCreateBusinessChatLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8851e68e: func() error {
			x.PutClazzID(0x8851e68e)

			_ = m.Link.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_createBusinessChatLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_createBusinessChatLink, layer)
	}
}

// Decode <--
func (m *TLAccountCreateBusinessChatLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8851e68e: func() (err error) {

			// m1 := &InputBusinessChatLink{}
			// _ = m1.Decode(d)
			// m.Link = m1
			m.Link, _ = DecodeInputBusinessChatLinkClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountEditBusinessChatLink <--
type TLAccountEditBusinessChatLink struct {
	ClazzID uint32                     `json:"_id"`
	Slug    string                     `json:"slug"`
	Link    InputBusinessChatLinkClazz `json:"link"`
}

func (m *TLAccountEditBusinessChatLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountEditBusinessChatLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8c3410af: func() error {
			x.PutClazzID(0x8c3410af)

			x.PutString(m.Slug)
			_ = m.Link.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_editBusinessChatLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_editBusinessChatLink, layer)
	}
}

// Decode <--
func (m *TLAccountEditBusinessChatLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8c3410af: func() (err error) {
			m.Slug, err = d.String()

			// m2 := &InputBusinessChatLink{}
			// _ = m2.Decode(d)
			// m.Link = m2
			m.Link, _ = DecodeInputBusinessChatLinkClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDeleteBusinessChatLink <--
type TLAccountDeleteBusinessChatLink struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLAccountDeleteBusinessChatLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDeleteBusinessChatLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x60073674: func() error {
			x.PutClazzID(0x60073674)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_deleteBusinessChatLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_deleteBusinessChatLink, layer)
	}
}

// Decode <--
func (m *TLAccountDeleteBusinessChatLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x60073674: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetBusinessChatLinks <--
type TLAccountGetBusinessChatLinks struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetBusinessChatLinks) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetBusinessChatLinks) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6f70dde1: func() error {
			x.PutClazzID(0x6f70dde1)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getBusinessChatLinks, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getBusinessChatLinks, layer)
	}
}

// Decode <--
func (m *TLAccountGetBusinessChatLinks) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6f70dde1: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResolveBusinessChatLink <--
type TLAccountResolveBusinessChatLink struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLAccountResolveBusinessChatLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResolveBusinessChatLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5492e5ee: func() error {
			x.PutClazzID(0x5492e5ee)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resolveBusinessChatLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resolveBusinessChatLink, layer)
	}
}

// Decode <--
func (m *TLAccountResolveBusinessChatLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5492e5ee: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdatePersonalChannel <--
type TLAccountUpdatePersonalChannel struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
}

func (m *TLAccountUpdatePersonalChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdatePersonalChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd94305e0: func() error {
			x.PutClazzID(0xd94305e0)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updatePersonalChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updatePersonalChannel, layer)
	}
}

// Decode <--
func (m *TLAccountUpdatePersonalChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd94305e0: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountToggleSponsoredMessages <--
type TLAccountToggleSponsoredMessages struct {
	ClazzID uint32    `json:"_id"`
	Enabled BoolClazz `json:"enabled"`
}

func (m *TLAccountToggleSponsoredMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountToggleSponsoredMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb9d9a38d: func() error {
			x.PutClazzID(0xb9d9a38d)

			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_toggleSponsoredMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_toggleSponsoredMessages, layer)
	}
}

// Decode <--
func (m *TLAccountToggleSponsoredMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb9d9a38d: func() (err error) {

			// m1 := &Bool{}
			// _ = m1.Decode(d)
			// m.Enabled = m1
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetReactionsNotifySettings <--
type TLAccountGetReactionsNotifySettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetReactionsNotifySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetReactionsNotifySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6dd654c: func() error {
			x.PutClazzID(0x6dd654c)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getReactionsNotifySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getReactionsNotifySettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetReactionsNotifySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6dd654c: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetReactionsNotifySettings <--
type TLAccountSetReactionsNotifySettings struct {
	ClazzID  uint32                       `json:"_id"`
	Settings ReactionsNotifySettingsClazz `json:"settings"`
}

func (m *TLAccountSetReactionsNotifySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetReactionsNotifySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x316ce548: func() error {
			x.PutClazzID(0x316ce548)

			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setReactionsNotifySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setReactionsNotifySettings, layer)
	}
}

// Decode <--
func (m *TLAccountSetReactionsNotifySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x316ce548: func() (err error) {

			// m1 := &ReactionsNotifySettings{}
			// _ = m1.Decode(d)
			// m.Settings = m1
			m.Settings, _ = DecodeReactionsNotifySettingsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetCollectibleEmojiStatuses <--
type TLAccountGetCollectibleEmojiStatuses struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetCollectibleEmojiStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetCollectibleEmojiStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2e7b4543: func() error {
			x.PutClazzID(0x2e7b4543)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getCollectibleEmojiStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getCollectibleEmojiStatuses, layer)
	}
}

// Decode <--
func (m *TLAccountGetCollectibleEmojiStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2e7b4543: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetPaidMessagesRevenue <--
type TLAccountGetPaidMessagesRevenue struct {
	ClazzID    uint32         `json:"_id"`
	ParentPeer InputPeerClazz `json:"parent_peer"`
	UserId     InputUserClazz `json:"user_id"`
}

func (m *TLAccountGetPaidMessagesRevenue) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetPaidMessagesRevenue) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x19ba4a67: func() error {
			x.PutClazzID(0x19ba4a67)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ParentPeer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.ParentPeer != nil {
				_ = m.ParentPeer.Encode(x, layer)
			}

			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getPaidMessagesRevenue, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getPaidMessagesRevenue, layer)
	}
}

// Decode <--
func (m *TLAccountGetPaidMessagesRevenue) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x19ba4a67: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputPeer{}
				// _ = m2.Decode(d)
				// m.ParentPeer = m2
				m.ParentPeer, _ = DecodeInputPeerClazz(d)
			}

			// m3 := &InputUser{}
			// _ = m3.Decode(d)
			// m.UserId = m3
			m.UserId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountToggleNoPaidMessagesException <--
type TLAccountToggleNoPaidMessagesException struct {
	ClazzID        uint32         `json:"_id"`
	RefundCharged  bool           `json:"refund_charged"`
	RequirePayment bool           `json:"require_payment"`
	ParentPeer     InputPeerClazz `json:"parent_peer"`
	UserId         InputUserClazz `json:"user_id"`
}

func (m *TLAccountToggleNoPaidMessagesException) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountToggleNoPaidMessagesException) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfe2eda76: func() error {
			x.PutClazzID(0xfe2eda76)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.RefundCharged == true {
					flags |= 1 << 0
				}
				if m.RequirePayment == true {
					flags |= 1 << 2
				}
				if m.ParentPeer != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.ParentPeer != nil {
				_ = m.ParentPeer.Encode(x, layer)
			}

			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_toggleNoPaidMessagesException, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_toggleNoPaidMessagesException, layer)
	}
}

// Decode <--
func (m *TLAccountToggleNoPaidMessagesException) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfe2eda76: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.RefundCharged = true
			}
			if (flags & (1 << 2)) != 0 {
				m.RequirePayment = true
			}
			if (flags & (1 << 1)) != 0 {
				// m4 := &InputPeer{}
				// _ = m4.Decode(d)
				// m.ParentPeer = m4
				m.ParentPeer, _ = DecodeInputPeerClazz(d)
			}

			// m5 := &InputUser{}
			// _ = m5.Decode(d)
			// m.UserId = m5
			m.UserId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetMainProfileTab <--
type TLAccountSetMainProfileTab struct {
	ClazzID uint32          `json:"_id"`
	Tab     ProfileTabClazz `json:"tab"`
}

func (m *TLAccountSetMainProfileTab) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetMainProfileTab) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5dee78b0: func() error {
			x.PutClazzID(0x5dee78b0)

			_ = m.Tab.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setMainProfileTab, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setMainProfileTab, layer)
	}
}

// Decode <--
func (m *TLAccountSetMainProfileTab) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5dee78b0: func() (err error) {

			// m1 := &ProfileTab{}
			// _ = m1.Decode(d)
			// m.Tab = m1
			m.Tab, _ = DecodeProfileTabClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveMusic <--
type TLAccountSaveMusic struct {
	ClazzID uint32             `json:"_id"`
	Unsave  bool               `json:"unsave"`
	Id      InputDocumentClazz `json:"id"`
	AfterId InputDocumentClazz `json:"after_id"`
}

func (m *TLAccountSaveMusic) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveMusic) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb26732a9: func() error {
			x.PutClazzID(0xb26732a9)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Unsave == true {
					flags |= 1 << 0
				}

				if m.AfterId != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)
			if m.AfterId != nil {
				_ = m.AfterId.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveMusic, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveMusic, layer)
	}
}

// Decode <--
func (m *TLAccountSaveMusic) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb26732a9: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Unsave = true
			}

			// m3 := &InputDocument{}
			// _ = m3.Decode(d)
			// m.Id = m3
			m.Id, _ = DecodeInputDocumentClazz(d)

			if (flags & (1 << 1)) != 0 {
				// m4 := &InputDocument{}
				// _ = m4.Decode(d)
				// m.AfterId = m4
				m.AfterId, _ = DecodeInputDocumentClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetSavedMusicIds <--
type TLAccountGetSavedMusicIds struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetSavedMusicIds) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetSavedMusicIds) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe09d5faf: func() error {
			x.PutClazzID(0xe09d5faf)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getSavedMusicIds, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getSavedMusicIds, layer)
	}
}

// Decode <--
func (m *TLAccountGetSavedMusicIds) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe09d5faf: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetUniqueGiftChatThemes <--
type TLAccountGetUniqueGiftChatThemes struct {
	ClazzID uint32 `json:"_id"`
	Offset  string `json:"offset"`
	Limit   int32  `json:"limit"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetUniqueGiftChatThemes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetUniqueGiftChatThemes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe42ce9c9: func() error {
			x.PutClazzID(0xe42ce9c9)

			x.PutString(m.Offset)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getUniqueGiftChatThemes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getUniqueGiftChatThemes, layer)
	}
}

// Decode <--
func (m *TLAccountGetUniqueGiftChatThemes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe42ce9c9: func() (err error) {
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetUsers <--
type TLUsersGetUsers struct {
	ClazzID uint32           `json:"_id"`
	Id      []InputUserClazz `json:"id"`
}

func (m *TLUsersGetUsers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetUsers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd91a548: func() error {
			x.PutClazzID(0xd91a548)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getUsers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getUsers, layer)
	}
}

// Decode <--
func (m *TLUsersGetUsers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd91a548: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputUser, l1)
			v1 := make([]InputUserClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputUser)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputUserClazz(d)
				_ = err3
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetFullUser <--
type TLUsersGetFullUser struct {
	ClazzID uint32         `json:"_id"`
	Id      InputUserClazz `json:"id"`
}

func (m *TLUsersGetFullUser) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetFullUser) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb60f5918: func() error {
			x.PutClazzID(0xb60f5918)

			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getFullUser, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getFullUser, layer)
	}
}

// Decode <--
func (m *TLUsersGetFullUser) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb60f5918: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersSetSecureValueErrors <--
type TLUsersSetSecureValueErrors struct {
	ClazzID uint32                  `json:"_id"`
	Id      InputUserClazz          `json:"id"`
	Errors  []SecureValueErrorClazz `json:"errors"`
}

func (m *TLUsersSetSecureValueErrors) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersSetSecureValueErrors) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x90c894b5: func() error {
			x.PutClazzID(0x90c894b5)

			_ = m.Id.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Errors, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_setSecureValueErrors, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_setSecureValueErrors, layer)
	}
}

// Decode <--
func (m *TLUsersSetSecureValueErrors) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x90c894b5: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputUserClazz(d)

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*SecureValueError, l2)
			v2 := make([]SecureValueErrorClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(SecureValueError)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeSecureValueErrorClazz(d)
				_ = err3
			}
			m.Errors = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetRequirementsToContact <--
type TLUsersGetRequirementsToContact struct {
	ClazzID uint32           `json:"_id"`
	Id      []InputUserClazz `json:"id"`
}

func (m *TLUsersGetRequirementsToContact) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetRequirementsToContact) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd89a83a3: func() error {
			x.PutClazzID(0xd89a83a3)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getRequirementsToContact, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getRequirementsToContact, layer)
	}
}

// Decode <--
func (m *TLUsersGetRequirementsToContact) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd89a83a3: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputUser, l1)
			v1 := make([]InputUserClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputUser)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputUserClazz(d)
				_ = err3
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetSavedMusic <--
type TLUsersGetSavedMusic struct {
	ClazzID uint32         `json:"_id"`
	Id      InputUserClazz `json:"id"`
	Offset  int32          `json:"offset"`
	Limit   int32          `json:"limit"`
	Hash    int64          `json:"hash"`
}

func (m *TLUsersGetSavedMusic) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetSavedMusic) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x788d7fe3: func() error {
			x.PutClazzID(0x788d7fe3)

			_ = m.Id.Encode(x, layer)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getSavedMusic, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getSavedMusic, layer)
	}
}

// Decode <--
func (m *TLUsersGetSavedMusic) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x788d7fe3: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputUserClazz(d)

			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetSavedMusicByID <--
type TLUsersGetSavedMusicByID struct {
	ClazzID   uint32               `json:"_id"`
	Id        InputUserClazz       `json:"id"`
	Documents []InputDocumentClazz `json:"documents"`
}

func (m *TLUsersGetSavedMusicByID) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetSavedMusicByID) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7573a4e9: func() error {
			x.PutClazzID(0x7573a4e9)

			_ = m.Id.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Documents, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getSavedMusicByID, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getSavedMusicByID, layer)
	}
}

// Decode <--
func (m *TLUsersGetSavedMusicByID) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7573a4e9: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputUserClazz(d)

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputDocument, l2)
			v2 := make([]InputDocumentClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputDocument)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputDocumentClazz(d)
				_ = err3
			}
			m.Documents = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersSuggestBirthday <--
type TLUsersSuggestBirthday struct {
	ClazzID  uint32         `json:"_id"`
	Id       InputUserClazz `json:"id"`
	Birthday BirthdayClazz  `json:"birthday"`
}

func (m *TLUsersSuggestBirthday) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersSuggestBirthday) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfc533372: func() error {
			x.PutClazzID(0xfc533372)

			_ = m.Id.Encode(x, layer)
			_ = m.Birthday.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_suggestBirthday, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_suggestBirthday, layer)
	}
}

// Decode <--
func (m *TLUsersSuggestBirthday) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfc533372: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputUserClazz(d)

			// m2 := &Birthday{}
			// _ = m2.Decode(d)
			// m.Birthday = m2
			m.Birthday, _ = DecodeBirthdayClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetContactIDs <--
type TLContactsGetContactIDs struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLContactsGetContactIDs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetContactIDs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7adc669d: func() error {
			x.PutClazzID(0x7adc669d)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getContactIDs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getContactIDs, layer)
	}
}

// Decode <--
func (m *TLContactsGetContactIDs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7adc669d: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetStatuses <--
type TLContactsGetStatuses struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLContactsGetStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc4a353ee: func() error {
			x.PutClazzID(0xc4a353ee)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getStatuses, layer)
	}
}

// Decode <--
func (m *TLContactsGetStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc4a353ee: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetContacts <--
type TLContactsGetContacts struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLContactsGetContacts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetContacts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5dd69e12: func() error {
			x.PutClazzID(0x5dd69e12)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getContacts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getContacts, layer)
	}
}

// Decode <--
func (m *TLContactsGetContacts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5dd69e12: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsImportContacts <--
type TLContactsImportContacts struct {
	ClazzID  uint32              `json:"_id"`
	Contacts []InputContactClazz `json:"contacts"`
}

func (m *TLContactsImportContacts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsImportContacts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2c800be5: func() error {
			x.PutClazzID(0x2c800be5)

			_ = iface.EncodeObjectList(x, m.Contacts, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_importContacts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_importContacts, layer)
	}
}

// Decode <--
func (m *TLContactsImportContacts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2c800be5: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputContact, l1)
			v1 := make([]InputContactClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputContact)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputContactClazz(d)
				_ = err3
			}
			m.Contacts = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsDeleteContacts <--
type TLContactsDeleteContacts struct {
	ClazzID uint32           `json:"_id"`
	Id      []InputUserClazz `json:"id"`
}

func (m *TLContactsDeleteContacts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsDeleteContacts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x96a0e00: func() error {
			x.PutClazzID(0x96a0e00)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_deleteContacts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_deleteContacts, layer)
	}
}

// Decode <--
func (m *TLContactsDeleteContacts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x96a0e00: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputUser, l1)
			v1 := make([]InputUserClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputUser)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputUserClazz(d)
				_ = err3
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsDeleteByPhones <--
type TLContactsDeleteByPhones struct {
	ClazzID uint32   `json:"_id"`
	Phones  []string `json:"phones"`
}

func (m *TLContactsDeleteByPhones) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsDeleteByPhones) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1013fd9e: func() error {
			x.PutClazzID(0x1013fd9e)

			iface.EncodeStringList(x, m.Phones)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_deleteByPhones, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_deleteByPhones, layer)
	}
}

// Decode <--
func (m *TLContactsDeleteByPhones) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1013fd9e: func() (err error) {

			m.Phones, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsBlock <--
type TLContactsBlock struct {
	ClazzID       uint32         `json:"_id"`
	MyStoriesFrom bool           `json:"my_stories_from"`
	Id            InputPeerClazz `json:"id"`
}

func (m *TLContactsBlock) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsBlock) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2e2e8734: func() error {
			x.PutClazzID(0x2e2e8734)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MyStoriesFrom == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_block, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_block, layer)
	}
}

// Decode <--
func (m *TLContactsBlock) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2e2e8734: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.MyStoriesFrom = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Id = m3
			m.Id, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsUnblock <--
type TLContactsUnblock struct {
	ClazzID       uint32         `json:"_id"`
	MyStoriesFrom bool           `json:"my_stories_from"`
	Id            InputPeerClazz `json:"id"`
}

func (m *TLContactsUnblock) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsUnblock) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb550d328: func() error {
			x.PutClazzID(0xb550d328)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MyStoriesFrom == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_unblock, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_unblock, layer)
	}
}

// Decode <--
func (m *TLContactsUnblock) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb550d328: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.MyStoriesFrom = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Id = m3
			m.Id, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetBlocked <--
type TLContactsGetBlocked struct {
	ClazzID       uint32 `json:"_id"`
	MyStoriesFrom bool   `json:"my_stories_from"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (m *TLContactsGetBlocked) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetBlocked) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9a868f80: func() error {
			x.PutClazzID(0x9a868f80)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MyStoriesFrom == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getBlocked, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getBlocked, layer)
	}
}

// Decode <--
func (m *TLContactsGetBlocked) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9a868f80: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.MyStoriesFrom = true
			}
			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsSearch <--
type TLContactsSearch struct {
	ClazzID uint32 `json:"_id"`
	Q       string `json:"q"`
	Limit   int32  `json:"limit"`
}

func (m *TLContactsSearch) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsSearch) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x11f812d8: func() error {
			x.PutClazzID(0x11f812d8)

			x.PutString(m.Q)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_search, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_search, layer)
	}
}

// Decode <--
func (m *TLContactsSearch) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x11f812d8: func() (err error) {
			m.Q, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsResolveUsername <--
type TLContactsResolveUsername struct {
	ClazzID  uint32  `json:"_id"`
	Username string  `json:"username"`
	Referer  *string `json:"referer"`
}

func (m *TLContactsResolveUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsResolveUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x725afbbc: func() error {
			x.PutClazzID(0x725afbbc)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Referer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Username)
			if m.Referer != nil {
				x.PutString(*m.Referer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_resolveUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_resolveUsername, layer)
	}
}

// Decode <--
func (m *TLContactsResolveUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x725afbbc: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Username, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.Referer = new(string)
				*m.Referer, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetTopPeers <--
type TLContactsGetTopPeers struct {
	ClazzID        uint32 `json:"_id"`
	Correspondents bool   `json:"correspondents"`
	BotsPm         bool   `json:"bots_pm"`
	BotsInline     bool   `json:"bots_inline"`
	PhoneCalls     bool   `json:"phone_calls"`
	ForwardUsers   bool   `json:"forward_users"`
	ForwardChats   bool   `json:"forward_chats"`
	Groups         bool   `json:"groups"`
	Channels       bool   `json:"channels"`
	BotsApp        bool   `json:"bots_app"`
	Offset         int32  `json:"offset"`
	Limit          int32  `json:"limit"`
	Hash           int64  `json:"hash"`
}

func (m *TLContactsGetTopPeers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetTopPeers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x973478b6: func() error {
			x.PutClazzID(0x973478b6)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Correspondents == true {
					flags |= 1 << 0
				}
				if m.BotsPm == true {
					flags |= 1 << 1
				}
				if m.BotsInline == true {
					flags |= 1 << 2
				}
				if m.PhoneCalls == true {
					flags |= 1 << 3
				}
				if m.ForwardUsers == true {
					flags |= 1 << 4
				}
				if m.ForwardChats == true {
					flags |= 1 << 5
				}
				if m.Groups == true {
					flags |= 1 << 10
				}
				if m.Channels == true {
					flags |= 1 << 15
				}
				if m.BotsApp == true {
					flags |= 1 << 16
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getTopPeers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getTopPeers, layer)
	}
}

// Decode <--
func (m *TLContactsGetTopPeers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x973478b6: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Correspondents = true
			}
			if (flags & (1 << 1)) != 0 {
				m.BotsPm = true
			}
			if (flags & (1 << 2)) != 0 {
				m.BotsInline = true
			}
			if (flags & (1 << 3)) != 0 {
				m.PhoneCalls = true
			}
			if (flags & (1 << 4)) != 0 {
				m.ForwardUsers = true
			}
			if (flags & (1 << 5)) != 0 {
				m.ForwardChats = true
			}
			if (flags & (1 << 10)) != 0 {
				m.Groups = true
			}
			if (flags & (1 << 15)) != 0 {
				m.Channels = true
			}
			if (flags & (1 << 16)) != 0 {
				m.BotsApp = true
			}
			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsResetTopPeerRating <--
type TLContactsResetTopPeerRating struct {
	ClazzID  uint32               `json:"_id"`
	Category TopPeerCategoryClazz `json:"category"`
	Peer     InputPeerClazz       `json:"peer"`
}

func (m *TLContactsResetTopPeerRating) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsResetTopPeerRating) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1ae373ac: func() error {
			x.PutClazzID(0x1ae373ac)

			_ = m.Category.Encode(x, layer)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_resetTopPeerRating, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_resetTopPeerRating, layer)
	}
}

// Decode <--
func (m *TLContactsResetTopPeerRating) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1ae373ac: func() (err error) {

			// m1 := &TopPeerCategory{}
			// _ = m1.Decode(d)
			// m.Category = m1
			m.Category, _ = DecodeTopPeerCategoryClazz(d)

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsResetSaved <--
type TLContactsResetSaved struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLContactsResetSaved) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsResetSaved) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x879537f1: func() error {
			x.PutClazzID(0x879537f1)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_resetSaved, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_resetSaved, layer)
	}
}

// Decode <--
func (m *TLContactsResetSaved) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x879537f1: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetSaved <--
type TLContactsGetSaved struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLContactsGetSaved) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetSaved) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x82f1e39f: func() error {
			x.PutClazzID(0x82f1e39f)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getSaved, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getSaved, layer)
	}
}

// Decode <--
func (m *TLContactsGetSaved) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x82f1e39f: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsToggleTopPeers <--
type TLContactsToggleTopPeers struct {
	ClazzID uint32    `json:"_id"`
	Enabled BoolClazz `json:"enabled"`
}

func (m *TLContactsToggleTopPeers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsToggleTopPeers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8514bdda: func() error {
			x.PutClazzID(0x8514bdda)

			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_toggleTopPeers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_toggleTopPeers, layer)
	}
}

// Decode <--
func (m *TLContactsToggleTopPeers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8514bdda: func() (err error) {

			// m1 := &Bool{}
			// _ = m1.Decode(d)
			// m.Enabled = m1
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsAddContact <--
type TLContactsAddContact struct {
	ClazzID                  uint32                `json:"_id"`
	AddPhonePrivacyException bool                  `json:"add_phone_privacy_exception"`
	Id                       InputUserClazz        `json:"id"`
	FirstName                string                `json:"first_name"`
	LastName                 string                `json:"last_name"`
	Phone                    string                `json:"phone"`
	Note                     TextWithEntitiesClazz `json:"note"`
}

func (m *TLContactsAddContact) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsAddContact) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd9ba2e54: func() error {
			x.PutClazzID(0xd9ba2e54)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.AddPhonePrivacyException == true {
					flags |= 1 << 0
				}

				if m.Note != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)
			x.PutString(m.FirstName)
			x.PutString(m.LastName)
			x.PutString(m.Phone)
			if m.Note != nil {
				_ = m.Note.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_addContact, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_addContact, layer)
	}
}

// Decode <--
func (m *TLContactsAddContact) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd9ba2e54: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.AddPhonePrivacyException = true
			}

			// m3 := &InputUser{}
			// _ = m3.Decode(d)
			// m.Id = m3
			m.Id, _ = DecodeInputUserClazz(d)

			m.FirstName, err = d.String()
			m.LastName, err = d.String()
			m.Phone, err = d.String()
			if (flags & (1 << 1)) != 0 {
				// m7 := &TextWithEntities{}
				// _ = m7.Decode(d)
				// m.Note = m7
				m.Note, _ = DecodeTextWithEntitiesClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsAcceptContact <--
type TLContactsAcceptContact struct {
	ClazzID uint32         `json:"_id"`
	Id      InputUserClazz `json:"id"`
}

func (m *TLContactsAcceptContact) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsAcceptContact) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf831a20f: func() error {
			x.PutClazzID(0xf831a20f)

			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_acceptContact, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_acceptContact, layer)
	}
}

// Decode <--
func (m *TLContactsAcceptContact) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf831a20f: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetLocated <--
type TLContactsGetLocated struct {
	ClazzID     uint32             `json:"_id"`
	Background  bool               `json:"background"`
	GeoPoint    InputGeoPointClazz `json:"geo_point"`
	SelfExpires *int32             `json:"self_expires"`
}

func (m *TLContactsGetLocated) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetLocated) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd348bc44: func() error {
			x.PutClazzID(0xd348bc44)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Background == true {
					flags |= 1 << 1
				}

				if m.SelfExpires != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.GeoPoint.Encode(x, layer)
			if m.SelfExpires != nil {
				x.PutInt32(*m.SelfExpires)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getLocated, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getLocated, layer)
	}
}

// Decode <--
func (m *TLContactsGetLocated) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd348bc44: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Background = true
			}

			// m3 := &InputGeoPoint{}
			// _ = m3.Decode(d)
			// m.GeoPoint = m3
			m.GeoPoint, _ = DecodeInputGeoPointClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.SelfExpires = new(int32)
				*m.SelfExpires, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsBlockFromReplies <--
type TLContactsBlockFromReplies struct {
	ClazzID       uint32 `json:"_id"`
	DeleteMessage bool   `json:"delete_message"`
	DeleteHistory bool   `json:"delete_history"`
	ReportSpam    bool   `json:"report_spam"`
	MsgId         int32  `json:"msg_id"`
}

func (m *TLContactsBlockFromReplies) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsBlockFromReplies) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x29a8962c: func() error {
			x.PutClazzID(0x29a8962c)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.DeleteMessage == true {
					flags |= 1 << 0
				}
				if m.DeleteHistory == true {
					flags |= 1 << 1
				}
				if m.ReportSpam == true {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_blockFromReplies, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_blockFromReplies, layer)
	}
}

// Decode <--
func (m *TLContactsBlockFromReplies) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x29a8962c: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.DeleteMessage = true
			}
			if (flags & (1 << 1)) != 0 {
				m.DeleteHistory = true
			}
			if (flags & (1 << 2)) != 0 {
				m.ReportSpam = true
			}
			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsResolvePhone <--
type TLContactsResolvePhone struct {
	ClazzID uint32 `json:"_id"`
	Phone   string `json:"phone"`
}

func (m *TLContactsResolvePhone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsResolvePhone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8af94344: func() error {
			x.PutClazzID(0x8af94344)

			x.PutString(m.Phone)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_resolvePhone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_resolvePhone, layer)
	}
}

// Decode <--
func (m *TLContactsResolvePhone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8af94344: func() (err error) {
			m.Phone, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsExportContactToken <--
type TLContactsExportContactToken struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLContactsExportContactToken) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsExportContactToken) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf8654027: func() error {
			x.PutClazzID(0xf8654027)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_exportContactToken, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_exportContactToken, layer)
	}
}

// Decode <--
func (m *TLContactsExportContactToken) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf8654027: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsImportContactToken <--
type TLContactsImportContactToken struct {
	ClazzID uint32 `json:"_id"`
	Token   string `json:"token"`
}

func (m *TLContactsImportContactToken) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsImportContactToken) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x13005788: func() error {
			x.PutClazzID(0x13005788)

			x.PutString(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_importContactToken, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_importContactToken, layer)
	}
}

// Decode <--
func (m *TLContactsImportContactToken) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x13005788: func() (err error) {
			m.Token, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsEditCloseFriends <--
type TLContactsEditCloseFriends struct {
	ClazzID uint32  `json:"_id"`
	Id      []int64 `json:"id"`
}

func (m *TLContactsEditCloseFriends) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsEditCloseFriends) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xba6705f0: func() error {
			x.PutClazzID(0xba6705f0)

			iface.EncodeInt64List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_editCloseFriends, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_editCloseFriends, layer)
	}
}

// Decode <--
func (m *TLContactsEditCloseFriends) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xba6705f0: func() (err error) {

			m.Id, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsSetBlocked <--
type TLContactsSetBlocked struct {
	ClazzID       uint32           `json:"_id"`
	MyStoriesFrom bool             `json:"my_stories_from"`
	Id            []InputPeerClazz `json:"id"`
	Limit         int32            `json:"limit"`
}

func (m *TLContactsSetBlocked) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsSetBlocked) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x94c65c76: func() error {
			x.PutClazzID(0x94c65c76)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MyStoriesFrom == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_setBlocked, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_setBlocked, layer)
	}
}

// Decode <--
func (m *TLContactsSetBlocked) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x94c65c76: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.MyStoriesFrom = true
			}
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			// v3 := make([]*InputPeer, l3)
			v3 := make([]InputPeerClazz, l3)
			for i := 0; i < l3; i++ {
				// vv := new(InputPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v3[i] = vv
				v3[i], _ = DecodeInputPeerClazz(d)
				_ = err3
			}
			m.Id = v3

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetBirthdays <--
type TLContactsGetBirthdays struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLContactsGetBirthdays) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetBirthdays) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdaeda864: func() error {
			x.PutClazzID(0xdaeda864)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getBirthdays, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getBirthdays, layer)
	}
}

// Decode <--
func (m *TLContactsGetBirthdays) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdaeda864: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetSponsoredPeers <--
type TLContactsGetSponsoredPeers struct {
	ClazzID uint32 `json:"_id"`
	Q       string `json:"q"`
}

func (m *TLContactsGetSponsoredPeers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetSponsoredPeers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb6c8c393: func() error {
			x.PutClazzID(0xb6c8c393)

			x.PutString(m.Q)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getSponsoredPeers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getSponsoredPeers, layer)
	}
}

// Decode <--
func (m *TLContactsGetSponsoredPeers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb6c8c393: func() (err error) {
			m.Q, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsUpdateContactNote <--
type TLContactsUpdateContactNote struct {
	ClazzID uint32                `json:"_id"`
	Id      InputUserClazz        `json:"id"`
	Note    TextWithEntitiesClazz `json:"note"`
}

func (m *TLContactsUpdateContactNote) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsUpdateContactNote) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x139f63fb: func() error {
			x.PutClazzID(0x139f63fb)

			_ = m.Id.Encode(x, layer)
			_ = m.Note.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_updateContactNote, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_updateContactNote, layer)
	}
}

// Decode <--
func (m *TLContactsUpdateContactNote) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x139f63fb: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputUserClazz(d)

			// m2 := &TextWithEntities{}
			// _ = m2.Decode(d)
			// m.Note = m2
			m.Note, _ = DecodeTextWithEntitiesClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessages <--
type TLMessagesGetMessages struct {
	ClazzID               uint32              `json:"_id"`
	Id_VECTORINPUTMESSAGE []InputMessageClazz `json:"id_VECTORINPUTMESSAGE"`
	Id_VECTORINT32        []int32             `json:"id_VECTORINT32"`
}

func (m *TLMessagesGetMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x63c66506: func() error {
			x.PutClazzID(0x63c66506)

			_ = iface.EncodeObjectList(x, m.Id_VECTORINPUTMESSAGE, layer)

			return nil
		},
		0x4222fa74: func() error {
			x.PutClazzID(0x4222fa74)

			iface.EncodeInt32List(x, m.Id_VECTORINT32)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x63c66506: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputMessage, l1)
			v1 := make([]InputMessageClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputMessage)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputMessageClazz(d)
				_ = err3
			}
			m.Id_VECTORINPUTMESSAGE = v1

			return nil
		},
		0x4222fa74: func() (err error) {

			m.Id_VECTORINT32, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDialogs <--
type TLMessagesGetDialogs struct {
	ClazzID       uint32         `json:"_id"`
	ExcludePinned bool           `json:"exclude_pinned"`
	FolderId      *int32         `json:"folder_id"`
	OffsetDate    int32          `json:"offset_date"`
	OffsetId      int32          `json:"offset_id"`
	OffsetPeer    InputPeerClazz `json:"offset_peer"`
	Limit         int32          `json:"limit"`
	Hash          int64          `json:"hash"`
}

func (m *TLMessagesGetDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa0f4cb4f: func() error {
			x.PutClazzID(0xa0f4cb4f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ExcludePinned == true {
					flags |= 1 << 0
				}
				if m.FolderId != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.FolderId != nil {
				x.PutInt32(*m.FolderId)
			}

			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.OffsetId)
			_ = m.OffsetPeer.Encode(x, layer)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa0f4cb4f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ExcludePinned = true
			}
			if (flags & (1 << 1)) != 0 {
				m.FolderId = new(int32)
				*m.FolderId, err = d.Int32()
			}
			m.OffsetDate, err = d.Int32()
			m.OffsetId, err = d.Int32()

			// m6 := &InputPeer{}
			// _ = m6.Decode(d)
			// m.OffsetPeer = m6
			m.OffsetPeer, _ = DecodeInputPeerClazz(d)

			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetHistory <--
type TLMessagesGetHistory struct {
	ClazzID    uint32         `json:"_id"`
	Peer       InputPeerClazz `json:"peer"`
	OffsetId   int32          `json:"offset_id"`
	OffsetDate int32          `json:"offset_date"`
	AddOffset  int32          `json:"add_offset"`
	Limit      int32          `json:"limit"`
	MaxId      int32          `json:"max_id"`
	MinId      int32          `json:"min_id"`
	Hash       int64          `json:"hash"`
}

func (m *TLMessagesGetHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4423e6c5: func() error {
			x.PutClazzID(0x4423e6c5)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesGetHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4423e6c5: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.OffsetId, err = d.Int32()
			m.OffsetDate, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearch <--
type TLMessagesSearch struct {
	ClazzID       uint32              `json:"_id"`
	Peer          InputPeerClazz      `json:"peer"`
	Q             string              `json:"q"`
	FromId        InputPeerClazz      `json:"from_id"`
	SavedPeerId   InputPeerClazz      `json:"saved_peer_id"`
	SavedReaction []ReactionClazz     `json:"saved_reaction"`
	TopMsgId      *int32              `json:"top_msg_id"`
	Filter        MessagesFilterClazz `json:"filter"`
	MinDate       int32               `json:"min_date"`
	MaxDate       int32               `json:"max_date"`
	OffsetId      int32               `json:"offset_id"`
	AddOffset     int32               `json:"add_offset"`
	Limit         int32               `json:"limit"`
	MaxId         int32               `json:"max_id"`
	MinId         int32               `json:"min_id"`
	Hash          int64               `json:"hash"`
}

func (m *TLMessagesSearch) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearch) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x29ee847a: func() error {
			x.PutClazzID(0x29ee847a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FromId != nil {
					flags |= 1 << 0
				}
				if m.SavedPeerId != nil {
					flags |= 1 << 2
				}
				if m.SavedReaction != nil {
					flags |= 1 << 3
				}
				if m.TopMsgId != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Q)
			if m.FromId != nil {
				_ = m.FromId.Encode(x, layer)
			}

			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			if m.SavedReaction != nil {
				_ = iface.EncodeObjectList(x, m.SavedReaction, layer)
			}
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.MinDate)
			x.PutInt32(m.MaxDate)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_search, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_search, layer)
	}
}

// Decode <--
func (m *TLMessagesSearch) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x29ee847a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Q, err = d.String()
			if (flags & (1 << 0)) != 0 {
				// m4 := &InputPeer{}
				// _ = m4.Decode(d)
				// m.FromId = m4
				m.FromId, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				// m5 := &InputPeer{}
				// _ = m5.Decode(d)
				// m.SavedPeerId = m5
				m.SavedPeerId, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 3)) != 0 {
				c6, err2 := d.ClazzID()
				if c6 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 6, c6)
					return err2
				}
				l6, err3 := d.Int()
				// v6 := make([]*Reaction, l6)
				v6 := make([]ReactionClazz, l6)
				for i := 0; i < l6; i++ {
					// vv := new(Reaction)
					// err3 = vv.Decode(d)
					// _ = err3
					// v6[i] = vv
					v6[i], _ = DecodeReactionClazz(d)
					_ = err3
				}
				m.SavedReaction = v6
			}
			if (flags & (1 << 1)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}

			// m8 := &MessagesFilter{}
			// _ = m8.Decode(d)
			// m.Filter = m8
			m.Filter, _ = DecodeMessagesFilterClazz(d)

			m.MinDate, err = d.Int32()
			m.MaxDate, err = d.Int32()
			m.OffsetId, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadHistory <--
type TLMessagesReadHistory struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MaxId   int32          `json:"max_id"`
}

func (m *TLMessagesReadHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe306d3a: func() error {
			x.PutClazzID(0xe306d3a)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesReadHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe306d3a: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteHistory <--
type TLMessagesDeleteHistory struct {
	ClazzID   uint32         `json:"_id"`
	JustClear bool           `json:"just_clear"`
	Revoke    bool           `json:"revoke"`
	Peer      InputPeerClazz `json:"peer"`
	MaxId     int32          `json:"max_id"`
	MinDate   *int32         `json:"min_date"`
	MaxDate   *int32         `json:"max_date"`
}

func (m *TLMessagesDeleteHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb08f922a: func() error {
			x.PutClazzID(0xb08f922a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.JustClear == true {
					flags |= 1 << 0
				}
				if m.Revoke == true {
					flags |= 1 << 1
				}

				if m.MinDate != nil {
					flags |= 1 << 2
				}
				if m.MaxDate != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxId)
			if m.MinDate != nil {
				x.PutInt32(*m.MinDate)
			}

			if m.MaxDate != nil {
				x.PutInt32(*m.MaxDate)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb08f922a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.JustClear = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Revoke = true
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MaxId, err = d.Int32()
			if (flags & (1 << 2)) != 0 {
				m.MinDate = new(int32)
				*m.MinDate, err = d.Int32()
			}
			if (flags & (1 << 3)) != 0 {
				m.MaxDate = new(int32)
				*m.MaxDate, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteMessages <--
type TLMessagesDeleteMessages struct {
	ClazzID uint32  `json:"_id"`
	Revoke  bool    `json:"revoke"`
	Id      []int32 `json:"id"`
}

func (m *TLMessagesDeleteMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe58e95d2: func() error {
			x.PutClazzID(0xe58e95d2)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Revoke == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe58e95d2: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Revoke = true
			}

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReceivedMessages <--
type TLMessagesReceivedMessages struct {
	ClazzID uint32 `json:"_id"`
	MaxId   int32  `json:"max_id"`
}

func (m *TLMessagesReceivedMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReceivedMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5a954c0: func() error {
			x.PutClazzID(0x5a954c0)

			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_receivedMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_receivedMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesReceivedMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5a954c0: func() (err error) {
			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetTyping <--
type TLMessagesSetTyping struct {
	ClazzID  uint32                 `json:"_id"`
	Peer     InputPeerClazz         `json:"peer"`
	TopMsgId *int32                 `json:"top_msg_id"`
	Action   SendMessageActionClazz `json:"action"`
}

func (m *TLMessagesSetTyping) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetTyping) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x58943ee2: func() error {
			x.PutClazzID(0x58943ee2)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			_ = m.Action.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setTyping, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setTyping, layer)
	}
}

// Decode <--
func (m *TLMessagesSetTyping) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x58943ee2: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}

			// m4 := &SendMessageAction{}
			// _ = m4.Decode(d)
			// m.Action = m4
			m.Action, _ = DecodeSendMessageActionClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendMessage <--
type TLMessagesSendMessage struct {
	ClazzID                uint32                       `json:"_id"`
	NoWebpage              bool                         `json:"no_webpage"`
	Silent                 bool                         `json:"silent"`
	Background             bool                         `json:"background"`
	ClearDraft             bool                         `json:"clear_draft"`
	Noforwards             bool                         `json:"noforwards"`
	UpdateStickersetsOrder bool                         `json:"update_stickersets_order"`
	InvertMedia            bool                         `json:"invert_media"`
	AllowPaidFloodskip     bool                         `json:"allow_paid_floodskip"`
	Peer                   InputPeerClazz               `json:"peer"`
	ReplyTo                InputReplyToClazz            `json:"reply_to"`
	Message                string                       `json:"message"`
	RandomId               int64                        `json:"random_id"`
	ReplyMarkup            ReplyMarkupClazz             `json:"reply_markup"`
	Entities               []MessageEntityClazz         `json:"entities"`
	ScheduleDate           *int32                       `json:"schedule_date"`
	SendAs                 InputPeerClazz               `json:"send_as"`
	QuickReplyShortcut     InputQuickReplyShortcutClazz `json:"quick_reply_shortcut"`
	Effect                 *int64                       `json:"effect"`
	AllowPaidStars         *int64                       `json:"allow_paid_stars"`
	SuggestedPost          SuggestedPostClazz           `json:"suggested_post"`
}

func (m *TLMessagesSendMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfe05dc9a: func() error {
			x.PutClazzID(0xfe05dc9a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoWebpage == true {
					flags |= 1 << 1
				}
				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.UpdateStickersetsOrder == true {
					flags |= 1 << 15
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ReplyMarkup != nil {
					flags |= 1 << 2
				}
				if m.Entities != nil {
					flags |= 1 << 3
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.Effect != nil {
					flags |= 1 << 18
				}
				if m.AllowPaidStars != nil {
					flags |= 1 << 21
				}
				if m.SuggestedPost != nil {
					flags |= 1 << 22
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			x.PutString(m.Message)
			x.PutInt64(m.RandomId)
			if m.ReplyMarkup != nil {
				_ = m.ReplyMarkup.Encode(x, layer)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			if m.SuggestedPost != nil {
				_ = m.SuggestedPost.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesSendMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfe05dc9a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.NoWebpage = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 15)) != 0 {
				m.UpdateStickersetsOrder = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			// m10 := &InputPeer{}
			// _ = m10.Decode(d)
			// m.Peer = m10
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m11 := &InputReplyTo{}
				// _ = m11.Decode(d)
				// m.ReplyTo = m11
				m.ReplyTo, _ = DecodeInputReplyToClazz(d)
			}
			m.Message, err = d.String()
			m.RandomId, err = d.Int64()
			if (flags & (1 << 2)) != 0 {
				// m14 := &ReplyMarkup{}
				// _ = m14.Decode(d)
				// m.ReplyMarkup = m14
				m.ReplyMarkup, _ = DecodeReplyMarkupClazz(d)
			}
			if (flags & (1 << 3)) != 0 {
				c15, err2 := d.ClazzID()
				if c15 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 15, c15)
					return err2
				}
				l15, err3 := d.Int()
				// v15 := make([]*MessageEntity, l15)
				v15 := make([]MessageEntityClazz, l15)
				for i := 0; i < l15; i++ {
					// vv := new(MessageEntity)
					// err3 = vv.Decode(d)
					// _ = err3
					// v15[i] = vv
					v15[i], _ = DecodeMessageEntityClazz(d)
					_ = err3
				}
				m.Entities = v15
			}
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				// m17 := &InputPeer{}
				// _ = m17.Decode(d)
				// m.SendAs = m17
				m.SendAs, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 17)) != 0 {
				// m18 := &InputQuickReplyShortcut{}
				// _ = m18.Decode(d)
				// m.QuickReplyShortcut = m18
				m.QuickReplyShortcut, _ = DecodeInputQuickReplyShortcutClazz(d)
			}
			if (flags & (1 << 18)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			if (flags & (1 << 21)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			if (flags & (1 << 22)) != 0 {
				// m21 := &SuggestedPost{}
				// _ = m21.Decode(d)
				// m.SuggestedPost = m21
				m.SuggestedPost, _ = DecodeSuggestedPostClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendMedia <--
type TLMessagesSendMedia struct {
	ClazzID                uint32                       `json:"_id"`
	Silent                 bool                         `json:"silent"`
	Background             bool                         `json:"background"`
	ClearDraft             bool                         `json:"clear_draft"`
	Noforwards             bool                         `json:"noforwards"`
	UpdateStickersetsOrder bool                         `json:"update_stickersets_order"`
	InvertMedia            bool                         `json:"invert_media"`
	AllowPaidFloodskip     bool                         `json:"allow_paid_floodskip"`
	Peer                   InputPeerClazz               `json:"peer"`
	ReplyTo                InputReplyToClazz            `json:"reply_to"`
	Media                  InputMediaClazz              `json:"media"`
	Message                string                       `json:"message"`
	RandomId               int64                        `json:"random_id"`
	ReplyMarkup            ReplyMarkupClazz             `json:"reply_markup"`
	Entities               []MessageEntityClazz         `json:"entities"`
	ScheduleDate           *int32                       `json:"schedule_date"`
	SendAs                 InputPeerClazz               `json:"send_as"`
	QuickReplyShortcut     InputQuickReplyShortcutClazz `json:"quick_reply_shortcut"`
	Effect                 *int64                       `json:"effect"`
	AllowPaidStars         *int64                       `json:"allow_paid_stars"`
	SuggestedPost          SuggestedPostClazz           `json:"suggested_post"`
}

func (m *TLMessagesSendMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xac55d9c1: func() error {
			x.PutClazzID(0xac55d9c1)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.UpdateStickersetsOrder == true {
					flags |= 1 << 15
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ReplyMarkup != nil {
					flags |= 1 << 2
				}
				if m.Entities != nil {
					flags |= 1 << 3
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.Effect != nil {
					flags |= 1 << 18
				}
				if m.AllowPaidStars != nil {
					flags |= 1 << 21
				}
				if m.SuggestedPost != nil {
					flags |= 1 << 22
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			_ = m.Media.Encode(x, layer)
			x.PutString(m.Message)
			x.PutInt64(m.RandomId)
			if m.ReplyMarkup != nil {
				_ = m.ReplyMarkup.Encode(x, layer)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			if m.SuggestedPost != nil {
				_ = m.SuggestedPost.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesSendMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xac55d9c1: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 15)) != 0 {
				m.UpdateStickersetsOrder = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			// m9 := &InputPeer{}
			// _ = m9.Decode(d)
			// m.Peer = m9
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m10 := &InputReplyTo{}
				// _ = m10.Decode(d)
				// m.ReplyTo = m10
				m.ReplyTo, _ = DecodeInputReplyToClazz(d)
			}

			// m11 := &InputMedia{}
			// _ = m11.Decode(d)
			// m.Media = m11
			m.Media, _ = DecodeInputMediaClazz(d)

			m.Message, err = d.String()
			m.RandomId, err = d.Int64()
			if (flags & (1 << 2)) != 0 {
				// m14 := &ReplyMarkup{}
				// _ = m14.Decode(d)
				// m.ReplyMarkup = m14
				m.ReplyMarkup, _ = DecodeReplyMarkupClazz(d)
			}
			if (flags & (1 << 3)) != 0 {
				c15, err2 := d.ClazzID()
				if c15 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 15, c15)
					return err2
				}
				l15, err3 := d.Int()
				// v15 := make([]*MessageEntity, l15)
				v15 := make([]MessageEntityClazz, l15)
				for i := 0; i < l15; i++ {
					// vv := new(MessageEntity)
					// err3 = vv.Decode(d)
					// _ = err3
					// v15[i] = vv
					v15[i], _ = DecodeMessageEntityClazz(d)
					_ = err3
				}
				m.Entities = v15
			}
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				// m17 := &InputPeer{}
				// _ = m17.Decode(d)
				// m.SendAs = m17
				m.SendAs, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 17)) != 0 {
				// m18 := &InputQuickReplyShortcut{}
				// _ = m18.Decode(d)
				// m.QuickReplyShortcut = m18
				m.QuickReplyShortcut, _ = DecodeInputQuickReplyShortcutClazz(d)
			}
			if (flags & (1 << 18)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			if (flags & (1 << 21)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			if (flags & (1 << 22)) != 0 {
				// m21 := &SuggestedPost{}
				// _ = m21.Decode(d)
				// m.SuggestedPost = m21
				m.SuggestedPost, _ = DecodeSuggestedPostClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesForwardMessages <--
type TLMessagesForwardMessages struct {
	ClazzID            uint32                       `json:"_id"`
	Silent             bool                         `json:"silent"`
	Background         bool                         `json:"background"`
	WithMyScore        bool                         `json:"with_my_score"`
	DropAuthor         bool                         `json:"drop_author"`
	DropMediaCaptions  bool                         `json:"drop_media_captions"`
	Noforwards         bool                         `json:"noforwards"`
	AllowPaidFloodskip bool                         `json:"allow_paid_floodskip"`
	FromPeer           InputPeerClazz               `json:"from_peer"`
	Id                 []int32                      `json:"id"`
	RandomId           []int64                      `json:"random_id"`
	ToPeer             InputPeerClazz               `json:"to_peer"`
	TopMsgId           *int32                       `json:"top_msg_id"`
	ReplyTo            InputReplyToClazz            `json:"reply_to"`
	ScheduleDate       *int32                       `json:"schedule_date"`
	SendAs             InputPeerClazz               `json:"send_as"`
	QuickReplyShortcut InputQuickReplyShortcutClazz `json:"quick_reply_shortcut"`
	VideoTimestamp     *int32                       `json:"video_timestamp"`
	AllowPaidStars     *int64                       `json:"allow_paid_stars"`
	SuggestedPost      SuggestedPostClazz           `json:"suggested_post"`
}

func (m *TLMessagesForwardMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesForwardMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x978928ca: func() error {
			x.PutClazzID(0x978928ca)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.WithMyScore == true {
					flags |= 1 << 8
				}
				if m.DropAuthor == true {
					flags |= 1 << 11
				}
				if m.DropMediaCaptions == true {
					flags |= 1 << 12
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.TopMsgId != nil {
					flags |= 1 << 9
				}
				if m.ReplyTo != nil {
					flags |= 1 << 22
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.VideoTimestamp != nil {
					flags |= 1 << 20
				}
				if m.AllowPaidStars != nil {
					flags |= 1 << 21
				}
				if m.SuggestedPost != nil {
					flags |= 1 << 23
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.FromPeer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			iface.EncodeInt64List(x, m.RandomId)

			_ = m.ToPeer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.VideoTimestamp != nil {
				x.PutInt32(*m.VideoTimestamp)
			}

			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			if m.SuggestedPost != nil {
				_ = m.SuggestedPost.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_forwardMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_forwardMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesForwardMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x978928ca: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 8)) != 0 {
				m.WithMyScore = true
			}
			if (flags & (1 << 11)) != 0 {
				m.DropAuthor = true
			}
			if (flags & (1 << 12)) != 0 {
				m.DropMediaCaptions = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			// m9 := &InputPeer{}
			// _ = m9.Decode(d)
			// m.FromPeer = m9
			m.FromPeer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			m.RandomId, err = iface.DecodeInt64List(d)

			// m12 := &InputPeer{}
			// _ = m12.Decode(d)
			// m.ToPeer = m12
			m.ToPeer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 9)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			if (flags & (1 << 22)) != 0 {
				// m14 := &InputReplyTo{}
				// _ = m14.Decode(d)
				// m.ReplyTo = m14
				m.ReplyTo, _ = DecodeInputReplyToClazz(d)
			}
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				// m16 := &InputPeer{}
				// _ = m16.Decode(d)
				// m.SendAs = m16
				m.SendAs, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 17)) != 0 {
				// m17 := &InputQuickReplyShortcut{}
				// _ = m17.Decode(d)
				// m.QuickReplyShortcut = m17
				m.QuickReplyShortcut, _ = DecodeInputQuickReplyShortcutClazz(d)
			}
			if (flags & (1 << 20)) != 0 {
				m.VideoTimestamp = new(int32)
				*m.VideoTimestamp, err = d.Int32()
			}
			if (flags & (1 << 21)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			if (flags & (1 << 23)) != 0 {
				// m20 := &SuggestedPost{}
				// _ = m20.Decode(d)
				// m.SuggestedPost = m20
				m.SuggestedPost, _ = DecodeSuggestedPostClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReportSpam <--
type TLMessagesReportSpam struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLMessagesReportSpam) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReportSpam) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcf1592db: func() error {
			x.PutClazzID(0xcf1592db)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reportSpam, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reportSpam, layer)
	}
}

// Decode <--
func (m *TLMessagesReportSpam) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcf1592db: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPeerSettings <--
type TLMessagesGetPeerSettings struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLMessagesGetPeerSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPeerSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xefd9a6a2: func() error {
			x.PutClazzID(0xefd9a6a2)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPeerSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPeerSettings, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPeerSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xefd9a6a2: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReport <--
type TLMessagesReport struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
	Option  []byte         `json:"option"`
	Message string         `json:"message"`
}

func (m *TLMessagesReport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfc78af9b: func() error {
			x.PutClazzID(0xfc78af9b)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			x.PutBytes(m.Option)
			x.PutString(m.Message)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_report, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_report, layer)
	}
}

// Decode <--
func (m *TLMessagesReport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfc78af9b: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			m.Option, err = d.Bytes()
			m.Message, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetChats <--
type TLMessagesGetChats struct {
	ClazzID uint32  `json:"_id"`
	Id      []int64 `json:"id"`
}

func (m *TLMessagesGetChats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetChats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x49e9528f: func() error {
			x.PutClazzID(0x49e9528f)

			iface.EncodeInt64List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getChats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getChats, layer)
	}
}

// Decode <--
func (m *TLMessagesGetChats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x49e9528f: func() (err error) {

			m.Id, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetFullChat <--
type TLMessagesGetFullChat struct {
	ClazzID uint32 `json:"_id"`
	ChatId  int64  `json:"chat_id"`
}

func (m *TLMessagesGetFullChat) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetFullChat) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaeb00b34: func() error {
			x.PutClazzID(0xaeb00b34)

			x.PutInt64(m.ChatId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getFullChat, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getFullChat, layer)
	}
}

// Decode <--
func (m *TLMessagesGetFullChat) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaeb00b34: func() (err error) {
			m.ChatId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditChatTitle <--
type TLMessagesEditChatTitle struct {
	ClazzID uint32 `json:"_id"`
	ChatId  int64  `json:"chat_id"`
	Title   string `json:"title"`
}

func (m *TLMessagesEditChatTitle) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditChatTitle) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x73783ffd: func() error {
			x.PutClazzID(0x73783ffd)

			x.PutInt64(m.ChatId)
			x.PutString(m.Title)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editChatTitle, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editChatTitle, layer)
	}
}

// Decode <--
func (m *TLMessagesEditChatTitle) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x73783ffd: func() (err error) {
			m.ChatId, err = d.Int64()
			m.Title, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditChatPhoto <--
type TLMessagesEditChatPhoto struct {
	ClazzID uint32              `json:"_id"`
	ChatId  int64               `json:"chat_id"`
	Photo   InputChatPhotoClazz `json:"photo"`
}

func (m *TLMessagesEditChatPhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditChatPhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x35ddd674: func() error {
			x.PutClazzID(0x35ddd674)

			x.PutInt64(m.ChatId)
			_ = m.Photo.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editChatPhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editChatPhoto, layer)
	}
}

// Decode <--
func (m *TLMessagesEditChatPhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x35ddd674: func() (err error) {
			m.ChatId, err = d.Int64()

			// m2 := &InputChatPhoto{}
			// _ = m2.Decode(d)
			// m.Photo = m2
			m.Photo, _ = DecodeInputChatPhotoClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesAddChatUser <--
type TLMessagesAddChatUser struct {
	ClazzID  uint32         `json:"_id"`
	ChatId   int64          `json:"chat_id"`
	UserId   InputUserClazz `json:"user_id"`
	FwdLimit int32          `json:"fwd_limit"`
}

func (m *TLMessagesAddChatUser) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesAddChatUser) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcbc6d107: func() error {
			x.PutClazzID(0xcbc6d107)

			x.PutInt64(m.ChatId)
			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.FwdLimit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_addChatUser, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_addChatUser, layer)
	}
}

// Decode <--
func (m *TLMessagesAddChatUser) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcbc6d107: func() (err error) {
			m.ChatId, err = d.Int64()

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.UserId = m2
			m.UserId, _ = DecodeInputUserClazz(d)

			m.FwdLimit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteChatUser <--
type TLMessagesDeleteChatUser struct {
	ClazzID       uint32         `json:"_id"`
	RevokeHistory bool           `json:"revoke_history"`
	ChatId        int64          `json:"chat_id"`
	UserId        InputUserClazz `json:"user_id"`
}

func (m *TLMessagesDeleteChatUser) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteChatUser) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa2185cab: func() error {
			x.PutClazzID(0xa2185cab)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.RevokeHistory == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.ChatId)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteChatUser, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteChatUser, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteChatUser) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa2185cab: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.RevokeHistory = true
			}
			m.ChatId, err = d.Int64()

			// m4 := &InputUser{}
			// _ = m4.Decode(d)
			// m.UserId = m4
			m.UserId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCreateChat <--
type TLMessagesCreateChat struct {
	ClazzID   uint32           `json:"_id"`
	Users     []InputUserClazz `json:"users"`
	Title     string           `json:"title"`
	TtlPeriod *int32           `json:"ttl_period"`
}

func (m *TLMessagesCreateChat) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCreateChat) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x92ceddd4: func() error {
			x.PutClazzID(0x92ceddd4)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TtlPeriod != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			_ = iface.EncodeObjectList(x, m.Users, layer)

			x.PutString(m.Title)
			if m.TtlPeriod != nil {
				x.PutInt32(*m.TtlPeriod)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_createChat, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_createChat, layer)
	}
}

// Decode <--
func (m *TLMessagesCreateChat) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x92ceddd4: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputUser, l2)
			v2 := make([]InputUserClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputUser)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputUserClazz(d)
				_ = err3
			}
			m.Users = v2

			m.Title, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.TtlPeriod = new(int32)
				*m.TtlPeriod, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDhConfig <--
type TLMessagesGetDhConfig struct {
	ClazzID      uint32 `json:"_id"`
	Version      int32  `json:"version"`
	RandomLength int32  `json:"random_length"`
}

func (m *TLMessagesGetDhConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDhConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x26cf8950: func() error {
			x.PutClazzID(0x26cf8950)

			x.PutInt32(m.Version)
			x.PutInt32(m.RandomLength)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDhConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDhConfig, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDhConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x26cf8950: func() (err error) {
			m.Version, err = d.Int32()
			m.RandomLength, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestEncryption <--
type TLMessagesRequestEncryption struct {
	ClazzID  uint32         `json:"_id"`
	UserId   InputUserClazz `json:"user_id"`
	RandomId int32          `json:"random_id"`
	GA       []byte         `json:"g_a"`
}

func (m *TLMessagesRequestEncryption) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestEncryption) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf64daf43: func() error {
			x.PutClazzID(0xf64daf43)

			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.RandomId)
			x.PutBytes(m.GA)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestEncryption, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestEncryption, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestEncryption) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf64daf43: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.UserId = m1
			m.UserId, _ = DecodeInputUserClazz(d)

			m.RandomId, err = d.Int32()
			m.GA, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesAcceptEncryption <--
type TLMessagesAcceptEncryption struct {
	ClazzID        uint32                  `json:"_id"`
	Peer           InputEncryptedChatClazz `json:"peer"`
	GB             []byte                  `json:"g_b"`
	KeyFingerprint int64                   `json:"key_fingerprint"`
}

func (m *TLMessagesAcceptEncryption) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesAcceptEncryption) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3dbc0415: func() error {
			x.PutClazzID(0x3dbc0415)

			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.GB)
			x.PutInt64(m.KeyFingerprint)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_acceptEncryption, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_acceptEncryption, layer)
	}
}

// Decode <--
func (m *TLMessagesAcceptEncryption) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3dbc0415: func() (err error) {

			// m1 := &InputEncryptedChat{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputEncryptedChatClazz(d)

			m.GB, err = d.Bytes()
			m.KeyFingerprint, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDiscardEncryption <--
type TLMessagesDiscardEncryption struct {
	ClazzID       uint32 `json:"_id"`
	DeleteHistory bool   `json:"delete_history"`
	ChatId        int32  `json:"chat_id"`
}

func (m *TLMessagesDiscardEncryption) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDiscardEncryption) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf393aea0: func() error {
			x.PutClazzID(0xf393aea0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.DeleteHistory == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.ChatId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_discardEncryption, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_discardEncryption, layer)
	}
}

// Decode <--
func (m *TLMessagesDiscardEncryption) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf393aea0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.DeleteHistory = true
			}
			m.ChatId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetEncryptedTyping <--
type TLMessagesSetEncryptedTyping struct {
	ClazzID uint32                  `json:"_id"`
	Peer    InputEncryptedChatClazz `json:"peer"`
	Typing  BoolClazz               `json:"typing"`
}

func (m *TLMessagesSetEncryptedTyping) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetEncryptedTyping) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x791451ed: func() error {
			x.PutClazzID(0x791451ed)

			_ = m.Peer.Encode(x, layer)
			_ = m.Typing.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setEncryptedTyping, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setEncryptedTyping, layer)
	}
}

// Decode <--
func (m *TLMessagesSetEncryptedTyping) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x791451ed: func() (err error) {

			// m1 := &InputEncryptedChat{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputEncryptedChatClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Typing = m2
			m.Typing, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadEncryptedHistory <--
type TLMessagesReadEncryptedHistory struct {
	ClazzID uint32                  `json:"_id"`
	Peer    InputEncryptedChatClazz `json:"peer"`
	MaxDate int32                   `json:"max_date"`
}

func (m *TLMessagesReadEncryptedHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadEncryptedHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7f4b690a: func() error {
			x.PutClazzID(0x7f4b690a)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxDate)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readEncryptedHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readEncryptedHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesReadEncryptedHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7f4b690a: func() (err error) {

			// m1 := &InputEncryptedChat{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputEncryptedChatClazz(d)

			m.MaxDate, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendEncrypted <--
type TLMessagesSendEncrypted struct {
	ClazzID  uint32                  `json:"_id"`
	Silent   bool                    `json:"silent"`
	Peer     InputEncryptedChatClazz `json:"peer"`
	RandomId int64                   `json:"random_id"`
	Data     []byte                  `json:"data"`
}

func (m *TLMessagesSendEncrypted) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendEncrypted) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x44fa7a15: func() error {
			x.PutClazzID(0x44fa7a15)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.RandomId)
			x.PutBytes(m.Data)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendEncrypted, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendEncrypted, layer)
	}
}

// Decode <--
func (m *TLMessagesSendEncrypted) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x44fa7a15: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Silent = true
			}

			// m3 := &InputEncryptedChat{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputEncryptedChatClazz(d)

			m.RandomId, err = d.Int64()
			m.Data, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendEncryptedFile <--
type TLMessagesSendEncryptedFile struct {
	ClazzID  uint32                  `json:"_id"`
	Silent   bool                    `json:"silent"`
	Peer     InputEncryptedChatClazz `json:"peer"`
	RandomId int64                   `json:"random_id"`
	Data     []byte                  `json:"data"`
	File     InputEncryptedFileClazz `json:"file"`
}

func (m *TLMessagesSendEncryptedFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendEncryptedFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5559481d: func() error {
			x.PutClazzID(0x5559481d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.RandomId)
			x.PutBytes(m.Data)
			_ = m.File.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendEncryptedFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendEncryptedFile, layer)
	}
}

// Decode <--
func (m *TLMessagesSendEncryptedFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5559481d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Silent = true
			}

			// m3 := &InputEncryptedChat{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputEncryptedChatClazz(d)

			m.RandomId, err = d.Int64()
			m.Data, err = d.Bytes()

			// m6 := &InputEncryptedFile{}
			// _ = m6.Decode(d)
			// m.File = m6
			m.File, _ = DecodeInputEncryptedFileClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendEncryptedService <--
type TLMessagesSendEncryptedService struct {
	ClazzID  uint32                  `json:"_id"`
	Peer     InputEncryptedChatClazz `json:"peer"`
	RandomId int64                   `json:"random_id"`
	Data     []byte                  `json:"data"`
}

func (m *TLMessagesSendEncryptedService) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendEncryptedService) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x32d439a4: func() error {
			x.PutClazzID(0x32d439a4)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.RandomId)
			x.PutBytes(m.Data)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendEncryptedService, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendEncryptedService, layer)
	}
}

// Decode <--
func (m *TLMessagesSendEncryptedService) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x32d439a4: func() (err error) {

			// m1 := &InputEncryptedChat{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputEncryptedChatClazz(d)

			m.RandomId, err = d.Int64()
			m.Data, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReceivedQueue <--
type TLMessagesReceivedQueue struct {
	ClazzID uint32 `json:"_id"`
	MaxQts  int32  `json:"max_qts"`
}

func (m *TLMessagesReceivedQueue) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReceivedQueue) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x55a5bb66: func() error {
			x.PutClazzID(0x55a5bb66)

			x.PutInt32(m.MaxQts)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_receivedQueue, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_receivedQueue, layer)
	}
}

// Decode <--
func (m *TLMessagesReceivedQueue) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x55a5bb66: func() (err error) {
			m.MaxQts, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReportEncryptedSpam <--
type TLMessagesReportEncryptedSpam struct {
	ClazzID uint32                  `json:"_id"`
	Peer    InputEncryptedChatClazz `json:"peer"`
}

func (m *TLMessagesReportEncryptedSpam) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReportEncryptedSpam) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4b0c8c0f: func() error {
			x.PutClazzID(0x4b0c8c0f)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reportEncryptedSpam, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reportEncryptedSpam, layer)
	}
}

// Decode <--
func (m *TLMessagesReportEncryptedSpam) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4b0c8c0f: func() (err error) {

			// m1 := &InputEncryptedChat{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputEncryptedChatClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadMessageContents <--
type TLMessagesReadMessageContents struct {
	ClazzID uint32  `json:"_id"`
	Id      []int32 `json:"id"`
}

func (m *TLMessagesReadMessageContents) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadMessageContents) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x36a73f77: func() error {
			x.PutClazzID(0x36a73f77)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readMessageContents, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readMessageContents, layer)
	}
}

// Decode <--
func (m *TLMessagesReadMessageContents) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x36a73f77: func() (err error) {

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetStickers <--
type TLMessagesGetStickers struct {
	ClazzID  uint32 `json:"_id"`
	Emoticon string `json:"emoticon"`
	Hash     int64  `json:"hash"`
}

func (m *TLMessagesGetStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd5a5d3a1: func() error {
			x.PutClazzID(0xd5a5d3a1)

			x.PutString(m.Emoticon)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd5a5d3a1: func() (err error) {
			m.Emoticon, err = d.String()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAllStickers <--
type TLMessagesGetAllStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetAllStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAllStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb8a0a1a8: func() error {
			x.PutClazzID(0xb8a0a1a8)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAllStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAllStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAllStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb8a0a1a8: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetWebPagePreview <--
type TLMessagesGetWebPagePreview struct {
	ClazzID  uint32               `json:"_id"`
	Message  string               `json:"message"`
	Entities []MessageEntityClazz `json:"entities"`
}

func (m *TLMessagesGetWebPagePreview) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetWebPagePreview) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x570d6f6f: func() error {
			x.PutClazzID(0x570d6f6f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Entities != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Message)
			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getWebPagePreview, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getWebPagePreview, layer)
	}
}

// Decode <--
func (m *TLMessagesGetWebPagePreview) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x570d6f6f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Message, err = d.String()
			if (flags & (1 << 3)) != 0 {
				c3, err2 := d.ClazzID()
				if c3 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
					return err2
				}
				l3, err3 := d.Int()
				// v3 := make([]*MessageEntity, l3)
				v3 := make([]MessageEntityClazz, l3)
				for i := 0; i < l3; i++ {
					// vv := new(MessageEntity)
					// err3 = vv.Decode(d)
					// _ = err3
					// v3[i] = vv
					v3[i], _ = DecodeMessageEntityClazz(d)
					_ = err3
				}
				m.Entities = v3
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesExportChatInvite <--
type TLMessagesExportChatInvite struct {
	ClazzID               uint32                        `json:"_id"`
	LegacyRevokePermanent bool                          `json:"legacy_revoke_permanent"`
	RequestNeeded         bool                          `json:"request_needed"`
	Peer                  InputPeerClazz                `json:"peer"`
	ExpireDate            *int32                        `json:"expire_date"`
	UsageLimit            *int32                        `json:"usage_limit"`
	Title                 *string                       `json:"title"`
	SubscriptionPricing   StarsSubscriptionPricingClazz `json:"subscription_pricing"`
}

func (m *TLMessagesExportChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesExportChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa455de90: func() error {
			x.PutClazzID(0xa455de90)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.LegacyRevokePermanent == true {
					flags |= 1 << 2
				}
				if m.RequestNeeded == true {
					flags |= 1 << 3
				}

				if m.ExpireDate != nil {
					flags |= 1 << 0
				}
				if m.UsageLimit != nil {
					flags |= 1 << 1
				}
				if m.Title != nil {
					flags |= 1 << 4
				}
				if m.SubscriptionPricing != nil {
					flags |= 1 << 5
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ExpireDate != nil {
				x.PutInt32(*m.ExpireDate)
			}

			if m.UsageLimit != nil {
				x.PutInt32(*m.UsageLimit)
			}

			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.SubscriptionPricing != nil {
				_ = m.SubscriptionPricing.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_exportChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_exportChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesExportChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa455de90: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m.LegacyRevokePermanent = true
			}
			if (flags & (1 << 3)) != 0 {
				m.RequestNeeded = true
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.ExpireDate = new(int32)
				*m.ExpireDate, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m.UsageLimit = new(int32)
				*m.UsageLimit, err = d.Int32()
			}
			if (flags & (1 << 4)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 5)) != 0 {
				// m8 := &StarsSubscriptionPricing{}
				// _ = m8.Decode(d)
				// m.SubscriptionPricing = m8
				m.SubscriptionPricing, _ = DecodeStarsSubscriptionPricingClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCheckChatInvite <--
type TLMessagesCheckChatInvite struct {
	ClazzID uint32 `json:"_id"`
	Hash    string `json:"hash"`
}

func (m *TLMessagesCheckChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCheckChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3eadb1bb: func() error {
			x.PutClazzID(0x3eadb1bb)

			x.PutString(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_checkChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_checkChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesCheckChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3eadb1bb: func() (err error) {
			m.Hash, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesImportChatInvite <--
type TLMessagesImportChatInvite struct {
	ClazzID uint32 `json:"_id"`
	Hash    string `json:"hash"`
}

func (m *TLMessagesImportChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesImportChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6c50051c: func() error {
			x.PutClazzID(0x6c50051c)

			x.PutString(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_importChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_importChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesImportChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6c50051c: func() (err error) {
			m.Hash, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetStickerSet <--
type TLMessagesGetStickerSet struct {
	ClazzID    uint32               `json:"_id"`
	Stickerset InputStickerSetClazz `json:"stickerset"`
	Hash       int32                `json:"hash"`
}

func (m *TLMessagesGetStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc8a0ec74: func() error {
			x.PutClazzID(0xc8a0ec74)

			_ = m.Stickerset.Encode(x, layer)
			x.PutInt32(m.Hash)

			return nil
		},
		0x2619a90e: func() error {
			x.PutClazzID(0x2619a90e)

			_ = m.Stickerset.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getStickerSet, layer)
	}
}

// Decode <--
func (m *TLMessagesGetStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc8a0ec74: func() (err error) {

			// m1 := &InputStickerSet{}
			// _ = m1.Decode(d)
			// m.Stickerset = m1
			m.Stickerset, _ = DecodeInputStickerSetClazz(d)

			m.Hash, err = d.Int32()

			return nil
		},
		0x2619a90e: func() (err error) {

			// m1 := &InputStickerSet{}
			// _ = m1.Decode(d)
			// m.Stickerset = m1
			m.Stickerset, _ = DecodeInputStickerSetClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesInstallStickerSet <--
type TLMessagesInstallStickerSet struct {
	ClazzID    uint32               `json:"_id"`
	Stickerset InputStickerSetClazz `json:"stickerset"`
	Archived   BoolClazz            `json:"archived"`
}

func (m *TLMessagesInstallStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesInstallStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc78fe460: func() error {
			x.PutClazzID(0xc78fe460)

			_ = m.Stickerset.Encode(x, layer)
			_ = m.Archived.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_installStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_installStickerSet, layer)
	}
}

// Decode <--
func (m *TLMessagesInstallStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc78fe460: func() (err error) {

			// m1 := &InputStickerSet{}
			// _ = m1.Decode(d)
			// m.Stickerset = m1
			m.Stickerset, _ = DecodeInputStickerSetClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Archived = m2
			m.Archived, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUninstallStickerSet <--
type TLMessagesUninstallStickerSet struct {
	ClazzID    uint32               `json:"_id"`
	Stickerset InputStickerSetClazz `json:"stickerset"`
}

func (m *TLMessagesUninstallStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUninstallStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf96e55de: func() error {
			x.PutClazzID(0xf96e55de)

			_ = m.Stickerset.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_uninstallStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_uninstallStickerSet, layer)
	}
}

// Decode <--
func (m *TLMessagesUninstallStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf96e55de: func() (err error) {

			// m1 := &InputStickerSet{}
			// _ = m1.Decode(d)
			// m.Stickerset = m1
			m.Stickerset, _ = DecodeInputStickerSetClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesStartBot <--
type TLMessagesStartBot struct {
	ClazzID    uint32         `json:"_id"`
	Bot        InputUserClazz `json:"bot"`
	Peer       InputPeerClazz `json:"peer"`
	RandomId   int64          `json:"random_id"`
	StartParam string         `json:"start_param"`
}

func (m *TLMessagesStartBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesStartBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe6df7378: func() error {
			x.PutClazzID(0xe6df7378)

			_ = m.Bot.Encode(x, layer)
			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.RandomId)
			x.PutString(m.StartParam)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_startBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_startBot, layer)
	}
}

// Decode <--
func (m *TLMessagesStartBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe6df7378: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.RandomId, err = d.Int64()
			m.StartParam, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessagesViews <--
type TLMessagesGetMessagesViews struct {
	ClazzID   uint32         `json:"_id"`
	Peer      InputPeerClazz `json:"peer"`
	Id        []int32        `json:"id"`
	Increment BoolClazz      `json:"increment"`
}

func (m *TLMessagesGetMessagesViews) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessagesViews) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5784d3e1: func() error {
			x.PutClazzID(0x5784d3e1)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			_ = m.Increment.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessagesViews, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessagesViews, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessagesViews) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5784d3e1: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			// m3 := &Bool{}
			// _ = m3.Decode(d)
			// m.Increment = m3
			m.Increment, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditChatAdmin <--
type TLMessagesEditChatAdmin struct {
	ClazzID uint32         `json:"_id"`
	ChatId  int64          `json:"chat_id"`
	UserId  InputUserClazz `json:"user_id"`
	IsAdmin BoolClazz      `json:"is_admin"`
}

func (m *TLMessagesEditChatAdmin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditChatAdmin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa85bd1c2: func() error {
			x.PutClazzID(0xa85bd1c2)

			x.PutInt64(m.ChatId)
			_ = m.UserId.Encode(x, layer)
			_ = m.IsAdmin.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editChatAdmin, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editChatAdmin, layer)
	}
}

// Decode <--
func (m *TLMessagesEditChatAdmin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa85bd1c2: func() (err error) {
			m.ChatId, err = d.Int64()

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.UserId = m2
			m.UserId, _ = DecodeInputUserClazz(d)

			// m3 := &Bool{}
			// _ = m3.Decode(d)
			// m.IsAdmin = m3
			m.IsAdmin, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesMigrateChat <--
type TLMessagesMigrateChat struct {
	ClazzID uint32 `json:"_id"`
	ChatId  int64  `json:"chat_id"`
}

func (m *TLMessagesMigrateChat) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesMigrateChat) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa2875319: func() error {
			x.PutClazzID(0xa2875319)

			x.PutInt64(m.ChatId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_migrateChat, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_migrateChat, layer)
	}
}

// Decode <--
func (m *TLMessagesMigrateChat) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa2875319: func() (err error) {
			m.ChatId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchGlobal <--
type TLMessagesSearchGlobal struct {
	ClazzID        uint32              `json:"_id"`
	BroadcastsOnly bool                `json:"broadcasts_only"`
	GroupsOnly     bool                `json:"groups_only"`
	UsersOnly      bool                `json:"users_only"`
	FolderId       *int32              `json:"folder_id"`
	Q              string              `json:"q"`
	Filter         MessagesFilterClazz `json:"filter"`
	MinDate        int32               `json:"min_date"`
	MaxDate        int32               `json:"max_date"`
	OffsetRate     int32               `json:"offset_rate"`
	OffsetPeer     InputPeerClazz      `json:"offset_peer"`
	OffsetId       int32               `json:"offset_id"`
	Limit          int32               `json:"limit"`
}

func (m *TLMessagesSearchGlobal) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchGlobal) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4bc6589a: func() error {
			x.PutClazzID(0x4bc6589a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.BroadcastsOnly == true {
					flags |= 1 << 1
				}
				if m.GroupsOnly == true {
					flags |= 1 << 2
				}
				if m.UsersOnly == true {
					flags |= 1 << 3
				}
				if m.FolderId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.FolderId != nil {
				x.PutInt32(*m.FolderId)
			}

			x.PutString(m.Q)
			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.MinDate)
			x.PutInt32(m.MaxDate)
			x.PutInt32(m.OffsetRate)
			_ = m.OffsetPeer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchGlobal, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchGlobal, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchGlobal) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4bc6589a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.BroadcastsOnly = true
			}
			if (flags & (1 << 2)) != 0 {
				m.GroupsOnly = true
			}
			if (flags & (1 << 3)) != 0 {
				m.UsersOnly = true
			}
			if (flags & (1 << 0)) != 0 {
				m.FolderId = new(int32)
				*m.FolderId, err = d.Int32()
			}
			m.Q, err = d.String()

			// m7 := &MessagesFilter{}
			// _ = m7.Decode(d)
			// m.Filter = m7
			m.Filter, _ = DecodeMessagesFilterClazz(d)

			m.MinDate, err = d.Int32()
			m.MaxDate, err = d.Int32()
			m.OffsetRate, err = d.Int32()

			// m11 := &InputPeer{}
			// _ = m11.Decode(d)
			// m.OffsetPeer = m11
			m.OffsetPeer, _ = DecodeInputPeerClazz(d)

			m.OffsetId, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReorderStickerSets <--
type TLMessagesReorderStickerSets struct {
	ClazzID uint32  `json:"_id"`
	Masks   bool    `json:"masks"`
	Emojis  bool    `json:"emojis"`
	Order   []int64 `json:"order"`
}

func (m *TLMessagesReorderStickerSets) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReorderStickerSets) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x78337739: func() error {
			x.PutClazzID(0x78337739)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Masks == true {
					flags |= 1 << 0
				}
				if m.Emojis == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			iface.EncodeInt64List(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reorderStickerSets, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reorderStickerSets, layer)
	}
}

// Decode <--
func (m *TLMessagesReorderStickerSets) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x78337739: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Masks = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Emojis = true
			}

			m.Order, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDocumentByHash <--
type TLMessagesGetDocumentByHash struct {
	ClazzID  uint32 `json:"_id"`
	Sha256   []byte `json:"sha256"`
	Size2    int64  `json:"size2"`
	MimeType string `json:"mime_type"`
}

func (m *TLMessagesGetDocumentByHash) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDocumentByHash) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb1f2061f: func() error {
			x.PutClazzID(0xb1f2061f)

			x.PutBytes(m.Sha256)
			x.PutInt64(m.Size2)
			x.PutString(m.MimeType)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDocumentByHash, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDocumentByHash, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDocumentByHash) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb1f2061f: func() (err error) {
			m.Sha256, err = d.Bytes()
			m.Size2, err = d.Int64()
			m.MimeType, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSavedGifs <--
type TLMessagesGetSavedGifs struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetSavedGifs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSavedGifs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5cf09635: func() error {
			x.PutClazzID(0x5cf09635)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSavedGifs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSavedGifs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSavedGifs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5cf09635: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSaveGif <--
type TLMessagesSaveGif struct {
	ClazzID uint32             `json:"_id"`
	Id      InputDocumentClazz `json:"id"`
	Unsave  BoolClazz          `json:"unsave"`
}

func (m *TLMessagesSaveGif) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSaveGif) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x327a30cb: func() error {
			x.PutClazzID(0x327a30cb)

			_ = m.Id.Encode(x, layer)
			_ = m.Unsave.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_saveGif, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_saveGif, layer)
	}
}

// Decode <--
func (m *TLMessagesSaveGif) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x327a30cb: func() (err error) {

			// m1 := &InputDocument{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputDocumentClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Unsave = m2
			m.Unsave, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetInlineBotResults <--
type TLMessagesGetInlineBotResults struct {
	ClazzID  uint32             `json:"_id"`
	Bot      InputUserClazz     `json:"bot"`
	Peer     InputPeerClazz     `json:"peer"`
	GeoPoint InputGeoPointClazz `json:"geo_point"`
	Query    string             `json:"query"`
	Offset   string             `json:"offset"`
}

func (m *TLMessagesGetInlineBotResults) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetInlineBotResults) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x514e999d: func() error {
			x.PutClazzID(0x514e999d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.GeoPoint != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Bot.Encode(x, layer)
			_ = m.Peer.Encode(x, layer)
			if m.GeoPoint != nil {
				_ = m.GeoPoint.Encode(x, layer)
			}

			x.PutString(m.Query)
			x.PutString(m.Offset)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getInlineBotResults, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getInlineBotResults, layer)
	}
}

// Decode <--
func (m *TLMessagesGetInlineBotResults) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x514e999d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.Bot = m2
			m.Bot, _ = DecodeInputUserClazz(d)

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m4 := &InputGeoPoint{}
				// _ = m4.Decode(d)
				// m.GeoPoint = m4
				m.GeoPoint, _ = DecodeInputGeoPointClazz(d)
			}
			m.Query, err = d.String()
			m.Offset, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetInlineBotResults <--
type TLMessagesSetInlineBotResults struct {
	ClazzID       uint32                      `json:"_id"`
	Gallery       bool                        `json:"gallery"`
	Private       bool                        `json:"private"`
	QueryId       int64                       `json:"query_id"`
	Results       []InputBotInlineResultClazz `json:"results"`
	CacheTime     int32                       `json:"cache_time"`
	NextOffset    *string                     `json:"next_offset"`
	SwitchPm      InlineBotSwitchPMClazz      `json:"switch_pm"`
	SwitchWebview InlineBotWebViewClazz       `json:"switch_webview"`
}

func (m *TLMessagesSetInlineBotResults) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetInlineBotResults) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbb12a419: func() error {
			x.PutClazzID(0xbb12a419)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Gallery == true {
					flags |= 1 << 0
				}
				if m.Private == true {
					flags |= 1 << 1
				}

				if m.NextOffset != nil {
					flags |= 1 << 2
				}
				if m.SwitchPm != nil {
					flags |= 1 << 3
				}
				if m.SwitchWebview != nil {
					flags |= 1 << 4
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.QueryId)

			_ = iface.EncodeObjectList(x, m.Results, layer)

			x.PutInt32(m.CacheTime)
			if m.NextOffset != nil {
				x.PutString(*m.NextOffset)
			}

			if m.SwitchPm != nil {
				_ = m.SwitchPm.Encode(x, layer)
			}

			if m.SwitchWebview != nil {
				_ = m.SwitchWebview.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setInlineBotResults, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setInlineBotResults, layer)
	}
}

// Decode <--
func (m *TLMessagesSetInlineBotResults) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbb12a419: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Gallery = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Private = true
			}
			m.QueryId, err = d.Int64()
			c5, err2 := d.ClazzID()
			if c5 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
				return err2
			}
			l5, err3 := d.Int()
			// v5 := make([]*InputBotInlineResult, l5)
			v5 := make([]InputBotInlineResultClazz, l5)
			for i := 0; i < l5; i++ {
				// vv := new(InputBotInlineResult)
				// err3 = vv.Decode(d)
				// _ = err3
				// v5[i] = vv
				v5[i], _ = DecodeInputBotInlineResultClazz(d)
				_ = err3
			}
			m.Results = v5

			m.CacheTime, err = d.Int32()
			if (flags & (1 << 2)) != 0 {
				m.NextOffset = new(string)
				*m.NextOffset, err = d.String()
			}

			if (flags & (1 << 3)) != 0 {
				// m8 := &InlineBotSwitchPM{}
				// _ = m8.Decode(d)
				// m.SwitchPm = m8
				m.SwitchPm, _ = DecodeInlineBotSwitchPMClazz(d)
			}
			if (flags & (1 << 4)) != 0 {
				// m9 := &InlineBotWebView{}
				// _ = m9.Decode(d)
				// m.SwitchWebview = m9
				m.SwitchWebview, _ = DecodeInlineBotWebViewClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendInlineBotResult <--
type TLMessagesSendInlineBotResult struct {
	ClazzID            uint32                       `json:"_id"`
	Silent             bool                         `json:"silent"`
	Background         bool                         `json:"background"`
	ClearDraft         bool                         `json:"clear_draft"`
	HideVia            bool                         `json:"hide_via"`
	Peer               InputPeerClazz               `json:"peer"`
	ReplyTo            InputReplyToClazz            `json:"reply_to"`
	RandomId           int64                        `json:"random_id"`
	QueryId            int64                        `json:"query_id"`
	Id                 string                       `json:"id"`
	ScheduleDate       *int32                       `json:"schedule_date"`
	SendAs             InputPeerClazz               `json:"send_as"`
	QuickReplyShortcut InputQuickReplyShortcutClazz `json:"quick_reply_shortcut"`
	AllowPaidStars     *int64                       `json:"allow_paid_stars"`
}

func (m *TLMessagesSendInlineBotResult) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendInlineBotResult) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc0cf7646: func() error {
			x.PutClazzID(0xc0cf7646)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.HideVia == true {
					flags |= 1 << 11
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.AllowPaidStars != nil {
					flags |= 1 << 21
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			x.PutInt64(m.RandomId)
			x.PutInt64(m.QueryId)
			x.PutString(m.Id)
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendInlineBotResult, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendInlineBotResult, layer)
	}
}

// Decode <--
func (m *TLMessagesSendInlineBotResult) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc0cf7646: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 11)) != 0 {
				m.HideVia = true
			}

			// m6 := &InputPeer{}
			// _ = m6.Decode(d)
			// m.Peer = m6
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m7 := &InputReplyTo{}
				// _ = m7.Decode(d)
				// m.ReplyTo = m7
				m.ReplyTo, _ = DecodeInputReplyToClazz(d)
			}
			m.RandomId, err = d.Int64()
			m.QueryId, err = d.Int64()
			m.Id, err = d.String()
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				// m12 := &InputPeer{}
				// _ = m12.Decode(d)
				// m.SendAs = m12
				m.SendAs, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 17)) != 0 {
				// m13 := &InputQuickReplyShortcut{}
				// _ = m13.Decode(d)
				// m.QuickReplyShortcut = m13
				m.QuickReplyShortcut, _ = DecodeInputQuickReplyShortcutClazz(d)
			}
			if (flags & (1 << 21)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessageEditData <--
type TLMessagesGetMessageEditData struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      int32          `json:"id"`
}

func (m *TLMessagesGetMessageEditData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessageEditData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfda68d36: func() error {
			x.PutClazzID(0xfda68d36)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessageEditData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessageEditData, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessageEditData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfda68d36: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditMessage <--
type TLMessagesEditMessage struct {
	ClazzID              uint32               `json:"_id"`
	NoWebpage            bool                 `json:"no_webpage"`
	InvertMedia          bool                 `json:"invert_media"`
	Peer                 InputPeerClazz       `json:"peer"`
	Id                   int32                `json:"id"`
	Message              *string              `json:"message"`
	Media                InputMediaClazz      `json:"media"`
	ReplyMarkup          ReplyMarkupClazz     `json:"reply_markup"`
	Entities             []MessageEntityClazz `json:"entities"`
	ScheduleDate         *int32               `json:"schedule_date"`
	QuickReplyShortcutId *int32               `json:"quick_reply_shortcut_id"`
}

func (m *TLMessagesEditMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdfd14005: func() error {
			x.PutClazzID(0xdfd14005)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoWebpage == true {
					flags |= 1 << 1
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}

				if m.Message != nil {
					flags |= 1 << 11
				}
				if m.Media != nil {
					flags |= 1 << 14
				}
				if m.ReplyMarkup != nil {
					flags |= 1 << 2
				}
				if m.Entities != nil {
					flags |= 1 << 3
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 15
				}
				if m.QuickReplyShortcutId != nil {
					flags |= 1 << 17
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			if m.Message != nil {
				x.PutString(*m.Message)
			}

			if m.Media != nil {
				_ = m.Media.Encode(x, layer)
			}

			if m.ReplyMarkup != nil {
				_ = m.ReplyMarkup.Encode(x, layer)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.QuickReplyShortcutId != nil {
				x.PutInt32(*m.QuickReplyShortcutId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesEditMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdfd14005: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.NoWebpage = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()
			if (flags & (1 << 11)) != 0 {
				m.Message = new(string)
				*m.Message, err = d.String()
			}

			if (flags & (1 << 14)) != 0 {
				// m7 := &InputMedia{}
				// _ = m7.Decode(d)
				// m.Media = m7
				m.Media, _ = DecodeInputMediaClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				// m8 := &ReplyMarkup{}
				// _ = m8.Decode(d)
				// m.ReplyMarkup = m8
				m.ReplyMarkup, _ = DecodeReplyMarkupClazz(d)
			}
			if (flags & (1 << 3)) != 0 {
				c9, err2 := d.ClazzID()
				if c9 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 9, c9)
					return err2
				}
				l9, err3 := d.Int()
				// v9 := make([]*MessageEntity, l9)
				v9 := make([]MessageEntityClazz, l9)
				for i := 0; i < l9; i++ {
					// vv := new(MessageEntity)
					// err3 = vv.Decode(d)
					// _ = err3
					// v9[i] = vv
					v9[i], _ = DecodeMessageEntityClazz(d)
					_ = err3
				}
				m.Entities = v9
			}
			if (flags & (1 << 15)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 17)) != 0 {
				m.QuickReplyShortcutId = new(int32)
				*m.QuickReplyShortcutId, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditInlineBotMessage <--
type TLMessagesEditInlineBotMessage struct {
	ClazzID     uint32                       `json:"_id"`
	NoWebpage   bool                         `json:"no_webpage"`
	InvertMedia bool                         `json:"invert_media"`
	Id          InputBotInlineMessageIDClazz `json:"id"`
	Message     *string                      `json:"message"`
	Media       InputMediaClazz              `json:"media"`
	ReplyMarkup ReplyMarkupClazz             `json:"reply_markup"`
	Entities    []MessageEntityClazz         `json:"entities"`
}

func (m *TLMessagesEditInlineBotMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditInlineBotMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x83557dba: func() error {
			x.PutClazzID(0x83557dba)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoWebpage == true {
					flags |= 1 << 1
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}

				if m.Message != nil {
					flags |= 1 << 11
				}
				if m.Media != nil {
					flags |= 1 << 14
				}
				if m.ReplyMarkup != nil {
					flags |= 1 << 2
				}
				if m.Entities != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)
			if m.Message != nil {
				x.PutString(*m.Message)
			}

			if m.Media != nil {
				_ = m.Media.Encode(x, layer)
			}

			if m.ReplyMarkup != nil {
				_ = m.ReplyMarkup.Encode(x, layer)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editInlineBotMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editInlineBotMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesEditInlineBotMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x83557dba: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.NoWebpage = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}

			// m4 := &InputBotInlineMessageID{}
			// _ = m4.Decode(d)
			// m.Id = m4
			m.Id, _ = DecodeInputBotInlineMessageIDClazz(d)

			if (flags & (1 << 11)) != 0 {
				m.Message = new(string)
				*m.Message, err = d.String()
			}

			if (flags & (1 << 14)) != 0 {
				// m6 := &InputMedia{}
				// _ = m6.Decode(d)
				// m.Media = m6
				m.Media, _ = DecodeInputMediaClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				// m7 := &ReplyMarkup{}
				// _ = m7.Decode(d)
				// m.ReplyMarkup = m7
				m.ReplyMarkup, _ = DecodeReplyMarkupClazz(d)
			}
			if (flags & (1 << 3)) != 0 {
				c8, err2 := d.ClazzID()
				if c8 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 8, c8)
					return err2
				}
				l8, err3 := d.Int()
				// v8 := make([]*MessageEntity, l8)
				v8 := make([]MessageEntityClazz, l8)
				for i := 0; i < l8; i++ {
					// vv := new(MessageEntity)
					// err3 = vv.Decode(d)
					// _ = err3
					// v8[i] = vv
					v8[i], _ = DecodeMessageEntityClazz(d)
					_ = err3
				}
				m.Entities = v8
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetBotCallbackAnswer <--
type TLMessagesGetBotCallbackAnswer struct {
	ClazzID  uint32                     `json:"_id"`
	Game     bool                       `json:"game"`
	Peer     InputPeerClazz             `json:"peer"`
	MsgId    int32                      `json:"msg_id"`
	Data     []byte                     `json:"data"`
	Password InputCheckPasswordSRPClazz `json:"password"`
}

func (m *TLMessagesGetBotCallbackAnswer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetBotCallbackAnswer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9342ca07: func() error {
			x.PutClazzID(0x9342ca07)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Game == true {
					flags |= 1 << 1
				}

				if m.Data != nil {
					flags |= 1 << 0
				}
				if m.Password != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			if m.Data != nil {
				x.PutBytes(m.Data)
			}

			if m.Password != nil {
				_ = m.Password.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getBotCallbackAnswer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getBotCallbackAnswer, layer)
	}
}

// Decode <--
func (m *TLMessagesGetBotCallbackAnswer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9342ca07: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Game = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Data, err = d.Bytes()
			}

			if (flags & (1 << 2)) != 0 {
				// m6 := &InputCheckPasswordSRP{}
				// _ = m6.Decode(d)
				// m.Password = m6
				m.Password, _ = DecodeInputCheckPasswordSRPClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetBotCallbackAnswer <--
type TLMessagesSetBotCallbackAnswer struct {
	ClazzID   uint32  `json:"_id"`
	Alert     bool    `json:"alert"`
	QueryId   int64   `json:"query_id"`
	Message   *string `json:"message"`
	Url       *string `json:"url"`
	CacheTime int32   `json:"cache_time"`
}

func (m *TLMessagesSetBotCallbackAnswer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetBotCallbackAnswer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd58f130a: func() error {
			x.PutClazzID(0xd58f130a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Alert == true {
					flags |= 1 << 1
				}

				if m.Message != nil {
					flags |= 1 << 0
				}
				if m.Url != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.QueryId)
			if m.Message != nil {
				x.PutString(*m.Message)
			}

			if m.Url != nil {
				x.PutString(*m.Url)
			}

			x.PutInt32(m.CacheTime)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setBotCallbackAnswer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setBotCallbackAnswer, layer)
	}
}

// Decode <--
func (m *TLMessagesSetBotCallbackAnswer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd58f130a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Alert = true
			}
			m.QueryId, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m.Message = new(string)
				*m.Message, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.Url = new(string)
				*m.Url, err = d.String()
			}

			m.CacheTime, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPeerDialogs <--
type TLMessagesGetPeerDialogs struct {
	ClazzID uint32                 `json:"_id"`
	Peers   []InputDialogPeerClazz `json:"peers"`
}

func (m *TLMessagesGetPeerDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPeerDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe470bcfd: func() error {
			x.PutClazzID(0xe470bcfd)

			_ = iface.EncodeObjectList(x, m.Peers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPeerDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPeerDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPeerDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe470bcfd: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputDialogPeer, l1)
			v1 := make([]InputDialogPeerClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputDialogPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputDialogPeerClazz(d)
				_ = err3
			}
			m.Peers = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSaveDraft <--
type TLMessagesSaveDraft struct {
	ClazzID       uint32               `json:"_id"`
	NoWebpage     bool                 `json:"no_webpage"`
	InvertMedia   bool                 `json:"invert_media"`
	ReplyTo       InputReplyToClazz    `json:"reply_to"`
	Peer          InputPeerClazz       `json:"peer"`
	Message       string               `json:"message"`
	Entities      []MessageEntityClazz `json:"entities"`
	Media         InputMediaClazz      `json:"media"`
	Effect        *int64               `json:"effect"`
	SuggestedPost SuggestedPostClazz   `json:"suggested_post"`
}

func (m *TLMessagesSaveDraft) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSaveDraft) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x54ae308e: func() error {
			x.PutClazzID(0x54ae308e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoWebpage == true {
					flags |= 1 << 1
				}
				if m.InvertMedia == true {
					flags |= 1 << 6
				}
				if m.ReplyTo != nil {
					flags |= 1 << 4
				}

				if m.Entities != nil {
					flags |= 1 << 3
				}
				if m.Media != nil {
					flags |= 1 << 5
				}
				if m.Effect != nil {
					flags |= 1 << 7
				}
				if m.SuggestedPost != nil {
					flags |= 1 << 8
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Message)
			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.Media != nil {
				_ = m.Media.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			if m.SuggestedPost != nil {
				_ = m.SuggestedPost.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_saveDraft, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_saveDraft, layer)
	}
}

// Decode <--
func (m *TLMessagesSaveDraft) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x54ae308e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.NoWebpage = true
			}
			if (flags & (1 << 6)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 4)) != 0 {
				// m4 := &InputReplyTo{}
				// _ = m4.Decode(d)
				// m.ReplyTo = m4
				m.ReplyTo, _ = DecodeInputReplyToClazz(d)
			}

			// m5 := &InputPeer{}
			// _ = m5.Decode(d)
			// m.Peer = m5
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Message, err = d.String()
			if (flags & (1 << 3)) != 0 {
				c7, err2 := d.ClazzID()
				if c7 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 7, c7)
					return err2
				}
				l7, err3 := d.Int()
				// v7 := make([]*MessageEntity, l7)
				v7 := make([]MessageEntityClazz, l7)
				for i := 0; i < l7; i++ {
					// vv := new(MessageEntity)
					// err3 = vv.Decode(d)
					// _ = err3
					// v7[i] = vv
					v7[i], _ = DecodeMessageEntityClazz(d)
					_ = err3
				}
				m.Entities = v7
			}
			if (flags & (1 << 5)) != 0 {
				// m8 := &InputMedia{}
				// _ = m8.Decode(d)
				// m.Media = m8
				m.Media, _ = DecodeInputMediaClazz(d)
			}
			if (flags & (1 << 7)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			if (flags & (1 << 8)) != 0 {
				// m10 := &SuggestedPost{}
				// _ = m10.Decode(d)
				// m.SuggestedPost = m10
				m.SuggestedPost, _ = DecodeSuggestedPostClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAllDrafts <--
type TLMessagesGetAllDrafts struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetAllDrafts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAllDrafts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6a3f8d65: func() error {
			x.PutClazzID(0x6a3f8d65)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAllDrafts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAllDrafts, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAllDrafts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6a3f8d65: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetFeaturedStickers <--
type TLMessagesGetFeaturedStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetFeaturedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetFeaturedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x64780b14: func() error {
			x.PutClazzID(0x64780b14)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getFeaturedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getFeaturedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetFeaturedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x64780b14: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadFeaturedStickers <--
type TLMessagesReadFeaturedStickers struct {
	ClazzID uint32  `json:"_id"`
	Id      []int64 `json:"id"`
}

func (m *TLMessagesReadFeaturedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadFeaturedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5b118126: func() error {
			x.PutClazzID(0x5b118126)

			iface.EncodeInt64List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readFeaturedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readFeaturedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesReadFeaturedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5b118126: func() (err error) {

			m.Id, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetRecentStickers <--
type TLMessagesGetRecentStickers struct {
	ClazzID  uint32 `json:"_id"`
	Attached bool   `json:"attached"`
	Hash     int64  `json:"hash"`
}

func (m *TLMessagesGetRecentStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetRecentStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9da9403b: func() error {
			x.PutClazzID(0x9da9403b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Attached == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getRecentStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getRecentStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetRecentStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9da9403b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Attached = true
			}
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSaveRecentSticker <--
type TLMessagesSaveRecentSticker struct {
	ClazzID  uint32             `json:"_id"`
	Attached bool               `json:"attached"`
	Id       InputDocumentClazz `json:"id"`
	Unsave   BoolClazz          `json:"unsave"`
}

func (m *TLMessagesSaveRecentSticker) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSaveRecentSticker) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x392718f8: func() error {
			x.PutClazzID(0x392718f8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Attached == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)
			_ = m.Unsave.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_saveRecentSticker, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_saveRecentSticker, layer)
	}
}

// Decode <--
func (m *TLMessagesSaveRecentSticker) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x392718f8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Attached = true
			}

			// m3 := &InputDocument{}
			// _ = m3.Decode(d)
			// m.Id = m3
			m.Id, _ = DecodeInputDocumentClazz(d)

			// m4 := &Bool{}
			// _ = m4.Decode(d)
			// m.Unsave = m4
			m.Unsave, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesClearRecentStickers <--
type TLMessagesClearRecentStickers struct {
	ClazzID  uint32 `json:"_id"`
	Attached bool   `json:"attached"`
}

func (m *TLMessagesClearRecentStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesClearRecentStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8999602d: func() error {
			x.PutClazzID(0x8999602d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Attached == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_clearRecentStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_clearRecentStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesClearRecentStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8999602d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Attached = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetArchivedStickers <--
type TLMessagesGetArchivedStickers struct {
	ClazzID  uint32 `json:"_id"`
	Masks    bool   `json:"masks"`
	Emojis   bool   `json:"emojis"`
	OffsetId int64  `json:"offset_id"`
	Limit    int32  `json:"limit"`
}

func (m *TLMessagesGetArchivedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetArchivedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x57f17692: func() error {
			x.PutClazzID(0x57f17692)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Masks == true {
					flags |= 1 << 0
				}
				if m.Emojis == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getArchivedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getArchivedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetArchivedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x57f17692: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Masks = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Emojis = true
			}
			m.OffsetId, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMaskStickers <--
type TLMessagesGetMaskStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetMaskStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMaskStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x640f82b8: func() error {
			x.PutClazzID(0x640f82b8)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMaskStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMaskStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMaskStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x640f82b8: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAttachedStickers <--
type TLMessagesGetAttachedStickers struct {
	ClazzID uint32                   `json:"_id"`
	Media   InputStickeredMediaClazz `json:"media"`
}

func (m *TLMessagesGetAttachedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAttachedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcc5b67cc: func() error {
			x.PutClazzID(0xcc5b67cc)

			_ = m.Media.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAttachedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAttachedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAttachedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcc5b67cc: func() (err error) {

			// m1 := &InputStickeredMedia{}
			// _ = m1.Decode(d)
			// m.Media = m1
			m.Media, _ = DecodeInputStickeredMediaClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetGameScore <--
type TLMessagesSetGameScore struct {
	ClazzID     uint32         `json:"_id"`
	EditMessage bool           `json:"edit_message"`
	Force       bool           `json:"force"`
	Peer        InputPeerClazz `json:"peer"`
	Id          int32          `json:"id"`
	UserId      InputUserClazz `json:"user_id"`
	Score       int32          `json:"score"`
}

func (m *TLMessagesSetGameScore) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetGameScore) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8ef8ecc0: func() error {
			x.PutClazzID(0x8ef8ecc0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.EditMessage == true {
					flags |= 1 << 0
				}
				if m.Force == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.Score)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setGameScore, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setGameScore, layer)
	}
}

// Decode <--
func (m *TLMessagesSetGameScore) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8ef8ecc0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.EditMessage = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Force = true
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()

			// m6 := &InputUser{}
			// _ = m6.Decode(d)
			// m.UserId = m6
			m.UserId, _ = DecodeInputUserClazz(d)

			m.Score, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetInlineGameScore <--
type TLMessagesSetInlineGameScore struct {
	ClazzID     uint32                       `json:"_id"`
	EditMessage bool                         `json:"edit_message"`
	Force       bool                         `json:"force"`
	Id          InputBotInlineMessageIDClazz `json:"id"`
	UserId      InputUserClazz               `json:"user_id"`
	Score       int32                        `json:"score"`
}

func (m *TLMessagesSetInlineGameScore) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetInlineGameScore) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x15ad9f64: func() error {
			x.PutClazzID(0x15ad9f64)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.EditMessage == true {
					flags |= 1 << 0
				}
				if m.Force == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.Score)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setInlineGameScore, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setInlineGameScore, layer)
	}
}

// Decode <--
func (m *TLMessagesSetInlineGameScore) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x15ad9f64: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.EditMessage = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Force = true
			}

			// m4 := &InputBotInlineMessageID{}
			// _ = m4.Decode(d)
			// m.Id = m4
			m.Id, _ = DecodeInputBotInlineMessageIDClazz(d)

			// m5 := &InputUser{}
			// _ = m5.Decode(d)
			// m.UserId = m5
			m.UserId, _ = DecodeInputUserClazz(d)

			m.Score, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetGameHighScores <--
type TLMessagesGetGameHighScores struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      int32          `json:"id"`
	UserId  InputUserClazz `json:"user_id"`
}

func (m *TLMessagesGetGameHighScores) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetGameHighScores) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe822649d: func() error {
			x.PutClazzID(0xe822649d)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getGameHighScores, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getGameHighScores, layer)
	}
}

// Decode <--
func (m *TLMessagesGetGameHighScores) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe822649d: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()

			// m3 := &InputUser{}
			// _ = m3.Decode(d)
			// m.UserId = m3
			m.UserId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetInlineGameHighScores <--
type TLMessagesGetInlineGameHighScores struct {
	ClazzID uint32                       `json:"_id"`
	Id      InputBotInlineMessageIDClazz `json:"id"`
	UserId  InputUserClazz               `json:"user_id"`
}

func (m *TLMessagesGetInlineGameHighScores) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetInlineGameHighScores) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf635e1b: func() error {
			x.PutClazzID(0xf635e1b)

			_ = m.Id.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getInlineGameHighScores, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getInlineGameHighScores, layer)
	}
}

// Decode <--
func (m *TLMessagesGetInlineGameHighScores) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf635e1b: func() (err error) {

			// m1 := &InputBotInlineMessageID{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputBotInlineMessageIDClazz(d)

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.UserId = m2
			m.UserId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetCommonChats <--
type TLMessagesGetCommonChats struct {
	ClazzID uint32         `json:"_id"`
	UserId  InputUserClazz `json:"user_id"`
	MaxId   int64          `json:"max_id"`
	Limit   int32          `json:"limit"`
}

func (m *TLMessagesGetCommonChats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetCommonChats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe40ca104: func() error {
			x.PutClazzID(0xe40ca104)

			_ = m.UserId.Encode(x, layer)
			x.PutInt64(m.MaxId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getCommonChats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getCommonChats, layer)
	}
}

// Decode <--
func (m *TLMessagesGetCommonChats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe40ca104: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.UserId = m1
			m.UserId, _ = DecodeInputUserClazz(d)

			m.MaxId, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetWebPage <--
type TLMessagesGetWebPage struct {
	ClazzID uint32 `json:"_id"`
	Url     string `json:"url"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetWebPage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetWebPage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8d9692a3: func() error {
			x.PutClazzID(0x8d9692a3)

			x.PutString(m.Url)
			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getWebPage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getWebPage, layer)
	}
}

// Decode <--
func (m *TLMessagesGetWebPage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8d9692a3: func() (err error) {
			m.Url, err = d.String()
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleDialogPin <--
type TLMessagesToggleDialogPin struct {
	ClazzID uint32               `json:"_id"`
	Pinned  bool                 `json:"pinned"`
	Peer    InputDialogPeerClazz `json:"peer"`
}

func (m *TLMessagesToggleDialogPin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleDialogPin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa731e257: func() error {
			x.PutClazzID(0xa731e257)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Pinned == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleDialogPin, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleDialogPin, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleDialogPin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa731e257: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Pinned = true
			}

			// m3 := &InputDialogPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputDialogPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReorderPinnedDialogs <--
type TLMessagesReorderPinnedDialogs struct {
	ClazzID  uint32                 `json:"_id"`
	Force    bool                   `json:"force"`
	FolderId int32                  `json:"folder_id"`
	Order    []InputDialogPeerClazz `json:"order"`
}

func (m *TLMessagesReorderPinnedDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReorderPinnedDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3b1adf37: func() error {
			x.PutClazzID(0x3b1adf37)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Force == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.FolderId)

			_ = iface.EncodeObjectList(x, m.Order, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reorderPinnedDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reorderPinnedDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesReorderPinnedDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3b1adf37: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Force = true
			}
			m.FolderId, err = d.Int32()
			c4, err2 := d.ClazzID()
			if c4 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
				return err2
			}
			l4, err3 := d.Int()
			// v4 := make([]*InputDialogPeer, l4)
			v4 := make([]InputDialogPeerClazz, l4)
			for i := 0; i < l4; i++ {
				// vv := new(InputDialogPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v4[i] = vv
				v4[i], _ = DecodeInputDialogPeerClazz(d)
				_ = err3
			}
			m.Order = v4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPinnedDialogs <--
type TLMessagesGetPinnedDialogs struct {
	ClazzID  uint32 `json:"_id"`
	FolderId int32  `json:"folder_id"`
}

func (m *TLMessagesGetPinnedDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPinnedDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd6b94df2: func() error {
			x.PutClazzID(0xd6b94df2)

			x.PutInt32(m.FolderId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPinnedDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPinnedDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPinnedDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd6b94df2: func() (err error) {
			m.FolderId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetBotShippingResults <--
type TLMessagesSetBotShippingResults struct {
	ClazzID         uint32                `json:"_id"`
	QueryId         int64                 `json:"query_id"`
	Error           *string               `json:"error"`
	ShippingOptions []ShippingOptionClazz `json:"shipping_options"`
}

func (m *TLMessagesSetBotShippingResults) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetBotShippingResults) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe5f672fa: func() error {
			x.PutClazzID(0xe5f672fa)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Error != nil {
					flags |= 1 << 0
				}
				if m.ShippingOptions != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.QueryId)
			if m.Error != nil {
				x.PutString(*m.Error)
			}

			if m.ShippingOptions != nil {
				_ = iface.EncodeObjectList(x, m.ShippingOptions, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setBotShippingResults, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setBotShippingResults, layer)
	}
}

// Decode <--
func (m *TLMessagesSetBotShippingResults) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe5f672fa: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.QueryId, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m.Error = new(string)
				*m.Error, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				c4, err2 := d.ClazzID()
				if c4 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
					return err2
				}
				l4, err3 := d.Int()
				// v4 := make([]*ShippingOption, l4)
				v4 := make([]ShippingOptionClazz, l4)
				for i := 0; i < l4; i++ {
					// vv := new(ShippingOption)
					// err3 = vv.Decode(d)
					// _ = err3
					// v4[i] = vv
					v4[i], _ = DecodeShippingOptionClazz(d)
					_ = err3
				}
				m.ShippingOptions = v4
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetBotPrecheckoutResults <--
type TLMessagesSetBotPrecheckoutResults struct {
	ClazzID uint32  `json:"_id"`
	Success bool    `json:"success"`
	QueryId int64   `json:"query_id"`
	Error   *string `json:"error"`
}

func (m *TLMessagesSetBotPrecheckoutResults) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetBotPrecheckoutResults) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9c2dd95: func() error {
			x.PutClazzID(0x9c2dd95)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Success == true {
					flags |= 1 << 1
				}

				if m.Error != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.QueryId)
			if m.Error != nil {
				x.PutString(*m.Error)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setBotPrecheckoutResults, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setBotPrecheckoutResults, layer)
	}
}

// Decode <--
func (m *TLMessagesSetBotPrecheckoutResults) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9c2dd95: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Success = true
			}
			m.QueryId, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m.Error = new(string)
				*m.Error, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUploadMedia <--
type TLMessagesUploadMedia struct {
	ClazzID              uint32          `json:"_id"`
	BusinessConnectionId *string         `json:"business_connection_id"`
	Peer                 InputPeerClazz  `json:"peer"`
	Media                InputMediaClazz `json:"media"`
}

func (m *TLMessagesUploadMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUploadMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x14967978: func() error {
			x.PutClazzID(0x14967978)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.BusinessConnectionId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.BusinessConnectionId != nil {
				x.PutString(*m.BusinessConnectionId)
			}

			_ = m.Peer.Encode(x, layer)
			_ = m.Media.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_uploadMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_uploadMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesUploadMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x14967978: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.BusinessConnectionId = new(string)
				*m.BusinessConnectionId, err = d.String()
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m4 := &InputMedia{}
			// _ = m4.Decode(d)
			// m.Media = m4
			m.Media, _ = DecodeInputMediaClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendScreenshotNotification <--
type TLMessagesSendScreenshotNotification struct {
	ClazzID  uint32            `json:"_id"`
	Peer     InputPeerClazz    `json:"peer"`
	ReplyTo  InputReplyToClazz `json:"reply_to"`
	RandomId int64             `json:"random_id"`
}

func (m *TLMessagesSendScreenshotNotification) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendScreenshotNotification) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa1405817: func() error {
			x.PutClazzID(0xa1405817)

			_ = m.Peer.Encode(x, layer)
			_ = m.ReplyTo.Encode(x, layer)
			x.PutInt64(m.RandomId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendScreenshotNotification, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendScreenshotNotification, layer)
	}
}

// Decode <--
func (m *TLMessagesSendScreenshotNotification) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa1405817: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputReplyTo{}
			// _ = m2.Decode(d)
			// m.ReplyTo = m2
			m.ReplyTo, _ = DecodeInputReplyToClazz(d)

			m.RandomId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetFavedStickers <--
type TLMessagesGetFavedStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetFavedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetFavedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4f1aaa9: func() error {
			x.PutClazzID(0x4f1aaa9)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getFavedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getFavedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetFavedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4f1aaa9: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesFaveSticker <--
type TLMessagesFaveSticker struct {
	ClazzID uint32             `json:"_id"`
	Id      InputDocumentClazz `json:"id"`
	Unfave  BoolClazz          `json:"unfave"`
}

func (m *TLMessagesFaveSticker) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesFaveSticker) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb9ffc55b: func() error {
			x.PutClazzID(0xb9ffc55b)

			_ = m.Id.Encode(x, layer)
			_ = m.Unfave.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_faveSticker, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_faveSticker, layer)
	}
}

// Decode <--
func (m *TLMessagesFaveSticker) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb9ffc55b: func() (err error) {

			// m1 := &InputDocument{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeInputDocumentClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Unfave = m2
			m.Unfave, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetUnreadMentions <--
type TLMessagesGetUnreadMentions struct {
	ClazzID   uint32         `json:"_id"`
	Peer      InputPeerClazz `json:"peer"`
	TopMsgId  *int32         `json:"top_msg_id"`
	OffsetId  int32          `json:"offset_id"`
	AddOffset int32          `json:"add_offset"`
	Limit     int32          `json:"limit"`
	MaxId     int32          `json:"max_id"`
	MinId     int32          `json:"min_id"`
}

func (m *TLMessagesGetUnreadMentions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetUnreadMentions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf107e790: func() error {
			x.PutClazzID(0xf107e790)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			x.PutInt32(m.OffsetId)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getUnreadMentions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getUnreadMentions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetUnreadMentions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf107e790: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			m.OffsetId, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadMentions <--
type TLMessagesReadMentions struct {
	ClazzID  uint32         `json:"_id"`
	Peer     InputPeerClazz `json:"peer"`
	TopMsgId *int32         `json:"top_msg_id"`
}

func (m *TLMessagesReadMentions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadMentions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x36e5bf4d: func() error {
			x.PutClazzID(0x36e5bf4d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readMentions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readMentions, layer)
	}
}

// Decode <--
func (m *TLMessagesReadMentions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x36e5bf4d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetRecentLocations <--
type TLMessagesGetRecentLocations struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Limit   int32          `json:"limit"`
	Hash    int64          `json:"hash"`
}

func (m *TLMessagesGetRecentLocations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetRecentLocations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x702a40e0: func() error {
			x.PutClazzID(0x702a40e0)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getRecentLocations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getRecentLocations, layer)
	}
}

// Decode <--
func (m *TLMessagesGetRecentLocations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x702a40e0: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendMultiMedia <--
type TLMessagesSendMultiMedia struct {
	ClazzID                uint32                       `json:"_id"`
	Silent                 bool                         `json:"silent"`
	Background             bool                         `json:"background"`
	ClearDraft             bool                         `json:"clear_draft"`
	Noforwards             bool                         `json:"noforwards"`
	UpdateStickersetsOrder bool                         `json:"update_stickersets_order"`
	InvertMedia            bool                         `json:"invert_media"`
	AllowPaidFloodskip     bool                         `json:"allow_paid_floodskip"`
	Peer                   InputPeerClazz               `json:"peer"`
	ReplyTo                InputReplyToClazz            `json:"reply_to"`
	MultiMedia             []InputSingleMediaClazz      `json:"multi_media"`
	ScheduleDate           *int32                       `json:"schedule_date"`
	SendAs                 InputPeerClazz               `json:"send_as"`
	QuickReplyShortcut     InputQuickReplyShortcutClazz `json:"quick_reply_shortcut"`
	Effect                 *int64                       `json:"effect"`
	AllowPaidStars         *int64                       `json:"allow_paid_stars"`
}

func (m *TLMessagesSendMultiMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendMultiMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1bf89d74: func() error {
			x.PutClazzID(0x1bf89d74)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.UpdateStickersetsOrder == true {
					flags |= 1 << 15
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.Effect != nil {
					flags |= 1 << 18
				}
				if m.AllowPaidStars != nil {
					flags |= 1 << 21
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			_ = iface.EncodeObjectList(x, m.MultiMedia, layer)

			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendMultiMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendMultiMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesSendMultiMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1bf89d74: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 15)) != 0 {
				m.UpdateStickersetsOrder = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			// m9 := &InputPeer{}
			// _ = m9.Decode(d)
			// m.Peer = m9
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m10 := &InputReplyTo{}
				// _ = m10.Decode(d)
				// m.ReplyTo = m10
				m.ReplyTo, _ = DecodeInputReplyToClazz(d)
			}
			c11, err2 := d.ClazzID()
			if c11 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 11, c11)
				return err2
			}
			l11, err3 := d.Int()
			// v11 := make([]*InputSingleMedia, l11)
			v11 := make([]InputSingleMediaClazz, l11)
			for i := 0; i < l11; i++ {
				// vv := new(InputSingleMedia)
				// err3 = vv.Decode(d)
				// _ = err3
				// v11[i] = vv
				v11[i], _ = DecodeInputSingleMediaClazz(d)
				_ = err3
			}
			m.MultiMedia = v11

			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				// m13 := &InputPeer{}
				// _ = m13.Decode(d)
				// m.SendAs = m13
				m.SendAs, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 17)) != 0 {
				// m14 := &InputQuickReplyShortcut{}
				// _ = m14.Decode(d)
				// m.QuickReplyShortcut = m14
				m.QuickReplyShortcut, _ = DecodeInputQuickReplyShortcutClazz(d)
			}
			if (flags & (1 << 18)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			if (flags & (1 << 21)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUploadEncryptedFile <--
type TLMessagesUploadEncryptedFile struct {
	ClazzID uint32                  `json:"_id"`
	Peer    InputEncryptedChatClazz `json:"peer"`
	File    InputEncryptedFileClazz `json:"file"`
}

func (m *TLMessagesUploadEncryptedFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUploadEncryptedFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5057c497: func() error {
			x.PutClazzID(0x5057c497)

			_ = m.Peer.Encode(x, layer)
			_ = m.File.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_uploadEncryptedFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_uploadEncryptedFile, layer)
	}
}

// Decode <--
func (m *TLMessagesUploadEncryptedFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5057c497: func() (err error) {

			// m1 := &InputEncryptedChat{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputEncryptedChatClazz(d)

			// m2 := &InputEncryptedFile{}
			// _ = m2.Decode(d)
			// m.File = m2
			m.File, _ = DecodeInputEncryptedFileClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchStickerSets <--
type TLMessagesSearchStickerSets struct {
	ClazzID         uint32 `json:"_id"`
	ExcludeFeatured bool   `json:"exclude_featured"`
	Q               string `json:"q"`
	Hash            int64  `json:"hash"`
}

func (m *TLMessagesSearchStickerSets) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchStickerSets) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x35705b8a: func() error {
			x.PutClazzID(0x35705b8a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ExcludeFeatured == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Q)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchStickerSets, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchStickerSets, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchStickerSets) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x35705b8a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ExcludeFeatured = true
			}
			m.Q, err = d.String()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSplitRanges <--
type TLMessagesGetSplitRanges struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetSplitRanges) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSplitRanges) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1cff7e08: func() error {
			x.PutClazzID(0x1cff7e08)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSplitRanges, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSplitRanges, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSplitRanges) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1cff7e08: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesMarkDialogUnread <--
type TLMessagesMarkDialogUnread struct {
	ClazzID    uint32               `json:"_id"`
	Unread     bool                 `json:"unread"`
	ParentPeer InputPeerClazz       `json:"parent_peer"`
	Peer       InputDialogPeerClazz `json:"peer"`
}

func (m *TLMessagesMarkDialogUnread) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesMarkDialogUnread) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8c5006f8: func() error {
			x.PutClazzID(0x8c5006f8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Unread == true {
					flags |= 1 << 0
				}
				if m.ParentPeer != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.ParentPeer != nil {
				_ = m.ParentPeer.Encode(x, layer)
			}

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_markDialogUnread, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_markDialogUnread, layer)
	}
}

// Decode <--
func (m *TLMessagesMarkDialogUnread) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8c5006f8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Unread = true
			}
			if (flags & (1 << 1)) != 0 {
				// m3 := &InputPeer{}
				// _ = m3.Decode(d)
				// m.ParentPeer = m3
				m.ParentPeer, _ = DecodeInputPeerClazz(d)
			}

			// m4 := &InputDialogPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputDialogPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDialogUnreadMarks <--
type TLMessagesGetDialogUnreadMarks struct {
	ClazzID    uint32         `json:"_id"`
	ParentPeer InputPeerClazz `json:"parent_peer"`
}

func (m *TLMessagesGetDialogUnreadMarks) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDialogUnreadMarks) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x21202222: func() error {
			x.PutClazzID(0x21202222)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ParentPeer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.ParentPeer != nil {
				_ = m.ParentPeer.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDialogUnreadMarks, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDialogUnreadMarks, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDialogUnreadMarks) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x21202222: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputPeer{}
				// _ = m2.Decode(d)
				// m.ParentPeer = m2
				m.ParentPeer, _ = DecodeInputPeerClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesClearAllDrafts <--
type TLMessagesClearAllDrafts struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesClearAllDrafts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesClearAllDrafts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7e58ee9c: func() error {
			x.PutClazzID(0x7e58ee9c)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_clearAllDrafts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_clearAllDrafts, layer)
	}
}

// Decode <--
func (m *TLMessagesClearAllDrafts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7e58ee9c: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUpdatePinnedMessage <--
type TLMessagesUpdatePinnedMessage struct {
	ClazzID   uint32         `json:"_id"`
	Silent    bool           `json:"silent"`
	Unpin     bool           `json:"unpin"`
	PmOneside bool           `json:"pm_oneside"`
	Peer      InputPeerClazz `json:"peer"`
	Id        int32          `json:"id"`
}

func (m *TLMessagesUpdatePinnedMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUpdatePinnedMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd2aaf7ec: func() error {
			x.PutClazzID(0xd2aaf7ec)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 0
				}
				if m.Unpin == true {
					flags |= 1 << 1
				}
				if m.PmOneside == true {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_updatePinnedMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_updatePinnedMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesUpdatePinnedMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd2aaf7ec: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Unpin = true
			}
			if (flags & (1 << 2)) != 0 {
				m.PmOneside = true
			}

			// m5 := &InputPeer{}
			// _ = m5.Decode(d)
			// m.Peer = m5
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendVote <--
type TLMessagesSendVote struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   int32          `json:"msg_id"`
	Options [][]byte       `json:"options"`
}

func (m *TLMessagesSendVote) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendVote) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x10ea6184: func() error {
			x.PutClazzID(0x10ea6184)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			iface.EncodeBytesList(x, m.Options)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendVote, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendVote, layer)
	}
}

// Decode <--
func (m *TLMessagesSendVote) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x10ea6184: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			m.Options, err = iface.DecodeBytesList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPollResults <--
type TLMessagesGetPollResults struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   int32          `json:"msg_id"`
}

func (m *TLMessagesGetPollResults) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPollResults) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x73bb643b: func() error {
			x.PutClazzID(0x73bb643b)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPollResults, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPollResults, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPollResults) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x73bb643b: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetOnlines <--
type TLMessagesGetOnlines struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLMessagesGetOnlines) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetOnlines) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6e2be050: func() error {
			x.PutClazzID(0x6e2be050)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getOnlines, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getOnlines, layer)
	}
}

// Decode <--
func (m *TLMessagesGetOnlines) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6e2be050: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditChatAbout <--
type TLMessagesEditChatAbout struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	About   string         `json:"about"`
}

func (m *TLMessagesEditChatAbout) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditChatAbout) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdef60797: func() error {
			x.PutClazzID(0xdef60797)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.About)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editChatAbout, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editChatAbout, layer)
	}
}

// Decode <--
func (m *TLMessagesEditChatAbout) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdef60797: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.About, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditChatDefaultBannedRights <--
type TLMessagesEditChatDefaultBannedRights struct {
	ClazzID      uint32                `json:"_id"`
	Peer         InputPeerClazz        `json:"peer"`
	BannedRights ChatBannedRightsClazz `json:"banned_rights"`
}

func (m *TLMessagesEditChatDefaultBannedRights) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditChatDefaultBannedRights) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa5866b41: func() error {
			x.PutClazzID(0xa5866b41)

			_ = m.Peer.Encode(x, layer)
			_ = m.BannedRights.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editChatDefaultBannedRights, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editChatDefaultBannedRights, layer)
	}
}

// Decode <--
func (m *TLMessagesEditChatDefaultBannedRights) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa5866b41: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &ChatBannedRights{}
			// _ = m2.Decode(d)
			// m.BannedRights = m2
			m.BannedRights, _ = DecodeChatBannedRightsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiKeywords <--
type TLMessagesGetEmojiKeywords struct {
	ClazzID  uint32 `json:"_id"`
	LangCode string `json:"lang_code"`
}

func (m *TLMessagesGetEmojiKeywords) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiKeywords) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x35a0e062: func() error {
			x.PutClazzID(0x35a0e062)

			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiKeywords, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiKeywords, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiKeywords) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x35a0e062: func() (err error) {
			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiKeywordsDifference <--
type TLMessagesGetEmojiKeywordsDifference struct {
	ClazzID     uint32 `json:"_id"`
	LangCode    string `json:"lang_code"`
	FromVersion int32  `json:"from_version"`
}

func (m *TLMessagesGetEmojiKeywordsDifference) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiKeywordsDifference) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1508b6af: func() error {
			x.PutClazzID(0x1508b6af)

			x.PutString(m.LangCode)
			x.PutInt32(m.FromVersion)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiKeywordsDifference, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiKeywordsDifference, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiKeywordsDifference) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1508b6af: func() (err error) {
			m.LangCode, err = d.String()
			m.FromVersion, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiKeywordsLanguages <--
type TLMessagesGetEmojiKeywordsLanguages struct {
	ClazzID   uint32   `json:"_id"`
	LangCodes []string `json:"lang_codes"`
}

func (m *TLMessagesGetEmojiKeywordsLanguages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiKeywordsLanguages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4e9963b2: func() error {
			x.PutClazzID(0x4e9963b2)

			iface.EncodeStringList(x, m.LangCodes)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiKeywordsLanguages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiKeywordsLanguages, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiKeywordsLanguages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4e9963b2: func() (err error) {

			m.LangCodes, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiURL <--
type TLMessagesGetEmojiURL struct {
	ClazzID  uint32 `json:"_id"`
	LangCode string `json:"lang_code"`
}

func (m *TLMessagesGetEmojiURL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiURL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd5b10c26: func() error {
			x.PutClazzID(0xd5b10c26)

			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiURL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiURL, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiURL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd5b10c26: func() (err error) {
			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSearchCounters <--
type TLMessagesGetSearchCounters struct {
	ClazzID     uint32                `json:"_id"`
	Peer        InputPeerClazz        `json:"peer"`
	SavedPeerId InputPeerClazz        `json:"saved_peer_id"`
	TopMsgId    *int32                `json:"top_msg_id"`
	Filters     []MessagesFilterClazz `json:"filters"`
}

func (m *TLMessagesGetSearchCounters) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSearchCounters) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1bbcf300: func() error {
			x.PutClazzID(0x1bbcf300)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SavedPeerId != nil {
					flags |= 1 << 2
				}
				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			_ = iface.EncodeObjectList(x, m.Filters, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSearchCounters, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSearchCounters, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSearchCounters) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1bbcf300: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 2)) != 0 {
				// m3 := &InputPeer{}
				// _ = m3.Decode(d)
				// m.SavedPeerId = m3
				m.SavedPeerId, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			c5, err2 := d.ClazzID()
			if c5 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
				return err2
			}
			l5, err3 := d.Int()
			// v5 := make([]*MessagesFilter, l5)
			v5 := make([]MessagesFilterClazz, l5)
			for i := 0; i < l5; i++ {
				// vv := new(MessagesFilter)
				// err3 = vv.Decode(d)
				// _ = err3
				// v5[i] = vv
				v5[i], _ = DecodeMessagesFilterClazz(d)
				_ = err3
			}
			m.Filters = v5

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestUrlAuth <--
type TLMessagesRequestUrlAuth struct {
	ClazzID  uint32         `json:"_id"`
	Peer     InputPeerClazz `json:"peer"`
	MsgId    *int32         `json:"msg_id"`
	ButtonId *int32         `json:"button_id"`
	Url      *string        `json:"url"`
}

func (m *TLMessagesRequestUrlAuth) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestUrlAuth) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x198fb446: func() error {
			x.PutClazzID(0x198fb446)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Peer != nil {
					flags |= 1 << 1
				}
				if m.MsgId != nil {
					flags |= 1 << 1
				}
				if m.ButtonId != nil {
					flags |= 1 << 1
				}
				if m.Url != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			if m.MsgId != nil {
				x.PutInt32(*m.MsgId)
			}

			if m.ButtonId != nil {
				x.PutInt32(*m.ButtonId)
			}

			if m.Url != nil {
				x.PutString(*m.Url)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestUrlAuth, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestUrlAuth, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestUrlAuth) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x198fb446: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				// m2 := &InputPeer{}
				// _ = m2.Decode(d)
				// m.Peer = m2
				m.Peer, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				m.MsgId = new(int32)
				*m.MsgId, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m.ButtonId = new(int32)
				*m.ButtonId, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				m.Url = new(string)
				*m.Url, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesAcceptUrlAuth <--
type TLMessagesAcceptUrlAuth struct {
	ClazzID      uint32         `json:"_id"`
	WriteAllowed bool           `json:"write_allowed"`
	Peer         InputPeerClazz `json:"peer"`
	MsgId        *int32         `json:"msg_id"`
	ButtonId     *int32         `json:"button_id"`
	Url          *string        `json:"url"`
}

func (m *TLMessagesAcceptUrlAuth) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesAcceptUrlAuth) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb12c7125: func() error {
			x.PutClazzID(0xb12c7125)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.WriteAllowed == true {
					flags |= 1 << 0
				}
				if m.Peer != nil {
					flags |= 1 << 1
				}
				if m.MsgId != nil {
					flags |= 1 << 1
				}
				if m.ButtonId != nil {
					flags |= 1 << 1
				}
				if m.Url != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			if m.MsgId != nil {
				x.PutInt32(*m.MsgId)
			}

			if m.ButtonId != nil {
				x.PutInt32(*m.ButtonId)
			}

			if m.Url != nil {
				x.PutString(*m.Url)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_acceptUrlAuth, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_acceptUrlAuth, layer)
	}
}

// Decode <--
func (m *TLMessagesAcceptUrlAuth) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb12c7125: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.WriteAllowed = true
			}
			if (flags & (1 << 1)) != 0 {
				// m3 := &InputPeer{}
				// _ = m3.Decode(d)
				// m.Peer = m3
				m.Peer, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				m.MsgId = new(int32)
				*m.MsgId, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m.ButtonId = new(int32)
				*m.ButtonId, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				m.Url = new(string)
				*m.Url, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesHidePeerSettingsBar <--
type TLMessagesHidePeerSettingsBar struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLMessagesHidePeerSettingsBar) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesHidePeerSettingsBar) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4facb138: func() error {
			x.PutClazzID(0x4facb138)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_hidePeerSettingsBar, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_hidePeerSettingsBar, layer)
	}
}

// Decode <--
func (m *TLMessagesHidePeerSettingsBar) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4facb138: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetScheduledHistory <--
type TLMessagesGetScheduledHistory struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Hash    int64          `json:"hash"`
}

func (m *TLMessagesGetScheduledHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetScheduledHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf516760b: func() error {
			x.PutClazzID(0xf516760b)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getScheduledHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getScheduledHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesGetScheduledHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf516760b: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetScheduledMessages <--
type TLMessagesGetScheduledMessages struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLMessagesGetScheduledMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetScheduledMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbdbb0464: func() error {
			x.PutClazzID(0xbdbb0464)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getScheduledMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getScheduledMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesGetScheduledMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbdbb0464: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendScheduledMessages <--
type TLMessagesSendScheduledMessages struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLMessagesSendScheduledMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendScheduledMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbd38850a: func() error {
			x.PutClazzID(0xbd38850a)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendScheduledMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendScheduledMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesSendScheduledMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbd38850a: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteScheduledMessages <--
type TLMessagesDeleteScheduledMessages struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLMessagesDeleteScheduledMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteScheduledMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x59ae2b16: func() error {
			x.PutClazzID(0x59ae2b16)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteScheduledMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteScheduledMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteScheduledMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x59ae2b16: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPollVotes <--
type TLMessagesGetPollVotes struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      int32          `json:"id"`
	Option  []byte         `json:"option"`
	Offset  *string        `json:"offset"`
	Limit   int32          `json:"limit"`
}

func (m *TLMessagesGetPollVotes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPollVotes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb86e380e: func() error {
			x.PutClazzID(0xb86e380e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Option != nil {
					flags |= 1 << 0
				}
				if m.Offset != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			if m.Option != nil {
				x.PutBytes(m.Option)
			}

			if m.Offset != nil {
				x.PutString(*m.Offset)
			}

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPollVotes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPollVotes, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPollVotes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb86e380e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Option, err = d.Bytes()
			}

			if (flags & (1 << 1)) != 0 {
				m.Offset = new(string)
				*m.Offset, err = d.String()
			}

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleStickerSets <--
type TLMessagesToggleStickerSets struct {
	ClazzID     uint32                 `json:"_id"`
	Uninstall   bool                   `json:"uninstall"`
	Archive     bool                   `json:"archive"`
	Unarchive   bool                   `json:"unarchive"`
	Stickersets []InputStickerSetClazz `json:"stickersets"`
}

func (m *TLMessagesToggleStickerSets) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleStickerSets) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb5052fea: func() error {
			x.PutClazzID(0xb5052fea)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Uninstall == true {
					flags |= 1 << 0
				}
				if m.Archive == true {
					flags |= 1 << 1
				}
				if m.Unarchive == true {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			_ = iface.EncodeObjectList(x, m.Stickersets, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleStickerSets, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleStickerSets, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleStickerSets) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb5052fea: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Uninstall = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Archive = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Unarchive = true
			}
			c5, err2 := d.ClazzID()
			if c5 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
				return err2
			}
			l5, err3 := d.Int()
			// v5 := make([]*InputStickerSet, l5)
			v5 := make([]InputStickerSetClazz, l5)
			for i := 0; i < l5; i++ {
				// vv := new(InputStickerSet)
				// err3 = vv.Decode(d)
				// _ = err3
				// v5[i] = vv
				v5[i], _ = DecodeInputStickerSetClazz(d)
				_ = err3
			}
			m.Stickersets = v5

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDialogFilters <--
type TLMessagesGetDialogFilters struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetDialogFilters) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDialogFilters) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xefd48c89: func() error {
			x.PutClazzID(0xefd48c89)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDialogFilters, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDialogFilters, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDialogFilters) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xefd48c89: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSuggestedDialogFilters <--
type TLMessagesGetSuggestedDialogFilters struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetSuggestedDialogFilters) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSuggestedDialogFilters) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa29cd42c: func() error {
			x.PutClazzID(0xa29cd42c)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSuggestedDialogFilters, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSuggestedDialogFilters, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSuggestedDialogFilters) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa29cd42c: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUpdateDialogFilter <--
type TLMessagesUpdateDialogFilter struct {
	ClazzID uint32            `json:"_id"`
	Id      int32             `json:"id"`
	Filter  DialogFilterClazz `json:"filter"`
}

func (m *TLMessagesUpdateDialogFilter) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUpdateDialogFilter) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1ad4a04a: func() error {
			x.PutClazzID(0x1ad4a04a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Filter != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.Id)
			if m.Filter != nil {
				_ = m.Filter.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_updateDialogFilter, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_updateDialogFilter, layer)
	}
}

// Decode <--
func (m *TLMessagesUpdateDialogFilter) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1ad4a04a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Id, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				// m3 := &DialogFilter{}
				// _ = m3.Decode(d)
				// m.Filter = m3
				m.Filter, _ = DecodeDialogFilterClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUpdateDialogFiltersOrder <--
type TLMessagesUpdateDialogFiltersOrder struct {
	ClazzID uint32  `json:"_id"`
	Order   []int32 `json:"order"`
}

func (m *TLMessagesUpdateDialogFiltersOrder) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUpdateDialogFiltersOrder) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc563c1e4: func() error {
			x.PutClazzID(0xc563c1e4)

			iface.EncodeInt32List(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_updateDialogFiltersOrder, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_updateDialogFiltersOrder, layer)
	}
}

// Decode <--
func (m *TLMessagesUpdateDialogFiltersOrder) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc563c1e4: func() (err error) {

			m.Order, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetOldFeaturedStickers <--
type TLMessagesGetOldFeaturedStickers struct {
	ClazzID uint32 `json:"_id"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetOldFeaturedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetOldFeaturedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7ed094a1: func() error {
			x.PutClazzID(0x7ed094a1)

			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getOldFeaturedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getOldFeaturedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetOldFeaturedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7ed094a1: func() (err error) {
			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetReplies <--
type TLMessagesGetReplies struct {
	ClazzID    uint32         `json:"_id"`
	Peer       InputPeerClazz `json:"peer"`
	MsgId      int32          `json:"msg_id"`
	OffsetId   int32          `json:"offset_id"`
	OffsetDate int32          `json:"offset_date"`
	AddOffset  int32          `json:"add_offset"`
	Limit      int32          `json:"limit"`
	MaxId      int32          `json:"max_id"`
	MinId      int32          `json:"min_id"`
	Hash       int64          `json:"hash"`
}

func (m *TLMessagesGetReplies) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetReplies) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x22ddd30c: func() error {
			x.PutClazzID(0x22ddd30c)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getReplies, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getReplies, layer)
	}
}

// Decode <--
func (m *TLMessagesGetReplies) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x22ddd30c: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()
			m.OffsetId, err = d.Int32()
			m.OffsetDate, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDiscussionMessage <--
type TLMessagesGetDiscussionMessage struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   int32          `json:"msg_id"`
}

func (m *TLMessagesGetDiscussionMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDiscussionMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x446972fd: func() error {
			x.PutClazzID(0x446972fd)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDiscussionMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDiscussionMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDiscussionMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x446972fd: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadDiscussion <--
type TLMessagesReadDiscussion struct {
	ClazzID   uint32         `json:"_id"`
	Peer      InputPeerClazz `json:"peer"`
	MsgId     int32          `json:"msg_id"`
	ReadMaxId int32          `json:"read_max_id"`
}

func (m *TLMessagesReadDiscussion) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadDiscussion) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf731a9f4: func() error {
			x.PutClazzID(0xf731a9f4)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutInt32(m.ReadMaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readDiscussion, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readDiscussion, layer)
	}
}

// Decode <--
func (m *TLMessagesReadDiscussion) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf731a9f4: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()
			m.ReadMaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUnpinAllMessages <--
type TLMessagesUnpinAllMessages struct {
	ClazzID     uint32         `json:"_id"`
	Peer        InputPeerClazz `json:"peer"`
	TopMsgId    *int32         `json:"top_msg_id"`
	SavedPeerId InputPeerClazz `json:"saved_peer_id"`
}

func (m *TLMessagesUnpinAllMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUnpinAllMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x62dd747: func() error {
			x.PutClazzID(0x62dd747)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}
				if m.SavedPeerId != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_unpinAllMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_unpinAllMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesUnpinAllMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x62dd747: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				// m4 := &InputPeer{}
				// _ = m4.Decode(d)
				// m.SavedPeerId = m4
				m.SavedPeerId, _ = DecodeInputPeerClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteChat <--
type TLMessagesDeleteChat struct {
	ClazzID uint32 `json:"_id"`
	ChatId  int64  `json:"chat_id"`
}

func (m *TLMessagesDeleteChat) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteChat) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5bd0ee50: func() error {
			x.PutClazzID(0x5bd0ee50)

			x.PutInt64(m.ChatId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteChat, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteChat, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteChat) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5bd0ee50: func() (err error) {
			m.ChatId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeletePhoneCallHistory <--
type TLMessagesDeletePhoneCallHistory struct {
	ClazzID uint32 `json:"_id"`
	Revoke  bool   `json:"revoke"`
}

func (m *TLMessagesDeletePhoneCallHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeletePhoneCallHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf9cbe409: func() error {
			x.PutClazzID(0xf9cbe409)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Revoke == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deletePhoneCallHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deletePhoneCallHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesDeletePhoneCallHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf9cbe409: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Revoke = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCheckHistoryImport <--
type TLMessagesCheckHistoryImport struct {
	ClazzID    uint32 `json:"_id"`
	ImportHead string `json:"import_head"`
}

func (m *TLMessagesCheckHistoryImport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCheckHistoryImport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x43fe19f3: func() error {
			x.PutClazzID(0x43fe19f3)

			x.PutString(m.ImportHead)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_checkHistoryImport, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_checkHistoryImport, layer)
	}
}

// Decode <--
func (m *TLMessagesCheckHistoryImport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x43fe19f3: func() (err error) {
			m.ImportHead, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesInitHistoryImport <--
type TLMessagesInitHistoryImport struct {
	ClazzID    uint32         `json:"_id"`
	Peer       InputPeerClazz `json:"peer"`
	File       InputFileClazz `json:"file"`
	MediaCount int32          `json:"media_count"`
}

func (m *TLMessagesInitHistoryImport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesInitHistoryImport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x34090c3b: func() error {
			x.PutClazzID(0x34090c3b)

			_ = m.Peer.Encode(x, layer)
			_ = m.File.Encode(x, layer)
			x.PutInt32(m.MediaCount)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_initHistoryImport, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_initHistoryImport, layer)
	}
}

// Decode <--
func (m *TLMessagesInitHistoryImport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x34090c3b: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputFile{}
			// _ = m2.Decode(d)
			// m.File = m2
			m.File, _ = DecodeInputFileClazz(d)

			m.MediaCount, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUploadImportedMedia <--
type TLMessagesUploadImportedMedia struct {
	ClazzID  uint32          `json:"_id"`
	Peer     InputPeerClazz  `json:"peer"`
	ImportId int64           `json:"import_id"`
	FileName string          `json:"file_name"`
	Media    InputMediaClazz `json:"media"`
}

func (m *TLMessagesUploadImportedMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUploadImportedMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2a862092: func() error {
			x.PutClazzID(0x2a862092)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.ImportId)
			x.PutString(m.FileName)
			_ = m.Media.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_uploadImportedMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_uploadImportedMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesUploadImportedMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2a862092: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.ImportId, err = d.Int64()
			m.FileName, err = d.String()

			// m4 := &InputMedia{}
			// _ = m4.Decode(d)
			// m.Media = m4
			m.Media, _ = DecodeInputMediaClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesStartHistoryImport <--
type TLMessagesStartHistoryImport struct {
	ClazzID  uint32         `json:"_id"`
	Peer     InputPeerClazz `json:"peer"`
	ImportId int64          `json:"import_id"`
}

func (m *TLMessagesStartHistoryImport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesStartHistoryImport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb43df344: func() error {
			x.PutClazzID(0xb43df344)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.ImportId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_startHistoryImport, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_startHistoryImport, layer)
	}
}

// Decode <--
func (m *TLMessagesStartHistoryImport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb43df344: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.ImportId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetExportedChatInvites <--
type TLMessagesGetExportedChatInvites struct {
	ClazzID    uint32         `json:"_id"`
	Revoked    bool           `json:"revoked"`
	Peer       InputPeerClazz `json:"peer"`
	AdminId    InputUserClazz `json:"admin_id"`
	OffsetDate *int32         `json:"offset_date"`
	OffsetLink *string        `json:"offset_link"`
	Limit      int32          `json:"limit"`
}

func (m *TLMessagesGetExportedChatInvites) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetExportedChatInvites) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa2b5a3f6: func() error {
			x.PutClazzID(0xa2b5a3f6)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Revoked == true {
					flags |= 1 << 3
				}

				if m.OffsetDate != nil {
					flags |= 1 << 2
				}
				if m.OffsetLink != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.AdminId.Encode(x, layer)
			if m.OffsetDate != nil {
				x.PutInt32(*m.OffsetDate)
			}

			if m.OffsetLink != nil {
				x.PutString(*m.OffsetLink)
			}

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getExportedChatInvites, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getExportedChatInvites, layer)
	}
}

// Decode <--
func (m *TLMessagesGetExportedChatInvites) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa2b5a3f6: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 3)) != 0 {
				m.Revoked = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m4 := &InputUser{}
			// _ = m4.Decode(d)
			// m.AdminId = m4
			m.AdminId, _ = DecodeInputUserClazz(d)

			if (flags & (1 << 2)) != 0 {
				m.OffsetDate = new(int32)
				*m.OffsetDate, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				m.OffsetLink = new(string)
				*m.OffsetLink, err = d.String()
			}

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetExportedChatInvite <--
type TLMessagesGetExportedChatInvite struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Link    string         `json:"link"`
}

func (m *TLMessagesGetExportedChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetExportedChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x73746f5c: func() error {
			x.PutClazzID(0x73746f5c)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Link)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getExportedChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getExportedChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesGetExportedChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x73746f5c: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Link, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditExportedChatInvite <--
type TLMessagesEditExportedChatInvite struct {
	ClazzID       uint32         `json:"_id"`
	Revoked       bool           `json:"revoked"`
	Peer          InputPeerClazz `json:"peer"`
	Link          string         `json:"link"`
	ExpireDate    *int32         `json:"expire_date"`
	UsageLimit    *int32         `json:"usage_limit"`
	RequestNeeded BoolClazz      `json:"request_needed"`
	Title         *string        `json:"title"`
}

func (m *TLMessagesEditExportedChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditExportedChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbdca2f75: func() error {
			x.PutClazzID(0xbdca2f75)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Revoked == true {
					flags |= 1 << 2
				}

				if m.ExpireDate != nil {
					flags |= 1 << 0
				}
				if m.UsageLimit != nil {
					flags |= 1 << 1
				}
				if m.RequestNeeded != nil {
					flags |= 1 << 3
				}
				if m.Title != nil {
					flags |= 1 << 4
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Link)
			if m.ExpireDate != nil {
				x.PutInt32(*m.ExpireDate)
			}

			if m.UsageLimit != nil {
				x.PutInt32(*m.UsageLimit)
			}

			if m.RequestNeeded != nil {
				_ = m.RequestNeeded.Encode(x, layer)
			}

			if m.Title != nil {
				x.PutString(*m.Title)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editExportedChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editExportedChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesEditExportedChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbdca2f75: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m.Revoked = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Link, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.ExpireDate = new(int32)
				*m.ExpireDate, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m.UsageLimit = new(int32)
				*m.UsageLimit, err = d.Int32()
			}
			if (flags & (1 << 3)) != 0 {
				// m7 := &Bool{}
				// _ = m7.Decode(d)
				// m.RequestNeeded = m7
				m.RequestNeeded, _ = DecodeBoolClazz(d)
			}
			if (flags & (1 << 4)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteRevokedExportedChatInvites <--
type TLMessagesDeleteRevokedExportedChatInvites struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	AdminId InputUserClazz `json:"admin_id"`
}

func (m *TLMessagesDeleteRevokedExportedChatInvites) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteRevokedExportedChatInvites) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x56987bd5: func() error {
			x.PutClazzID(0x56987bd5)

			_ = m.Peer.Encode(x, layer)
			_ = m.AdminId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteRevokedExportedChatInvites, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteRevokedExportedChatInvites, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteRevokedExportedChatInvites) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x56987bd5: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.AdminId = m2
			m.AdminId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteExportedChatInvite <--
type TLMessagesDeleteExportedChatInvite struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Link    string         `json:"link"`
}

func (m *TLMessagesDeleteExportedChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteExportedChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd464a42b: func() error {
			x.PutClazzID(0xd464a42b)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Link)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteExportedChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteExportedChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteExportedChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd464a42b: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Link, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAdminsWithInvites <--
type TLMessagesGetAdminsWithInvites struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLMessagesGetAdminsWithInvites) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAdminsWithInvites) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3920e6ef: func() error {
			x.PutClazzID(0x3920e6ef)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAdminsWithInvites, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAdminsWithInvites, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAdminsWithInvites) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3920e6ef: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetChatInviteImporters <--
type TLMessagesGetChatInviteImporters struct {
	ClazzID             uint32         `json:"_id"`
	Requested           bool           `json:"requested"`
	SubscriptionExpired bool           `json:"subscription_expired"`
	Peer                InputPeerClazz `json:"peer"`
	Link                *string        `json:"link"`
	Q                   *string        `json:"q"`
	OffsetDate          int32          `json:"offset_date"`
	OffsetUser          InputUserClazz `json:"offset_user"`
	Limit               int32          `json:"limit"`
}

func (m *TLMessagesGetChatInviteImporters) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetChatInviteImporters) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdf04dd4e: func() error {
			x.PutClazzID(0xdf04dd4e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Requested == true {
					flags |= 1 << 0
				}
				if m.SubscriptionExpired == true {
					flags |= 1 << 3
				}

				if m.Link != nil {
					flags |= 1 << 1
				}
				if m.Q != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.Link != nil {
				x.PutString(*m.Link)
			}

			if m.Q != nil {
				x.PutString(*m.Q)
			}

			x.PutInt32(m.OffsetDate)
			_ = m.OffsetUser.Encode(x, layer)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getChatInviteImporters, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getChatInviteImporters, layer)
	}
}

// Decode <--
func (m *TLMessagesGetChatInviteImporters) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdf04dd4e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Requested = true
			}
			if (flags & (1 << 3)) != 0 {
				m.SubscriptionExpired = true
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 1)) != 0 {
				m.Link = new(string)
				*m.Link, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.Q = new(string)
				*m.Q, err = d.String()
			}

			m.OffsetDate, err = d.Int32()

			// m8 := &InputUser{}
			// _ = m8.Decode(d)
			// m.OffsetUser = m8
			m.OffsetUser, _ = DecodeInputUserClazz(d)

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetHistoryTTL <--
type TLMessagesSetHistoryTTL struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Period  int32          `json:"period"`
}

func (m *TLMessagesSetHistoryTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetHistoryTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb80e5fe4: func() error {
			x.PutClazzID(0xb80e5fe4)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Period)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setHistoryTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setHistoryTTL, layer)
	}
}

// Decode <--
func (m *TLMessagesSetHistoryTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb80e5fe4: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Period, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCheckHistoryImportPeer <--
type TLMessagesCheckHistoryImportPeer struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLMessagesCheckHistoryImportPeer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCheckHistoryImportPeer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5dc60f03: func() error {
			x.PutClazzID(0x5dc60f03)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_checkHistoryImportPeer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_checkHistoryImportPeer, layer)
	}
}

// Decode <--
func (m *TLMessagesCheckHistoryImportPeer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5dc60f03: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetChatTheme <--
type TLMessagesSetChatTheme struct {
	ClazzID uint32              `json:"_id"`
	Peer    InputPeerClazz      `json:"peer"`
	Theme   InputChatThemeClazz `json:"theme"`
}

func (m *TLMessagesSetChatTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetChatTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x81202c9: func() error {
			x.PutClazzID(0x81202c9)

			_ = m.Peer.Encode(x, layer)
			_ = m.Theme.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setChatTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setChatTheme, layer)
	}
}

// Decode <--
func (m *TLMessagesSetChatTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x81202c9: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputChatTheme{}
			// _ = m2.Decode(d)
			// m.Theme = m2
			m.Theme, _ = DecodeInputChatThemeClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessageReadParticipants <--
type TLMessagesGetMessageReadParticipants struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   int32          `json:"msg_id"`
}

func (m *TLMessagesGetMessageReadParticipants) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessageReadParticipants) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x31c1c44f: func() error {
			x.PutClazzID(0x31c1c44f)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessageReadParticipants, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessageReadParticipants, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessageReadParticipants) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x31c1c44f: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSearchResultsCalendar <--
type TLMessagesGetSearchResultsCalendar struct {
	ClazzID     uint32              `json:"_id"`
	Peer        InputPeerClazz      `json:"peer"`
	SavedPeerId InputPeerClazz      `json:"saved_peer_id"`
	Filter      MessagesFilterClazz `json:"filter"`
	OffsetId    int32               `json:"offset_id"`
	OffsetDate  int32               `json:"offset_date"`
}

func (m *TLMessagesGetSearchResultsCalendar) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSearchResultsCalendar) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6aa3f6bd: func() error {
			x.PutClazzID(0x6aa3f6bd)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SavedPeerId != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.OffsetDate)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSearchResultsCalendar, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSearchResultsCalendar, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSearchResultsCalendar) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6aa3f6bd: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 2)) != 0 {
				// m3 := &InputPeer{}
				// _ = m3.Decode(d)
				// m.SavedPeerId = m3
				m.SavedPeerId, _ = DecodeInputPeerClazz(d)
			}

			// m4 := &MessagesFilter{}
			// _ = m4.Decode(d)
			// m.Filter = m4
			m.Filter, _ = DecodeMessagesFilterClazz(d)

			m.OffsetId, err = d.Int32()
			m.OffsetDate, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSearchResultsPositions <--
type TLMessagesGetSearchResultsPositions struct {
	ClazzID     uint32              `json:"_id"`
	Peer        InputPeerClazz      `json:"peer"`
	SavedPeerId InputPeerClazz      `json:"saved_peer_id"`
	Filter      MessagesFilterClazz `json:"filter"`
	OffsetId    int32               `json:"offset_id"`
	Limit       int32               `json:"limit"`
}

func (m *TLMessagesGetSearchResultsPositions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSearchResultsPositions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9c7f2f10: func() error {
			x.PutClazzID(0x9c7f2f10)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SavedPeerId != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSearchResultsPositions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSearchResultsPositions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSearchResultsPositions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9c7f2f10: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 2)) != 0 {
				// m3 := &InputPeer{}
				// _ = m3.Decode(d)
				// m.SavedPeerId = m3
				m.SavedPeerId, _ = DecodeInputPeerClazz(d)
			}

			// m4 := &MessagesFilter{}
			// _ = m4.Decode(d)
			// m.Filter = m4
			m.Filter, _ = DecodeMessagesFilterClazz(d)

			m.OffsetId, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesHideChatJoinRequest <--
type TLMessagesHideChatJoinRequest struct {
	ClazzID  uint32         `json:"_id"`
	Approved bool           `json:"approved"`
	Peer     InputPeerClazz `json:"peer"`
	UserId   InputUserClazz `json:"user_id"`
}

func (m *TLMessagesHideChatJoinRequest) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesHideChatJoinRequest) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7fe7e815: func() error {
			x.PutClazzID(0x7fe7e815)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Approved == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_hideChatJoinRequest, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_hideChatJoinRequest, layer)
	}
}

// Decode <--
func (m *TLMessagesHideChatJoinRequest) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7fe7e815: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Approved = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m4 := &InputUser{}
			// _ = m4.Decode(d)
			// m.UserId = m4
			m.UserId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesHideAllChatJoinRequests <--
type TLMessagesHideAllChatJoinRequests struct {
	ClazzID  uint32         `json:"_id"`
	Approved bool           `json:"approved"`
	Peer     InputPeerClazz `json:"peer"`
	Link     *string        `json:"link"`
}

func (m *TLMessagesHideAllChatJoinRequests) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesHideAllChatJoinRequests) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe085f4ea: func() error {
			x.PutClazzID(0xe085f4ea)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Approved == true {
					flags |= 1 << 0
				}

				if m.Link != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.Link != nil {
				x.PutString(*m.Link)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_hideAllChatJoinRequests, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_hideAllChatJoinRequests, layer)
	}
}

// Decode <--
func (m *TLMessagesHideAllChatJoinRequests) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe085f4ea: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Approved = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 1)) != 0 {
				m.Link = new(string)
				*m.Link, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleNoForwards <--
type TLMessagesToggleNoForwards struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Enabled BoolClazz      `json:"enabled"`
}

func (m *TLMessagesToggleNoForwards) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleNoForwards) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb11eafa2: func() error {
			x.PutClazzID(0xb11eafa2)

			_ = m.Peer.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleNoForwards, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleNoForwards, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleNoForwards) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb11eafa2: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Enabled = m2
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSaveDefaultSendAs <--
type TLMessagesSaveDefaultSendAs struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	SendAs  InputPeerClazz `json:"send_as"`
}

func (m *TLMessagesSaveDefaultSendAs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSaveDefaultSendAs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xccfddf96: func() error {
			x.PutClazzID(0xccfddf96)

			_ = m.Peer.Encode(x, layer)
			_ = m.SendAs.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_saveDefaultSendAs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_saveDefaultSendAs, layer)
	}
}

// Decode <--
func (m *TLMessagesSaveDefaultSendAs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xccfddf96: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.SendAs = m2
			m.SendAs, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendReaction <--
type TLMessagesSendReaction struct {
	ClazzID     uint32          `json:"_id"`
	Big         bool            `json:"big"`
	AddToRecent bool            `json:"add_to_recent"`
	Peer        InputPeerClazz  `json:"peer"`
	MsgId       int32           `json:"msg_id"`
	Reaction    []ReactionClazz `json:"reaction"`
}

func (m *TLMessagesSendReaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendReaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd30d78d4: func() error {
			x.PutClazzID(0xd30d78d4)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Big == true {
					flags |= 1 << 1
				}
				if m.AddToRecent == true {
					flags |= 1 << 2
				}

				if m.Reaction != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			if m.Reaction != nil {
				_ = iface.EncodeObjectList(x, m.Reaction, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendReaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendReaction, layer)
	}
}

// Decode <--
func (m *TLMessagesSendReaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd30d78d4: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Big = true
			}
			if (flags & (1 << 2)) != 0 {
				m.AddToRecent = true
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				c6, err2 := d.ClazzID()
				if c6 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 6, c6)
					return err2
				}
				l6, err3 := d.Int()
				// v6 := make([]*Reaction, l6)
				v6 := make([]ReactionClazz, l6)
				for i := 0; i < l6; i++ {
					// vv := new(Reaction)
					// err3 = vv.Decode(d)
					// _ = err3
					// v6[i] = vv
					v6[i], _ = DecodeReactionClazz(d)
					_ = err3
				}
				m.Reaction = v6
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessagesReactions <--
type TLMessagesGetMessagesReactions struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLMessagesGetMessagesReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessagesReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8bba90e6: func() error {
			x.PutClazzID(0x8bba90e6)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessagesReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessagesReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessagesReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8bba90e6: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessageReactionsList <--
type TLMessagesGetMessageReactionsList struct {
	ClazzID  uint32         `json:"_id"`
	Peer     InputPeerClazz `json:"peer"`
	Id       int32          `json:"id"`
	Reaction ReactionClazz  `json:"reaction"`
	Offset   *string        `json:"offset"`
	Limit    int32          `json:"limit"`
}

func (m *TLMessagesGetMessageReactionsList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessageReactionsList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x461b3f48: func() error {
			x.PutClazzID(0x461b3f48)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Reaction != nil {
					flags |= 1 << 0
				}
				if m.Offset != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			if m.Reaction != nil {
				_ = m.Reaction.Encode(x, layer)
			}

			if m.Offset != nil {
				x.PutString(*m.Offset)
			}

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessageReactionsList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessageReactionsList, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessageReactionsList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x461b3f48: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				// m4 := &Reaction{}
				// _ = m4.Decode(d)
				// m.Reaction = m4
				m.Reaction, _ = DecodeReactionClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				m.Offset = new(string)
				*m.Offset, err = d.String()
			}

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetChatAvailableReactions <--
type TLMessagesSetChatAvailableReactions struct {
	ClazzID            uint32             `json:"_id"`
	Peer               InputPeerClazz     `json:"peer"`
	AvailableReactions ChatReactionsClazz `json:"available_reactions"`
	ReactionsLimit     *int32             `json:"reactions_limit"`
	PaidEnabled        BoolClazz          `json:"paid_enabled"`
}

func (m *TLMessagesSetChatAvailableReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetChatAvailableReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x864b2581: func() error {
			x.PutClazzID(0x864b2581)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ReactionsLimit != nil {
					flags |= 1 << 0
				}
				if m.PaidEnabled != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.AvailableReactions.Encode(x, layer)
			if m.ReactionsLimit != nil {
				x.PutInt32(*m.ReactionsLimit)
			}

			if m.PaidEnabled != nil {
				_ = m.PaidEnabled.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setChatAvailableReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setChatAvailableReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesSetChatAvailableReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x864b2581: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m3 := &ChatReactions{}
			// _ = m3.Decode(d)
			// m.AvailableReactions = m3
			m.AvailableReactions, _ = DecodeChatReactionsClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.ReactionsLimit = new(int32)
				*m.ReactionsLimit, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				// m5 := &Bool{}
				// _ = m5.Decode(d)
				// m.PaidEnabled = m5
				m.PaidEnabled, _ = DecodeBoolClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAvailableReactions <--
type TLMessagesGetAvailableReactions struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetAvailableReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAvailableReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x18dea0ac: func() error {
			x.PutClazzID(0x18dea0ac)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAvailableReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAvailableReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAvailableReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x18dea0ac: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetDefaultReaction <--
type TLMessagesSetDefaultReaction struct {
	ClazzID  uint32        `json:"_id"`
	Reaction ReactionClazz `json:"reaction"`
}

func (m *TLMessagesSetDefaultReaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetDefaultReaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4f47a016: func() error {
			x.PutClazzID(0x4f47a016)

			_ = m.Reaction.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setDefaultReaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setDefaultReaction, layer)
	}
}

// Decode <--
func (m *TLMessagesSetDefaultReaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4f47a016: func() (err error) {

			// m1 := &Reaction{}
			// _ = m1.Decode(d)
			// m.Reaction = m1
			m.Reaction, _ = DecodeReactionClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesTranslateText <--
type TLMessagesTranslateText struct {
	ClazzID uint32                  `json:"_id"`
	Peer    InputPeerClazz          `json:"peer"`
	Id      []int32                 `json:"id"`
	Text    []TextWithEntitiesClazz `json:"text"`
	ToLang  string                  `json:"to_lang"`
}

func (m *TLMessagesTranslateText) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesTranslateText) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x63183030: func() error {
			x.PutClazzID(0x63183030)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Peer != nil {
					flags |= 1 << 0
				}
				if m.Id != nil {
					flags |= 1 << 0
				}
				if m.Text != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			if m.Id != nil {
				iface.EncodeInt32List(x, m.Id)
			}
			if m.Text != nil {
				_ = iface.EncodeObjectList(x, m.Text, layer)
			}
			x.PutString(m.ToLang)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_translateText, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_translateText, layer)
	}
}

// Decode <--
func (m *TLMessagesTranslateText) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x63183030: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputPeer{}
				// _ = m2.Decode(d)
				// m.Peer = m2
				m.Peer, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 0)) != 0 {
				m.Id, err = iface.DecodeInt32List(d)
			}
			if (flags & (1 << 1)) != 0 {
				c4, err2 := d.ClazzID()
				if c4 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
					return err2
				}
				l4, err3 := d.Int()
				// v4 := make([]*TextWithEntities, l4)
				v4 := make([]TextWithEntitiesClazz, l4)
				for i := 0; i < l4; i++ {
					// vv := new(TextWithEntities)
					// err3 = vv.Decode(d)
					// _ = err3
					// v4[i] = vv
					v4[i], _ = DecodeTextWithEntitiesClazz(d)
					_ = err3
				}
				m.Text = v4
			}
			m.ToLang, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetUnreadReactions <--
type TLMessagesGetUnreadReactions struct {
	ClazzID     uint32         `json:"_id"`
	Peer        InputPeerClazz `json:"peer"`
	TopMsgId    *int32         `json:"top_msg_id"`
	SavedPeerId InputPeerClazz `json:"saved_peer_id"`
	OffsetId    int32          `json:"offset_id"`
	AddOffset   int32          `json:"add_offset"`
	Limit       int32          `json:"limit"`
	MaxId       int32          `json:"max_id"`
	MinId       int32          `json:"min_id"`
}

func (m *TLMessagesGetUnreadReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetUnreadReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbd7f90ac: func() error {
			x.PutClazzID(0xbd7f90ac)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}
				if m.SavedPeerId != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			x.PutInt32(m.OffsetId)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getUnreadReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getUnreadReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetUnreadReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbd7f90ac: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				// m4 := &InputPeer{}
				// _ = m4.Decode(d)
				// m.SavedPeerId = m4
				m.SavedPeerId, _ = DecodeInputPeerClazz(d)
			}
			m.OffsetId, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadReactions <--
type TLMessagesReadReactions struct {
	ClazzID     uint32         `json:"_id"`
	Peer        InputPeerClazz `json:"peer"`
	TopMsgId    *int32         `json:"top_msg_id"`
	SavedPeerId InputPeerClazz `json:"saved_peer_id"`
}

func (m *TLMessagesReadReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9ec44f93: func() error {
			x.PutClazzID(0x9ec44f93)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}
				if m.SavedPeerId != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesReadReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9ec44f93: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				// m4 := &InputPeer{}
				// _ = m4.Decode(d)
				// m.SavedPeerId = m4
				m.SavedPeerId, _ = DecodeInputPeerClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchSentMedia <--
type TLMessagesSearchSentMedia struct {
	ClazzID uint32              `json:"_id"`
	Q       string              `json:"q"`
	Filter  MessagesFilterClazz `json:"filter"`
	Limit   int32               `json:"limit"`
}

func (m *TLMessagesSearchSentMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchSentMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x107e31a0: func() error {
			x.PutClazzID(0x107e31a0)

			x.PutString(m.Q)
			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchSentMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchSentMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchSentMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x107e31a0: func() (err error) {
			m.Q, err = d.String()

			// m2 := &MessagesFilter{}
			// _ = m2.Decode(d)
			// m.Filter = m2
			m.Filter, _ = DecodeMessagesFilterClazz(d)

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAttachMenuBots <--
type TLMessagesGetAttachMenuBots struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetAttachMenuBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAttachMenuBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x16fcc2cb: func() error {
			x.PutClazzID(0x16fcc2cb)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAttachMenuBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAttachMenuBots, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAttachMenuBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x16fcc2cb: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAttachMenuBot <--
type TLMessagesGetAttachMenuBot struct {
	ClazzID uint32         `json:"_id"`
	Bot     InputUserClazz `json:"bot"`
}

func (m *TLMessagesGetAttachMenuBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAttachMenuBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x77216192: func() error {
			x.PutClazzID(0x77216192)

			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAttachMenuBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAttachMenuBot, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAttachMenuBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x77216192: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleBotInAttachMenu <--
type TLMessagesToggleBotInAttachMenu struct {
	ClazzID      uint32         `json:"_id"`
	WriteAllowed bool           `json:"write_allowed"`
	Bot          InputUserClazz `json:"bot"`
	Enabled      BoolClazz      `json:"enabled"`
}

func (m *TLMessagesToggleBotInAttachMenu) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleBotInAttachMenu) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x69f59d69: func() error {
			x.PutClazzID(0x69f59d69)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.WriteAllowed == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Bot.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleBotInAttachMenu, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleBotInAttachMenu, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleBotInAttachMenu) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x69f59d69: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.WriteAllowed = true
			}

			// m3 := &InputUser{}
			// _ = m3.Decode(d)
			// m.Bot = m3
			m.Bot, _ = DecodeInputUserClazz(d)

			// m4 := &Bool{}
			// _ = m4.Decode(d)
			// m.Enabled = m4
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestWebView <--
type TLMessagesRequestWebView struct {
	ClazzID     uint32            `json:"_id"`
	FromBotMenu bool              `json:"from_bot_menu"`
	Silent      bool              `json:"silent"`
	Compact     bool              `json:"compact"`
	Fullscreen  bool              `json:"fullscreen"`
	Peer        InputPeerClazz    `json:"peer"`
	Bot         InputUserClazz    `json:"bot"`
	Url         *string           `json:"url"`
	StartParam  *string           `json:"start_param"`
	ThemeParams DataJSONClazz     `json:"theme_params"`
	Platform    string            `json:"platform"`
	ReplyTo     InputReplyToClazz `json:"reply_to"`
	SendAs      InputPeerClazz    `json:"send_as"`
}

func (m *TLMessagesRequestWebView) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestWebView) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x269dc2c1: func() error {
			x.PutClazzID(0x269dc2c1)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FromBotMenu == true {
					flags |= 1 << 4
				}
				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Compact == true {
					flags |= 1 << 7
				}
				if m.Fullscreen == true {
					flags |= 1 << 8
				}

				if m.Url != nil {
					flags |= 1 << 1
				}
				if m.StartParam != nil {
					flags |= 1 << 3
				}
				if m.ThemeParams != nil {
					flags |= 1 << 2
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.Bot.Encode(x, layer)
			if m.Url != nil {
				x.PutString(*m.Url)
			}

			if m.StartParam != nil {
				x.PutString(*m.StartParam)
			}

			if m.ThemeParams != nil {
				_ = m.ThemeParams.Encode(x, layer)
			}

			x.PutString(m.Platform)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestWebView, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestWebView, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestWebView) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x269dc2c1: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 4)) != 0 {
				m.FromBotMenu = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 7)) != 0 {
				m.Compact = true
			}
			if (flags & (1 << 8)) != 0 {
				m.Fullscreen = true
			}

			// m6 := &InputPeer{}
			// _ = m6.Decode(d)
			// m.Peer = m6
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m7 := &InputUser{}
			// _ = m7.Decode(d)
			// m.Bot = m7
			m.Bot, _ = DecodeInputUserClazz(d)

			if (flags & (1 << 1)) != 0 {
				m.Url = new(string)
				*m.Url, err = d.String()
			}

			if (flags & (1 << 3)) != 0 {
				m.StartParam = new(string)
				*m.StartParam, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				// m10 := &DataJSON{}
				// _ = m10.Decode(d)
				// m.ThemeParams = m10
				m.ThemeParams, _ = DecodeDataJSONClazz(d)
			}
			m.Platform, err = d.String()
			if (flags & (1 << 0)) != 0 {
				// m12 := &InputReplyTo{}
				// _ = m12.Decode(d)
				// m.ReplyTo = m12
				m.ReplyTo, _ = DecodeInputReplyToClazz(d)
			}
			if (flags & (1 << 13)) != 0 {
				// m13 := &InputPeer{}
				// _ = m13.Decode(d)
				// m.SendAs = m13
				m.SendAs, _ = DecodeInputPeerClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesProlongWebView <--
type TLMessagesProlongWebView struct {
	ClazzID uint32            `json:"_id"`
	Silent  bool              `json:"silent"`
	Peer    InputPeerClazz    `json:"peer"`
	Bot     InputUserClazz    `json:"bot"`
	QueryId int64             `json:"query_id"`
	ReplyTo InputReplyToClazz `json:"reply_to"`
	SendAs  InputPeerClazz    `json:"send_as"`
}

func (m *TLMessagesProlongWebView) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesProlongWebView) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb0d81a83: func() error {
			x.PutClazzID(0xb0d81a83)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.Bot.Encode(x, layer)
			x.PutInt64(m.QueryId)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_prolongWebView, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_prolongWebView, layer)
	}
}

// Decode <--
func (m *TLMessagesProlongWebView) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb0d81a83: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m4 := &InputUser{}
			// _ = m4.Decode(d)
			// m.Bot = m4
			m.Bot, _ = DecodeInputUserClazz(d)

			m.QueryId, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				// m6 := &InputReplyTo{}
				// _ = m6.Decode(d)
				// m.ReplyTo = m6
				m.ReplyTo, _ = DecodeInputReplyToClazz(d)
			}
			if (flags & (1 << 13)) != 0 {
				// m7 := &InputPeer{}
				// _ = m7.Decode(d)
				// m.SendAs = m7
				m.SendAs, _ = DecodeInputPeerClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestSimpleWebView <--
type TLMessagesRequestSimpleWebView struct {
	ClazzID           uint32         `json:"_id"`
	FromSwitchWebview bool           `json:"from_switch_webview"`
	FromSideMenu      bool           `json:"from_side_menu"`
	Compact           bool           `json:"compact"`
	Fullscreen        bool           `json:"fullscreen"`
	Bot               InputUserClazz `json:"bot"`
	Url               *string        `json:"url"`
	StartParam        *string        `json:"start_param"`
	ThemeParams       DataJSONClazz  `json:"theme_params"`
	Platform          string         `json:"platform"`
}

func (m *TLMessagesRequestSimpleWebView) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestSimpleWebView) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x413a3e73: func() error {
			x.PutClazzID(0x413a3e73)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FromSwitchWebview == true {
					flags |= 1 << 1
				}
				if m.FromSideMenu == true {
					flags |= 1 << 2
				}
				if m.Compact == true {
					flags |= 1 << 7
				}
				if m.Fullscreen == true {
					flags |= 1 << 8
				}

				if m.Url != nil {
					flags |= 1 << 3
				}
				if m.StartParam != nil {
					flags |= 1 << 4
				}
				if m.ThemeParams != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Bot.Encode(x, layer)
			if m.Url != nil {
				x.PutString(*m.Url)
			}

			if m.StartParam != nil {
				x.PutString(*m.StartParam)
			}

			if m.ThemeParams != nil {
				_ = m.ThemeParams.Encode(x, layer)
			}

			x.PutString(m.Platform)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestSimpleWebView, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestSimpleWebView, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestSimpleWebView) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x413a3e73: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.FromSwitchWebview = true
			}
			if (flags & (1 << 2)) != 0 {
				m.FromSideMenu = true
			}
			if (flags & (1 << 7)) != 0 {
				m.Compact = true
			}
			if (flags & (1 << 8)) != 0 {
				m.Fullscreen = true
			}

			// m6 := &InputUser{}
			// _ = m6.Decode(d)
			// m.Bot = m6
			m.Bot, _ = DecodeInputUserClazz(d)

			if (flags & (1 << 3)) != 0 {
				m.Url = new(string)
				*m.Url, err = d.String()
			}

			if (flags & (1 << 4)) != 0 {
				m.StartParam = new(string)
				*m.StartParam, err = d.String()
			}

			if (flags & (1 << 0)) != 0 {
				// m9 := &DataJSON{}
				// _ = m9.Decode(d)
				// m.ThemeParams = m9
				m.ThemeParams, _ = DecodeDataJSONClazz(d)
			}
			m.Platform, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendWebViewResultMessage <--
type TLMessagesSendWebViewResultMessage struct {
	ClazzID    uint32                    `json:"_id"`
	BotQueryId string                    `json:"bot_query_id"`
	Result     InputBotInlineResultClazz `json:"result"`
}

func (m *TLMessagesSendWebViewResultMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendWebViewResultMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa4314f5: func() error {
			x.PutClazzID(0xa4314f5)

			x.PutString(m.BotQueryId)
			_ = m.Result.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendWebViewResultMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendWebViewResultMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesSendWebViewResultMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa4314f5: func() (err error) {
			m.BotQueryId, err = d.String()

			// m2 := &InputBotInlineResult{}
			// _ = m2.Decode(d)
			// m.Result = m2
			m.Result, _ = DecodeInputBotInlineResultClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendWebViewData <--
type TLMessagesSendWebViewData struct {
	ClazzID    uint32         `json:"_id"`
	Bot        InputUserClazz `json:"bot"`
	RandomId   int64          `json:"random_id"`
	ButtonText string         `json:"button_text"`
	Data       string         `json:"data"`
}

func (m *TLMessagesSendWebViewData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendWebViewData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdc0242c8: func() error {
			x.PutClazzID(0xdc0242c8)

			_ = m.Bot.Encode(x, layer)
			x.PutInt64(m.RandomId)
			x.PutString(m.ButtonText)
			x.PutString(m.Data)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendWebViewData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendWebViewData, layer)
	}
}

// Decode <--
func (m *TLMessagesSendWebViewData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdc0242c8: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.RandomId, err = d.Int64()
			m.ButtonText, err = d.String()
			m.Data, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesTranscribeAudio <--
type TLMessagesTranscribeAudio struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   int32          `json:"msg_id"`
}

func (m *TLMessagesTranscribeAudio) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesTranscribeAudio) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x269e9a49: func() error {
			x.PutClazzID(0x269e9a49)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_transcribeAudio, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_transcribeAudio, layer)
	}
}

// Decode <--
func (m *TLMessagesTranscribeAudio) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x269e9a49: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRateTranscribedAudio <--
type TLMessagesRateTranscribedAudio struct {
	ClazzID         uint32         `json:"_id"`
	Peer            InputPeerClazz `json:"peer"`
	MsgId           int32          `json:"msg_id"`
	TranscriptionId int64          `json:"transcription_id"`
	Good            BoolClazz      `json:"good"`
}

func (m *TLMessagesRateTranscribedAudio) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRateTranscribedAudio) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7f1d072f: func() error {
			x.PutClazzID(0x7f1d072f)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutInt64(m.TranscriptionId)
			_ = m.Good.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_rateTranscribedAudio, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_rateTranscribedAudio, layer)
	}
}

// Decode <--
func (m *TLMessagesRateTranscribedAudio) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7f1d072f: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()
			m.TranscriptionId, err = d.Int64()

			// m4 := &Bool{}
			// _ = m4.Decode(d)
			// m.Good = m4
			m.Good, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetCustomEmojiDocuments <--
type TLMessagesGetCustomEmojiDocuments struct {
	ClazzID    uint32  `json:"_id"`
	DocumentId []int64 `json:"document_id"`
}

func (m *TLMessagesGetCustomEmojiDocuments) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetCustomEmojiDocuments) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd9ab0f54: func() error {
			x.PutClazzID(0xd9ab0f54)

			iface.EncodeInt64List(x, m.DocumentId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getCustomEmojiDocuments, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getCustomEmojiDocuments, layer)
	}
}

// Decode <--
func (m *TLMessagesGetCustomEmojiDocuments) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd9ab0f54: func() (err error) {

			m.DocumentId, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiStickers <--
type TLMessagesGetEmojiStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetEmojiStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfbfca18f: func() error {
			x.PutClazzID(0xfbfca18f)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfbfca18f: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetFeaturedEmojiStickers <--
type TLMessagesGetFeaturedEmojiStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetFeaturedEmojiStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetFeaturedEmojiStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xecf6736: func() error {
			x.PutClazzID(0xecf6736)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getFeaturedEmojiStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getFeaturedEmojiStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetFeaturedEmojiStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xecf6736: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReportReaction <--
type TLMessagesReportReaction struct {
	ClazzID      uint32         `json:"_id"`
	Peer         InputPeerClazz `json:"peer"`
	Id           int32          `json:"id"`
	ReactionPeer InputPeerClazz `json:"reaction_peer"`
}

func (m *TLMessagesReportReaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReportReaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3f64c076: func() error {
			x.PutClazzID(0x3f64c076)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			_ = m.ReactionPeer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reportReaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reportReaction, layer)
	}
}

// Decode <--
func (m *TLMessagesReportReaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3f64c076: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.ReactionPeer = m3
			m.ReactionPeer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetTopReactions <--
type TLMessagesGetTopReactions struct {
	ClazzID uint32 `json:"_id"`
	Limit   int32  `json:"limit"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetTopReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetTopReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbb8125ba: func() error {
			x.PutClazzID(0xbb8125ba)

			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getTopReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getTopReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetTopReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbb8125ba: func() (err error) {
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetRecentReactions <--
type TLMessagesGetRecentReactions struct {
	ClazzID uint32 `json:"_id"`
	Limit   int32  `json:"limit"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetRecentReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetRecentReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x39461db2: func() error {
			x.PutClazzID(0x39461db2)

			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getRecentReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getRecentReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetRecentReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x39461db2: func() (err error) {
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesClearRecentReactions <--
type TLMessagesClearRecentReactions struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesClearRecentReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesClearRecentReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9dfeefb4: func() error {
			x.PutClazzID(0x9dfeefb4)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_clearRecentReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_clearRecentReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesClearRecentReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9dfeefb4: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetExtendedMedia <--
type TLMessagesGetExtendedMedia struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLMessagesGetExtendedMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetExtendedMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x84f80814: func() error {
			x.PutClazzID(0x84f80814)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getExtendedMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getExtendedMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesGetExtendedMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x84f80814: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetDefaultHistoryTTL <--
type TLMessagesSetDefaultHistoryTTL struct {
	ClazzID uint32 `json:"_id"`
	Period  int32  `json:"period"`
}

func (m *TLMessagesSetDefaultHistoryTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetDefaultHistoryTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9eb51445: func() error {
			x.PutClazzID(0x9eb51445)

			x.PutInt32(m.Period)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setDefaultHistoryTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setDefaultHistoryTTL, layer)
	}
}

// Decode <--
func (m *TLMessagesSetDefaultHistoryTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9eb51445: func() (err error) {
			m.Period, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDefaultHistoryTTL <--
type TLMessagesGetDefaultHistoryTTL struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetDefaultHistoryTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDefaultHistoryTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x658b7188: func() error {
			x.PutClazzID(0x658b7188)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDefaultHistoryTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDefaultHistoryTTL, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDefaultHistoryTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x658b7188: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendBotRequestedPeer <--
type TLMessagesSendBotRequestedPeer struct {
	ClazzID        uint32           `json:"_id"`
	Peer           InputPeerClazz   `json:"peer"`
	MsgId          int32            `json:"msg_id"`
	ButtonId       int32            `json:"button_id"`
	RequestedPeers []InputPeerClazz `json:"requested_peers"`
}

func (m *TLMessagesSendBotRequestedPeer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendBotRequestedPeer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x91b2d060: func() error {
			x.PutClazzID(0x91b2d060)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutInt32(m.ButtonId)

			_ = iface.EncodeObjectList(x, m.RequestedPeers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendBotRequestedPeer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendBotRequestedPeer, layer)
	}
}

// Decode <--
func (m *TLMessagesSendBotRequestedPeer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x91b2d060: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()
			m.ButtonId, err = d.Int32()
			c4, err2 := d.ClazzID()
			if c4 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
				return err2
			}
			l4, err3 := d.Int()
			// v4 := make([]*InputPeer, l4)
			v4 := make([]InputPeerClazz, l4)
			for i := 0; i < l4; i++ {
				// vv := new(InputPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v4[i] = vv
				v4[i], _ = DecodeInputPeerClazz(d)
				_ = err3
			}
			m.RequestedPeers = v4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiGroups <--
type TLMessagesGetEmojiGroups struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetEmojiGroups) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiGroups) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7488ce5b: func() error {
			x.PutClazzID(0x7488ce5b)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiGroups, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiGroups, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiGroups) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7488ce5b: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiStatusGroups <--
type TLMessagesGetEmojiStatusGroups struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetEmojiStatusGroups) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiStatusGroups) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2ecd56cd: func() error {
			x.PutClazzID(0x2ecd56cd)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiStatusGroups, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiStatusGroups, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiStatusGroups) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2ecd56cd: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiProfilePhotoGroups <--
type TLMessagesGetEmojiProfilePhotoGroups struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetEmojiProfilePhotoGroups) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiProfilePhotoGroups) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x21a548f3: func() error {
			x.PutClazzID(0x21a548f3)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiProfilePhotoGroups, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiProfilePhotoGroups, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiProfilePhotoGroups) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x21a548f3: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchCustomEmoji <--
type TLMessagesSearchCustomEmoji struct {
	ClazzID  uint32 `json:"_id"`
	Emoticon string `json:"emoticon"`
	Hash     int64  `json:"hash"`
}

func (m *TLMessagesSearchCustomEmoji) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchCustomEmoji) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2c11c0d7: func() error {
			x.PutClazzID(0x2c11c0d7)

			x.PutString(m.Emoticon)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchCustomEmoji, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchCustomEmoji, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchCustomEmoji) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2c11c0d7: func() (err error) {
			m.Emoticon, err = d.String()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesTogglePeerTranslations <--
type TLMessagesTogglePeerTranslations struct {
	ClazzID  uint32         `json:"_id"`
	Disabled bool           `json:"disabled"`
	Peer     InputPeerClazz `json:"peer"`
}

func (m *TLMessagesTogglePeerTranslations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesTogglePeerTranslations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe47cb579: func() error {
			x.PutClazzID(0xe47cb579)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Disabled == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_togglePeerTranslations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_togglePeerTranslations, layer)
	}
}

// Decode <--
func (m *TLMessagesTogglePeerTranslations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe47cb579: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Disabled = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetBotApp <--
type TLMessagesGetBotApp struct {
	ClazzID uint32           `json:"_id"`
	App     InputBotAppClazz `json:"app"`
	Hash    int64            `json:"hash"`
}

func (m *TLMessagesGetBotApp) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetBotApp) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x34fdc5c3: func() error {
			x.PutClazzID(0x34fdc5c3)

			_ = m.App.Encode(x, layer)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getBotApp, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getBotApp, layer)
	}
}

// Decode <--
func (m *TLMessagesGetBotApp) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x34fdc5c3: func() (err error) {

			// m1 := &InputBotApp{}
			// _ = m1.Decode(d)
			// m.App = m1
			m.App, _ = DecodeInputBotAppClazz(d)

			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestAppWebView <--
type TLMessagesRequestAppWebView struct {
	ClazzID      uint32           `json:"_id"`
	WriteAllowed bool             `json:"write_allowed"`
	Compact      bool             `json:"compact"`
	Fullscreen   bool             `json:"fullscreen"`
	Peer         InputPeerClazz   `json:"peer"`
	App          InputBotAppClazz `json:"app"`
	StartParam   *string          `json:"start_param"`
	ThemeParams  DataJSONClazz    `json:"theme_params"`
	Platform     string           `json:"platform"`
}

func (m *TLMessagesRequestAppWebView) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestAppWebView) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x53618bce: func() error {
			x.PutClazzID(0x53618bce)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.WriteAllowed == true {
					flags |= 1 << 0
				}
				if m.Compact == true {
					flags |= 1 << 7
				}
				if m.Fullscreen == true {
					flags |= 1 << 8
				}

				if m.StartParam != nil {
					flags |= 1 << 1
				}
				if m.ThemeParams != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.App.Encode(x, layer)
			if m.StartParam != nil {
				x.PutString(*m.StartParam)
			}

			if m.ThemeParams != nil {
				_ = m.ThemeParams.Encode(x, layer)
			}

			x.PutString(m.Platform)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestAppWebView, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestAppWebView, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestAppWebView) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x53618bce: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.WriteAllowed = true
			}
			if (flags & (1 << 7)) != 0 {
				m.Compact = true
			}
			if (flags & (1 << 8)) != 0 {
				m.Fullscreen = true
			}

			// m5 := &InputPeer{}
			// _ = m5.Decode(d)
			// m.Peer = m5
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m6 := &InputBotApp{}
			// _ = m6.Decode(d)
			// m.App = m6
			m.App, _ = DecodeInputBotAppClazz(d)

			if (flags & (1 << 1)) != 0 {
				m.StartParam = new(string)
				*m.StartParam, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				// m8 := &DataJSON{}
				// _ = m8.Decode(d)
				// m.ThemeParams = m8
				m.ThemeParams, _ = DecodeDataJSONClazz(d)
			}
			m.Platform, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetChatWallPaper <--
type TLMessagesSetChatWallPaper struct {
	ClazzID   uint32                 `json:"_id"`
	ForBoth   bool                   `json:"for_both"`
	Revert    bool                   `json:"revert"`
	Peer      InputPeerClazz         `json:"peer"`
	Wallpaper InputWallPaperClazz    `json:"wallpaper"`
	Settings  WallPaperSettingsClazz `json:"settings"`
	Id        *int32                 `json:"id"`
}

func (m *TLMessagesSetChatWallPaper) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetChatWallPaper) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8ffacae1: func() error {
			x.PutClazzID(0x8ffacae1)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForBoth == true {
					flags |= 1 << 3
				}
				if m.Revert == true {
					flags |= 1 << 4
				}

				if m.Wallpaper != nil {
					flags |= 1 << 0
				}
				if m.Settings != nil {
					flags |= 1 << 2
				}
				if m.Id != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.Wallpaper != nil {
				_ = m.Wallpaper.Encode(x, layer)
			}

			if m.Settings != nil {
				_ = m.Settings.Encode(x, layer)
			}

			if m.Id != nil {
				x.PutInt32(*m.Id)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setChatWallPaper, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setChatWallPaper, layer)
	}
}

// Decode <--
func (m *TLMessagesSetChatWallPaper) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8ffacae1: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 3)) != 0 {
				m.ForBoth = true
			}
			if (flags & (1 << 4)) != 0 {
				m.Revert = true
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m5 := &InputWallPaper{}
				// _ = m5.Decode(d)
				// m.Wallpaper = m5
				m.Wallpaper, _ = DecodeInputWallPaperClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				// m6 := &WallPaperSettings{}
				// _ = m6.Decode(d)
				// m.Settings = m6
				m.Settings, _ = DecodeWallPaperSettingsClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				m.Id = new(int32)
				*m.Id, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchEmojiStickerSets <--
type TLMessagesSearchEmojiStickerSets struct {
	ClazzID         uint32 `json:"_id"`
	ExcludeFeatured bool   `json:"exclude_featured"`
	Q               string `json:"q"`
	Hash            int64  `json:"hash"`
}

func (m *TLMessagesSearchEmojiStickerSets) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchEmojiStickerSets) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x92b4494c: func() error {
			x.PutClazzID(0x92b4494c)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ExcludeFeatured == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Q)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchEmojiStickerSets, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchEmojiStickerSets, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchEmojiStickerSets) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x92b4494c: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ExcludeFeatured = true
			}
			m.Q, err = d.String()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSavedDialogs <--
type TLMessagesGetSavedDialogs struct {
	ClazzID       uint32         `json:"_id"`
	ExcludePinned bool           `json:"exclude_pinned"`
	ParentPeer    InputPeerClazz `json:"parent_peer"`
	OffsetDate    int32          `json:"offset_date"`
	OffsetId      int32          `json:"offset_id"`
	OffsetPeer    InputPeerClazz `json:"offset_peer"`
	Limit         int32          `json:"limit"`
	Hash          int64          `json:"hash"`
}

func (m *TLMessagesGetSavedDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSavedDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1e91fc99: func() error {
			x.PutClazzID(0x1e91fc99)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ExcludePinned == true {
					flags |= 1 << 0
				}
				if m.ParentPeer != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.ParentPeer != nil {
				_ = m.ParentPeer.Encode(x, layer)
			}

			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.OffsetId)
			_ = m.OffsetPeer.Encode(x, layer)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSavedDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSavedDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSavedDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1e91fc99: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ExcludePinned = true
			}
			if (flags & (1 << 1)) != 0 {
				// m3 := &InputPeer{}
				// _ = m3.Decode(d)
				// m.ParentPeer = m3
				m.ParentPeer, _ = DecodeInputPeerClazz(d)
			}
			m.OffsetDate, err = d.Int32()
			m.OffsetId, err = d.Int32()

			// m6 := &InputPeer{}
			// _ = m6.Decode(d)
			// m.OffsetPeer = m6
			m.OffsetPeer, _ = DecodeInputPeerClazz(d)

			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSavedHistory <--
type TLMessagesGetSavedHistory struct {
	ClazzID    uint32         `json:"_id"`
	ParentPeer InputPeerClazz `json:"parent_peer"`
	Peer       InputPeerClazz `json:"peer"`
	OffsetId   int32          `json:"offset_id"`
	OffsetDate int32          `json:"offset_date"`
	AddOffset  int32          `json:"add_offset"`
	Limit      int32          `json:"limit"`
	MaxId      int32          `json:"max_id"`
	MinId      int32          `json:"min_id"`
	Hash       int64          `json:"hash"`
}

func (m *TLMessagesGetSavedHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSavedHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x998ab009: func() error {
			x.PutClazzID(0x998ab009)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ParentPeer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.ParentPeer != nil {
				_ = m.ParentPeer.Encode(x, layer)
			}

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSavedHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSavedHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSavedHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x998ab009: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputPeer{}
				// _ = m2.Decode(d)
				// m.ParentPeer = m2
				m.ParentPeer, _ = DecodeInputPeerClazz(d)
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.OffsetId, err = d.Int32()
			m.OffsetDate, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteSavedHistory <--
type TLMessagesDeleteSavedHistory struct {
	ClazzID    uint32         `json:"_id"`
	ParentPeer InputPeerClazz `json:"parent_peer"`
	Peer       InputPeerClazz `json:"peer"`
	MaxId      int32          `json:"max_id"`
	MinDate    *int32         `json:"min_date"`
	MaxDate    *int32         `json:"max_date"`
}

func (m *TLMessagesDeleteSavedHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteSavedHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4dc5085f: func() error {
			x.PutClazzID(0x4dc5085f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ParentPeer != nil {
					flags |= 1 << 0
				}

				if m.MinDate != nil {
					flags |= 1 << 2
				}
				if m.MaxDate != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.ParentPeer != nil {
				_ = m.ParentPeer.Encode(x, layer)
			}

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxId)
			if m.MinDate != nil {
				x.PutInt32(*m.MinDate)
			}

			if m.MaxDate != nil {
				x.PutInt32(*m.MaxDate)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteSavedHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteSavedHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteSavedHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4dc5085f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputPeer{}
				// _ = m2.Decode(d)
				// m.ParentPeer = m2
				m.ParentPeer, _ = DecodeInputPeerClazz(d)
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MaxId, err = d.Int32()
			if (flags & (1 << 2)) != 0 {
				m.MinDate = new(int32)
				*m.MinDate, err = d.Int32()
			}
			if (flags & (1 << 3)) != 0 {
				m.MaxDate = new(int32)
				*m.MaxDate, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPinnedSavedDialogs <--
type TLMessagesGetPinnedSavedDialogs struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetPinnedSavedDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPinnedSavedDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd63d94e0: func() error {
			x.PutClazzID(0xd63d94e0)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPinnedSavedDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPinnedSavedDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPinnedSavedDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd63d94e0: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleSavedDialogPin <--
type TLMessagesToggleSavedDialogPin struct {
	ClazzID uint32               `json:"_id"`
	Pinned  bool                 `json:"pinned"`
	Peer    InputDialogPeerClazz `json:"peer"`
}

func (m *TLMessagesToggleSavedDialogPin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleSavedDialogPin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xac81bbde: func() error {
			x.PutClazzID(0xac81bbde)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Pinned == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleSavedDialogPin, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleSavedDialogPin, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleSavedDialogPin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xac81bbde: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Pinned = true
			}

			// m3 := &InputDialogPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputDialogPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReorderPinnedSavedDialogs <--
type TLMessagesReorderPinnedSavedDialogs struct {
	ClazzID uint32                 `json:"_id"`
	Force   bool                   `json:"force"`
	Order   []InputDialogPeerClazz `json:"order"`
}

func (m *TLMessagesReorderPinnedSavedDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReorderPinnedSavedDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8b716587: func() error {
			x.PutClazzID(0x8b716587)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Force == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			_ = iface.EncodeObjectList(x, m.Order, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reorderPinnedSavedDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reorderPinnedSavedDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesReorderPinnedSavedDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8b716587: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Force = true
			}
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			// v3 := make([]*InputDialogPeer, l3)
			v3 := make([]InputDialogPeerClazz, l3)
			for i := 0; i < l3; i++ {
				// vv := new(InputDialogPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v3[i] = vv
				v3[i], _ = DecodeInputDialogPeerClazz(d)
				_ = err3
			}
			m.Order = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSavedReactionTags <--
type TLMessagesGetSavedReactionTags struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Hash    int64          `json:"hash"`
}

func (m *TLMessagesGetSavedReactionTags) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSavedReactionTags) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3637e05b: func() error {
			x.PutClazzID(0x3637e05b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Peer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSavedReactionTags, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSavedReactionTags, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSavedReactionTags) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3637e05b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputPeer{}
				// _ = m2.Decode(d)
				// m.Peer = m2
				m.Peer, _ = DecodeInputPeerClazz(d)
			}
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUpdateSavedReactionTag <--
type TLMessagesUpdateSavedReactionTag struct {
	ClazzID  uint32        `json:"_id"`
	Reaction ReactionClazz `json:"reaction"`
	Title    *string       `json:"title"`
}

func (m *TLMessagesUpdateSavedReactionTag) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUpdateSavedReactionTag) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x60297dec: func() error {
			x.PutClazzID(0x60297dec)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Title != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Reaction.Encode(x, layer)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_updateSavedReactionTag, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_updateSavedReactionTag, layer)
	}
}

// Decode <--
func (m *TLMessagesUpdateSavedReactionTag) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x60297dec: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &Reaction{}
			// _ = m2.Decode(d)
			// m.Reaction = m2
			m.Reaction, _ = DecodeReactionClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDefaultTagReactions <--
type TLMessagesGetDefaultTagReactions struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetDefaultTagReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDefaultTagReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbdf93428: func() error {
			x.PutClazzID(0xbdf93428)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDefaultTagReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDefaultTagReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDefaultTagReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbdf93428: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetOutboxReadDate <--
type TLMessagesGetOutboxReadDate struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   int32          `json:"msg_id"`
}

func (m *TLMessagesGetOutboxReadDate) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetOutboxReadDate) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8c4bfe5d: func() error {
			x.PutClazzID(0x8c4bfe5d)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getOutboxReadDate, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getOutboxReadDate, layer)
	}
}

// Decode <--
func (m *TLMessagesGetOutboxReadDate) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8c4bfe5d: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetQuickReplies <--
type TLMessagesGetQuickReplies struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetQuickReplies) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetQuickReplies) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd483f2a8: func() error {
			x.PutClazzID(0xd483f2a8)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getQuickReplies, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getQuickReplies, layer)
	}
}

// Decode <--
func (m *TLMessagesGetQuickReplies) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd483f2a8: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReorderQuickReplies <--
type TLMessagesReorderQuickReplies struct {
	ClazzID uint32  `json:"_id"`
	Order   []int32 `json:"order"`
}

func (m *TLMessagesReorderQuickReplies) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReorderQuickReplies) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x60331907: func() error {
			x.PutClazzID(0x60331907)

			iface.EncodeInt32List(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reorderQuickReplies, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reorderQuickReplies, layer)
	}
}

// Decode <--
func (m *TLMessagesReorderQuickReplies) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x60331907: func() (err error) {

			m.Order, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCheckQuickReplyShortcut <--
type TLMessagesCheckQuickReplyShortcut struct {
	ClazzID  uint32 `json:"_id"`
	Shortcut string `json:"shortcut"`
}

func (m *TLMessagesCheckQuickReplyShortcut) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCheckQuickReplyShortcut) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf1d0fbd3: func() error {
			x.PutClazzID(0xf1d0fbd3)

			x.PutString(m.Shortcut)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_checkQuickReplyShortcut, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_checkQuickReplyShortcut, layer)
	}
}

// Decode <--
func (m *TLMessagesCheckQuickReplyShortcut) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf1d0fbd3: func() (err error) {
			m.Shortcut, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditQuickReplyShortcut <--
type TLMessagesEditQuickReplyShortcut struct {
	ClazzID    uint32 `json:"_id"`
	ShortcutId int32  `json:"shortcut_id"`
	Shortcut   string `json:"shortcut"`
}

func (m *TLMessagesEditQuickReplyShortcut) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditQuickReplyShortcut) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5c003cef: func() error {
			x.PutClazzID(0x5c003cef)

			x.PutInt32(m.ShortcutId)
			x.PutString(m.Shortcut)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editQuickReplyShortcut, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editQuickReplyShortcut, layer)
	}
}

// Decode <--
func (m *TLMessagesEditQuickReplyShortcut) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5c003cef: func() (err error) {
			m.ShortcutId, err = d.Int32()
			m.Shortcut, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteQuickReplyShortcut <--
type TLMessagesDeleteQuickReplyShortcut struct {
	ClazzID    uint32 `json:"_id"`
	ShortcutId int32  `json:"shortcut_id"`
}

func (m *TLMessagesDeleteQuickReplyShortcut) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteQuickReplyShortcut) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3cc04740: func() error {
			x.PutClazzID(0x3cc04740)

			x.PutInt32(m.ShortcutId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteQuickReplyShortcut, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteQuickReplyShortcut, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteQuickReplyShortcut) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3cc04740: func() (err error) {
			m.ShortcutId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetQuickReplyMessages <--
type TLMessagesGetQuickReplyMessages struct {
	ClazzID    uint32  `json:"_id"`
	ShortcutId int32   `json:"shortcut_id"`
	Id         []int32 `json:"id"`
	Hash       int64   `json:"hash"`
}

func (m *TLMessagesGetQuickReplyMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetQuickReplyMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x94a495c3: func() error {
			x.PutClazzID(0x94a495c3)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Id != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.ShortcutId)
			if m.Id != nil {
				iface.EncodeInt32List(x, m.Id)
			}
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getQuickReplyMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getQuickReplyMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesGetQuickReplyMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x94a495c3: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.ShortcutId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Id, err = iface.DecodeInt32List(d)
			}
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendQuickReplyMessages <--
type TLMessagesSendQuickReplyMessages struct {
	ClazzID    uint32         `json:"_id"`
	Peer       InputPeerClazz `json:"peer"`
	ShortcutId int32          `json:"shortcut_id"`
	Id         []int32        `json:"id"`
	RandomId   []int64        `json:"random_id"`
}

func (m *TLMessagesSendQuickReplyMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendQuickReplyMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6c750de1: func() error {
			x.PutClazzID(0x6c750de1)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.ShortcutId)

			iface.EncodeInt32List(x, m.Id)

			iface.EncodeInt64List(x, m.RandomId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendQuickReplyMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendQuickReplyMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesSendQuickReplyMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6c750de1: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.ShortcutId, err = d.Int32()

			m.Id, err = iface.DecodeInt32List(d)

			m.RandomId, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteQuickReplyMessages <--
type TLMessagesDeleteQuickReplyMessages struct {
	ClazzID    uint32  `json:"_id"`
	ShortcutId int32   `json:"shortcut_id"`
	Id         []int32 `json:"id"`
}

func (m *TLMessagesDeleteQuickReplyMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteQuickReplyMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe105e910: func() error {
			x.PutClazzID(0xe105e910)

			x.PutInt32(m.ShortcutId)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteQuickReplyMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteQuickReplyMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteQuickReplyMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe105e910: func() (err error) {
			m.ShortcutId, err = d.Int32()

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleDialogFilterTags <--
type TLMessagesToggleDialogFilterTags struct {
	ClazzID uint32    `json:"_id"`
	Enabled BoolClazz `json:"enabled"`
}

func (m *TLMessagesToggleDialogFilterTags) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleDialogFilterTags) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfd2dda49: func() error {
			x.PutClazzID(0xfd2dda49)

			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleDialogFilterTags, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleDialogFilterTags, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleDialogFilterTags) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfd2dda49: func() (err error) {

			// m1 := &Bool{}
			// _ = m1.Decode(d)
			// m.Enabled = m1
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMyStickers <--
type TLMessagesGetMyStickers struct {
	ClazzID  uint32 `json:"_id"`
	OffsetId int64  `json:"offset_id"`
	Limit    int32  `json:"limit"`
}

func (m *TLMessagesGetMyStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMyStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd0b5e1fc: func() error {
			x.PutClazzID(0xd0b5e1fc)

			x.PutInt64(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMyStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMyStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMyStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd0b5e1fc: func() (err error) {
			m.OffsetId, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiStickerGroups <--
type TLMessagesGetEmojiStickerGroups struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetEmojiStickerGroups) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiStickerGroups) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1dd840f5: func() error {
			x.PutClazzID(0x1dd840f5)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiStickerGroups, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiStickerGroups, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiStickerGroups) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1dd840f5: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAvailableEffects <--
type TLMessagesGetAvailableEffects struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetAvailableEffects) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAvailableEffects) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdea20a39: func() error {
			x.PutClazzID(0xdea20a39)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAvailableEffects, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAvailableEffects, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAvailableEffects) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdea20a39: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditFactCheck <--
type TLMessagesEditFactCheck struct {
	ClazzID uint32                `json:"_id"`
	Peer    InputPeerClazz        `json:"peer"`
	MsgId   int32                 `json:"msg_id"`
	Text    TextWithEntitiesClazz `json:"text"`
}

func (m *TLMessagesEditFactCheck) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditFactCheck) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x589ee75: func() error {
			x.PutClazzID(0x589ee75)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			_ = m.Text.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editFactCheck, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editFactCheck, layer)
	}
}

// Decode <--
func (m *TLMessagesEditFactCheck) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x589ee75: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			// m3 := &TextWithEntities{}
			// _ = m3.Decode(d)
			// m.Text = m3
			m.Text, _ = DecodeTextWithEntitiesClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteFactCheck <--
type TLMessagesDeleteFactCheck struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   int32          `json:"msg_id"`
}

func (m *TLMessagesDeleteFactCheck) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteFactCheck) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd1da940c: func() error {
			x.PutClazzID(0xd1da940c)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteFactCheck, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteFactCheck, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteFactCheck) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd1da940c: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetFactCheck <--
type TLMessagesGetFactCheck struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   []int32        `json:"msg_id"`
}

func (m *TLMessagesGetFactCheck) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetFactCheck) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb9cdc5ee: func() error {
			x.PutClazzID(0xb9cdc5ee)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getFactCheck, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getFactCheck, layer)
	}
}

// Decode <--
func (m *TLMessagesGetFactCheck) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb9cdc5ee: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestMainWebView <--
type TLMessagesRequestMainWebView struct {
	ClazzID     uint32         `json:"_id"`
	Compact     bool           `json:"compact"`
	Fullscreen  bool           `json:"fullscreen"`
	Peer        InputPeerClazz `json:"peer"`
	Bot         InputUserClazz `json:"bot"`
	StartParam  *string        `json:"start_param"`
	ThemeParams DataJSONClazz  `json:"theme_params"`
	Platform    string         `json:"platform"`
}

func (m *TLMessagesRequestMainWebView) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestMainWebView) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc9e01e7b: func() error {
			x.PutClazzID(0xc9e01e7b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Compact == true {
					flags |= 1 << 7
				}
				if m.Fullscreen == true {
					flags |= 1 << 8
				}

				if m.StartParam != nil {
					flags |= 1 << 1
				}
				if m.ThemeParams != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.Bot.Encode(x, layer)
			if m.StartParam != nil {
				x.PutString(*m.StartParam)
			}

			if m.ThemeParams != nil {
				_ = m.ThemeParams.Encode(x, layer)
			}

			x.PutString(m.Platform)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestMainWebView, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestMainWebView, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestMainWebView) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc9e01e7b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 7)) != 0 {
				m.Compact = true
			}
			if (flags & (1 << 8)) != 0 {
				m.Fullscreen = true
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m5 := &InputUser{}
			// _ = m5.Decode(d)
			// m.Bot = m5
			m.Bot, _ = DecodeInputUserClazz(d)

			if (flags & (1 << 1)) != 0 {
				m.StartParam = new(string)
				*m.StartParam, err = d.String()
			}

			if (flags & (1 << 0)) != 0 {
				// m7 := &DataJSON{}
				// _ = m7.Decode(d)
				// m.ThemeParams = m7
				m.ThemeParams, _ = DecodeDataJSONClazz(d)
			}
			m.Platform, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendPaidReaction <--
type TLMessagesSendPaidReaction struct {
	ClazzID  uint32                   `json:"_id"`
	Peer     InputPeerClazz           `json:"peer"`
	MsgId    int32                    `json:"msg_id"`
	Count    int32                    `json:"count"`
	RandomId int64                    `json:"random_id"`
	Private  PaidReactionPrivacyClazz `json:"private"`
}

func (m *TLMessagesSendPaidReaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendPaidReaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x58bbcb50: func() error {
			x.PutClazzID(0x58bbcb50)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Private != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutInt32(m.Count)
			x.PutInt64(m.RandomId)
			if m.Private != nil {
				_ = m.Private.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendPaidReaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendPaidReaction, layer)
	}
}

// Decode <--
func (m *TLMessagesSendPaidReaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x58bbcb50: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()
			m.Count, err = d.Int32()
			m.RandomId, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				// m6 := &PaidReactionPrivacy{}
				// _ = m6.Decode(d)
				// m.Private = m6
				m.Private, _ = DecodePaidReactionPrivacyClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesTogglePaidReactionPrivacy <--
type TLMessagesTogglePaidReactionPrivacy struct {
	ClazzID uint32                   `json:"_id"`
	Peer    InputPeerClazz           `json:"peer"`
	MsgId   int32                    `json:"msg_id"`
	Private PaidReactionPrivacyClazz `json:"private"`
}

func (m *TLMessagesTogglePaidReactionPrivacy) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesTogglePaidReactionPrivacy) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x435885b5: func() error {
			x.PutClazzID(0x435885b5)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			_ = m.Private.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_togglePaidReactionPrivacy, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_togglePaidReactionPrivacy, layer)
	}
}

// Decode <--
func (m *TLMessagesTogglePaidReactionPrivacy) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x435885b5: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			// m3 := &PaidReactionPrivacy{}
			// _ = m3.Decode(d)
			// m.Private = m3
			m.Private, _ = DecodePaidReactionPrivacyClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPaidReactionPrivacy <--
type TLMessagesGetPaidReactionPrivacy struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetPaidReactionPrivacy) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPaidReactionPrivacy) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x472455aa: func() error {
			x.PutClazzID(0x472455aa)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPaidReactionPrivacy, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPaidReactionPrivacy, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPaidReactionPrivacy) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x472455aa: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesViewSponsoredMessage <--
type TLMessagesViewSponsoredMessage struct {
	ClazzID  uint32 `json:"_id"`
	RandomId []byte `json:"random_id"`
}

func (m *TLMessagesViewSponsoredMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesViewSponsoredMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x269e3643: func() error {
			x.PutClazzID(0x269e3643)

			x.PutBytes(m.RandomId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_viewSponsoredMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_viewSponsoredMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesViewSponsoredMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x269e3643: func() (err error) {
			m.RandomId, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesClickSponsoredMessage <--
type TLMessagesClickSponsoredMessage struct {
	ClazzID    uint32 `json:"_id"`
	Media      bool   `json:"media"`
	Fullscreen bool   `json:"fullscreen"`
	RandomId   []byte `json:"random_id"`
}

func (m *TLMessagesClickSponsoredMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesClickSponsoredMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8235057e: func() error {
			x.PutClazzID(0x8235057e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Media == true {
					flags |= 1 << 0
				}
				if m.Fullscreen == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutBytes(m.RandomId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_clickSponsoredMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_clickSponsoredMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesClickSponsoredMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8235057e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Media = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Fullscreen = true
			}
			m.RandomId, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReportSponsoredMessage <--
type TLMessagesReportSponsoredMessage struct {
	ClazzID  uint32 `json:"_id"`
	RandomId []byte `json:"random_id"`
	Option   []byte `json:"option"`
}

func (m *TLMessagesReportSponsoredMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReportSponsoredMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x12cbf0c4: func() error {
			x.PutClazzID(0x12cbf0c4)

			x.PutBytes(m.RandomId)
			x.PutBytes(m.Option)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reportSponsoredMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reportSponsoredMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesReportSponsoredMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x12cbf0c4: func() (err error) {
			m.RandomId, err = d.Bytes()
			m.Option, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSponsoredMessages <--
type TLMessagesGetSponsoredMessages struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   *int32         `json:"msg_id"`
}

func (m *TLMessagesGetSponsoredMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSponsoredMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3d6ce850: func() error {
			x.PutClazzID(0x3d6ce850)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.MsgId != nil {
				x.PutInt32(*m.MsgId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSponsoredMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSponsoredMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSponsoredMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3d6ce850: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.MsgId = new(int32)
				*m.MsgId, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSavePreparedInlineMessage <--
type TLMessagesSavePreparedInlineMessage struct {
	ClazzID   uint32                     `json:"_id"`
	Result    InputBotInlineResultClazz  `json:"result"`
	UserId    InputUserClazz             `json:"user_id"`
	PeerTypes []InlineQueryPeerTypeClazz `json:"peer_types"`
}

func (m *TLMessagesSavePreparedInlineMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSavePreparedInlineMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf21f7f2f: func() error {
			x.PutClazzID(0xf21f7f2f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.PeerTypes != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Result.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)
			if m.PeerTypes != nil {
				_ = iface.EncodeObjectList(x, m.PeerTypes, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_savePreparedInlineMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_savePreparedInlineMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesSavePreparedInlineMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf21f7f2f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputBotInlineResult{}
			// _ = m2.Decode(d)
			// m.Result = m2
			m.Result, _ = DecodeInputBotInlineResultClazz(d)

			// m3 := &InputUser{}
			// _ = m3.Decode(d)
			// m.UserId = m3
			m.UserId, _ = DecodeInputUserClazz(d)

			if (flags & (1 << 0)) != 0 {
				c4, err2 := d.ClazzID()
				if c4 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
					return err2
				}
				l4, err3 := d.Int()
				// v4 := make([]*InlineQueryPeerType, l4)
				v4 := make([]InlineQueryPeerTypeClazz, l4)
				for i := 0; i < l4; i++ {
					// vv := new(InlineQueryPeerType)
					// err3 = vv.Decode(d)
					// _ = err3
					// v4[i] = vv
					v4[i], _ = DecodeInlineQueryPeerTypeClazz(d)
					_ = err3
				}
				m.PeerTypes = v4
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPreparedInlineMessage <--
type TLMessagesGetPreparedInlineMessage struct {
	ClazzID uint32         `json:"_id"`
	Bot     InputUserClazz `json:"bot"`
	Id      string         `json:"id"`
}

func (m *TLMessagesGetPreparedInlineMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPreparedInlineMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x857ebdb8: func() error {
			x.PutClazzID(0x857ebdb8)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPreparedInlineMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPreparedInlineMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPreparedInlineMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x857ebdb8: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.Id, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchStickers <--
type TLMessagesSearchStickers struct {
	ClazzID  uint32   `json:"_id"`
	Emojis   bool     `json:"emojis"`
	Q        string   `json:"q"`
	Emoticon string   `json:"emoticon"`
	LangCode []string `json:"lang_code"`
	Offset   int32    `json:"offset"`
	Limit    int32    `json:"limit"`
	Hash     int64    `json:"hash"`
}

func (m *TLMessagesSearchStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x29b1c66a: func() error {
			x.PutClazzID(0x29b1c66a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Emojis == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Q)
			x.PutString(m.Emoticon)

			iface.EncodeStringList(x, m.LangCode)

			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x29b1c66a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Emojis = true
			}
			m.Q, err = d.String()
			m.Emoticon, err = d.String()

			m.LangCode, err = iface.DecodeStringList(d)

			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReportMessagesDelivery <--
type TLMessagesReportMessagesDelivery struct {
	ClazzID uint32         `json:"_id"`
	Push    bool           `json:"push"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLMessagesReportMessagesDelivery) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReportMessagesDelivery) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5a6d7395: func() error {
			x.PutClazzID(0x5a6d7395)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Push == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reportMessagesDelivery, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reportMessagesDelivery, layer)
	}
}

// Decode <--
func (m *TLMessagesReportMessagesDelivery) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5a6d7395: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Push = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSavedDialogsByID <--
type TLMessagesGetSavedDialogsByID struct {
	ClazzID    uint32           `json:"_id"`
	ParentPeer InputPeerClazz   `json:"parent_peer"`
	Ids        []InputPeerClazz `json:"ids"`
}

func (m *TLMessagesGetSavedDialogsByID) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSavedDialogsByID) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6f6f9c96: func() error {
			x.PutClazzID(0x6f6f9c96)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ParentPeer != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.ParentPeer != nil {
				_ = m.ParentPeer.Encode(x, layer)
			}

			_ = iface.EncodeObjectList(x, m.Ids, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSavedDialogsByID, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSavedDialogsByID, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSavedDialogsByID) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6f6f9c96: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				// m2 := &InputPeer{}
				// _ = m2.Decode(d)
				// m.ParentPeer = m2
				m.ParentPeer, _ = DecodeInputPeerClazz(d)
			}
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			// v3 := make([]*InputPeer, l3)
			v3 := make([]InputPeerClazz, l3)
			for i := 0; i < l3; i++ {
				// vv := new(InputPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v3[i] = vv
				v3[i], _ = DecodeInputPeerClazz(d)
				_ = err3
			}
			m.Ids = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadSavedHistory <--
type TLMessagesReadSavedHistory struct {
	ClazzID    uint32         `json:"_id"`
	ParentPeer InputPeerClazz `json:"parent_peer"`
	Peer       InputPeerClazz `json:"peer"`
	MaxId      int32          `json:"max_id"`
}

func (m *TLMessagesReadSavedHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadSavedHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xba4a3b5b: func() error {
			x.PutClazzID(0xba4a3b5b)

			_ = m.ParentPeer.Encode(x, layer)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readSavedHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readSavedHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesReadSavedHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xba4a3b5b: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.ParentPeer = m1
			m.ParentPeer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleTodoCompleted <--
type TLMessagesToggleTodoCompleted struct {
	ClazzID     uint32         `json:"_id"`
	Peer        InputPeerClazz `json:"peer"`
	MsgId       int32          `json:"msg_id"`
	Completed   []int32        `json:"completed"`
	Incompleted []int32        `json:"incompleted"`
}

func (m *TLMessagesToggleTodoCompleted) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleTodoCompleted) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd3e03124: func() error {
			x.PutClazzID(0xd3e03124)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			iface.EncodeInt32List(x, m.Completed)

			iface.EncodeInt32List(x, m.Incompleted)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleTodoCompleted, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleTodoCompleted, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleTodoCompleted) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd3e03124: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			m.Completed, err = iface.DecodeInt32List(d)

			m.Incompleted, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesAppendTodoList <--
type TLMessagesAppendTodoList struct {
	ClazzID uint32          `json:"_id"`
	Peer    InputPeerClazz  `json:"peer"`
	MsgId   int32           `json:"msg_id"`
	List    []TodoItemClazz `json:"list"`
}

func (m *TLMessagesAppendTodoList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesAppendTodoList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x21a61057: func() error {
			x.PutClazzID(0x21a61057)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			_ = iface.EncodeObjectList(x, m.List, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_appendTodoList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_appendTodoList, layer)
	}
}

// Decode <--
func (m *TLMessagesAppendTodoList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x21a61057: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			// v3 := make([]*TodoItem, l3)
			v3 := make([]TodoItemClazz, l3)
			for i := 0; i < l3; i++ {
				// vv := new(TodoItem)
				// err3 = vv.Decode(d)
				// _ = err3
				// v3[i] = vv
				v3[i], _ = DecodeTodoItemClazz(d)
				_ = err3
			}
			m.List = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleSuggestedPostApproval <--
type TLMessagesToggleSuggestedPostApproval struct {
	ClazzID       uint32         `json:"_id"`
	Reject        bool           `json:"reject"`
	Peer          InputPeerClazz `json:"peer"`
	MsgId         int32          `json:"msg_id"`
	ScheduleDate  *int32         `json:"schedule_date"`
	RejectComment *string        `json:"reject_comment"`
}

func (m *TLMessagesToggleSuggestedPostApproval) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleSuggestedPostApproval) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8107455c: func() error {
			x.PutClazzID(0x8107455c)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Reject == true {
					flags |= 1 << 1
				}

				if m.ScheduleDate != nil {
					flags |= 1 << 0
				}
				if m.RejectComment != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.RejectComment != nil {
				x.PutString(*m.RejectComment)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleSuggestedPostApproval, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleSuggestedPostApproval, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleSuggestedPostApproval) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8107455c: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Reject = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				m.RejectComment = new(string)
				*m.RejectComment, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetForumTopics <--
type TLMessagesGetForumTopics struct {
	ClazzID     uint32         `json:"_id"`
	Peer        InputPeerClazz `json:"peer"`
	Q           *string        `json:"q"`
	OffsetDate  int32          `json:"offset_date"`
	OffsetId    int32          `json:"offset_id"`
	OffsetTopic int32          `json:"offset_topic"`
	Limit       int32          `json:"limit"`
}

func (m *TLMessagesGetForumTopics) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetForumTopics) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3ba47bff: func() error {
			x.PutClazzID(0x3ba47bff)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Q != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.Q != nil {
				x.PutString(*m.Q)
			}

			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.OffsetTopic)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getForumTopics, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getForumTopics, layer)
	}
}

// Decode <--
func (m *TLMessagesGetForumTopics) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3ba47bff: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.Q = new(string)
				*m.Q, err = d.String()
			}

			m.OffsetDate, err = d.Int32()
			m.OffsetId, err = d.Int32()
			m.OffsetTopic, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetForumTopicsByID <--
type TLMessagesGetForumTopicsByID struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Topics  []int32        `json:"topics"`
}

func (m *TLMessagesGetForumTopicsByID) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetForumTopicsByID) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaf0a4a08: func() error {
			x.PutClazzID(0xaf0a4a08)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Topics)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getForumTopicsByID, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getForumTopicsByID, layer)
	}
}

// Decode <--
func (m *TLMessagesGetForumTopicsByID) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaf0a4a08: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Topics, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditForumTopic <--
type TLMessagesEditForumTopic struct {
	ClazzID     uint32         `json:"_id"`
	Peer        InputPeerClazz `json:"peer"`
	TopicId     int32          `json:"topic_id"`
	Title       *string        `json:"title"`
	IconEmojiId *int64         `json:"icon_emoji_id"`
	Closed      BoolClazz      `json:"closed"`
	Hidden      BoolClazz      `json:"hidden"`
}

func (m *TLMessagesEditForumTopic) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditForumTopic) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcecc1134: func() error {
			x.PutClazzID(0xcecc1134)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Title != nil {
					flags |= 1 << 0
				}
				if m.IconEmojiId != nil {
					flags |= 1 << 1
				}
				if m.Closed != nil {
					flags |= 1 << 2
				}
				if m.Hidden != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.TopicId)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.IconEmojiId != nil {
				x.PutInt64(*m.IconEmojiId)
			}

			if m.Closed != nil {
				_ = m.Closed.Encode(x, layer)
			}

			if m.Hidden != nil {
				_ = m.Hidden.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editForumTopic, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editForumTopic, layer)
	}
}

// Decode <--
func (m *TLMessagesEditForumTopic) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcecc1134: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.TopicId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.IconEmojiId = new(int64)
				*m.IconEmojiId, err = d.Int64()
			}

			if (flags & (1 << 2)) != 0 {
				// m6 := &Bool{}
				// _ = m6.Decode(d)
				// m.Closed = m6
				m.Closed, _ = DecodeBoolClazz(d)
			}
			if (flags & (1 << 3)) != 0 {
				// m7 := &Bool{}
				// _ = m7.Decode(d)
				// m.Hidden = m7
				m.Hidden, _ = DecodeBoolClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUpdatePinnedForumTopic <--
type TLMessagesUpdatePinnedForumTopic struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	TopicId int32          `json:"topic_id"`
	Pinned  BoolClazz      `json:"pinned"`
}

func (m *TLMessagesUpdatePinnedForumTopic) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUpdatePinnedForumTopic) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x175df251: func() error {
			x.PutClazzID(0x175df251)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.TopicId)
			_ = m.Pinned.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_updatePinnedForumTopic, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_updatePinnedForumTopic, layer)
	}
}

// Decode <--
func (m *TLMessagesUpdatePinnedForumTopic) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x175df251: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.TopicId, err = d.Int32()

			// m3 := &Bool{}
			// _ = m3.Decode(d)
			// m.Pinned = m3
			m.Pinned, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReorderPinnedForumTopics <--
type TLMessagesReorderPinnedForumTopics struct {
	ClazzID uint32         `json:"_id"`
	Force   bool           `json:"force"`
	Peer    InputPeerClazz `json:"peer"`
	Order   []int32        `json:"order"`
}

func (m *TLMessagesReorderPinnedForumTopics) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReorderPinnedForumTopics) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe7841f0: func() error {
			x.PutClazzID(0xe7841f0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Force == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reorderPinnedForumTopics, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reorderPinnedForumTopics, layer)
	}
}

// Decode <--
func (m *TLMessagesReorderPinnedForumTopics) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe7841f0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Force = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Order, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCreateForumTopic <--
type TLMessagesCreateForumTopic struct {
	ClazzID      uint32         `json:"_id"`
	TitleMissing bool           `json:"title_missing"`
	Peer         InputPeerClazz `json:"peer"`
	Title        string         `json:"title"`
	IconColor    *int32         `json:"icon_color"`
	IconEmojiId  *int64         `json:"icon_emoji_id"`
	RandomId     int64          `json:"random_id"`
	SendAs       InputPeerClazz `json:"send_as"`
}

func (m *TLMessagesCreateForumTopic) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCreateForumTopic) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2f98c3d5: func() error {
			x.PutClazzID(0x2f98c3d5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TitleMissing == true {
					flags |= 1 << 4
				}

				if m.IconColor != nil {
					flags |= 1 << 0
				}
				if m.IconEmojiId != nil {
					flags |= 1 << 3
				}

				if m.SendAs != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Title)
			if m.IconColor != nil {
				x.PutInt32(*m.IconColor)
			}

			if m.IconEmojiId != nil {
				x.PutInt64(*m.IconEmojiId)
			}

			x.PutInt64(m.RandomId)
			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_createForumTopic, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_createForumTopic, layer)
	}
}

// Decode <--
func (m *TLMessagesCreateForumTopic) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2f98c3d5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 4)) != 0 {
				m.TitleMissing = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Title, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.IconColor = new(int32)
				*m.IconColor, err = d.Int32()
			}
			if (flags & (1 << 3)) != 0 {
				m.IconEmojiId = new(int64)
				*m.IconEmojiId, err = d.Int64()
			}

			m.RandomId, err = d.Int64()
			if (flags & (1 << 2)) != 0 {
				// m8 := &InputPeer{}
				// _ = m8.Decode(d)
				// m.SendAs = m8
				m.SendAs, _ = DecodeInputPeerClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteTopicHistory <--
type TLMessagesDeleteTopicHistory struct {
	ClazzID  uint32         `json:"_id"`
	Peer     InputPeerClazz `json:"peer"`
	TopMsgId int32          `json:"top_msg_id"`
}

func (m *TLMessagesDeleteTopicHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteTopicHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd2816f10: func() error {
			x.PutClazzID(0xd2816f10)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.TopMsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteTopicHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteTopicHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteTopicHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd2816f10: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.TopMsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUpdatesGetState <--
type TLUpdatesGetState struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLUpdatesGetState) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUpdatesGetState) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xedd4882a: func() error {
			x.PutClazzID(0xedd4882a)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_updates_getState, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_updates_getState, layer)
	}
}

// Decode <--
func (m *TLUpdatesGetState) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xedd4882a: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUpdatesGetDifference <--
type TLUpdatesGetDifference struct {
	ClazzID       uint32 `json:"_id"`
	Pts           int32  `json:"pts"`
	PtsLimit      *int32 `json:"pts_limit"`
	PtsTotalLimit *int32 `json:"pts_total_limit"`
	Date          int32  `json:"date"`
	Qts           int32  `json:"qts"`
	QtsLimit      *int32 `json:"qts_limit"`
}

func (m *TLUpdatesGetDifference) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUpdatesGetDifference) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x19c2f763: func() error {
			x.PutClazzID(0x19c2f763)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.PtsLimit != nil {
					flags |= 1 << 1
				}
				if m.PtsTotalLimit != nil {
					flags |= 1 << 0
				}

				if m.QtsLimit != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.Pts)
			if m.PtsLimit != nil {
				x.PutInt32(*m.PtsLimit)
			}

			if m.PtsTotalLimit != nil {
				x.PutInt32(*m.PtsTotalLimit)
			}

			x.PutInt32(m.Date)
			x.PutInt32(m.Qts)
			if m.QtsLimit != nil {
				x.PutInt32(*m.QtsLimit)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_updates_getDifference, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_updates_getDifference, layer)
	}
}

// Decode <--
func (m *TLUpdatesGetDifference) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x19c2f763: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Pts, err = d.Int32()
			if (flags & (1 << 1)) != 0 {
				m.PtsLimit = new(int32)
				*m.PtsLimit, err = d.Int32()
			}
			if (flags & (1 << 0)) != 0 {
				m.PtsTotalLimit = new(int32)
				*m.PtsTotalLimit, err = d.Int32()
			}
			m.Date, err = d.Int32()
			m.Qts, err = d.Int32()
			if (flags & (1 << 2)) != 0 {
				m.QtsLimit = new(int32)
				*m.QtsLimit, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUpdatesGetChannelDifference <--
type TLUpdatesGetChannelDifference struct {
	ClazzID uint32                     `json:"_id"`
	Force   bool                       `json:"force"`
	Channel InputChannelClazz          `json:"channel"`
	Filter  ChannelMessagesFilterClazz `json:"filter"`
	Pts     int32                      `json:"pts"`
	Limit   int32                      `json:"limit"`
}

func (m *TLUpdatesGetChannelDifference) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUpdatesGetChannelDifference) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3173d78: func() error {
			x.PutClazzID(0x3173d78)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Force == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.Pts)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_updates_getChannelDifference, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_updates_getChannelDifference, layer)
	}
}

// Decode <--
func (m *TLUpdatesGetChannelDifference) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3173d78: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Force = true
			}

			// m3 := &InputChannel{}
			// _ = m3.Decode(d)
			// m.Channel = m3
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m4 := &ChannelMessagesFilter{}
			// _ = m4.Decode(d)
			// m.Filter = m4
			m.Filter, _ = DecodeChannelMessagesFilterClazz(d)

			m.Pts, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhotosUpdateProfilePhoto <--
type TLPhotosUpdateProfilePhoto struct {
	ClazzID  uint32          `json:"_id"`
	Fallback bool            `json:"fallback"`
	Bot      InputUserClazz  `json:"bot"`
	Id       InputPhotoClazz `json:"id"`
}

func (m *TLPhotosUpdateProfilePhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhotosUpdateProfilePhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9e82039: func() error {
			x.PutClazzID(0x9e82039)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Fallback == true {
					flags |= 1 << 0
				}
				if m.Bot != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Bot != nil {
				_ = m.Bot.Encode(x, layer)
			}

			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_photos_updateProfilePhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_photos_updateProfilePhoto, layer)
	}
}

// Decode <--
func (m *TLPhotosUpdateProfilePhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9e82039: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Fallback = true
			}
			if (flags & (1 << 1)) != 0 {
				// m3 := &InputUser{}
				// _ = m3.Decode(d)
				// m.Bot = m3
				m.Bot, _ = DecodeInputUserClazz(d)
			}

			// m4 := &InputPhoto{}
			// _ = m4.Decode(d)
			// m.Id = m4
			m.Id, _ = DecodeInputPhotoClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhotosUploadProfilePhoto <--
type TLPhotosUploadProfilePhoto struct {
	ClazzID          uint32         `json:"_id"`
	Fallback         bool           `json:"fallback"`
	Bot              InputUserClazz `json:"bot"`
	File             InputFileClazz `json:"file"`
	Video            InputFileClazz `json:"video"`
	VideoStartTs     *float64       `json:"video_start_ts"`
	VideoEmojiMarkup VideoSizeClazz `json:"video_emoji_markup"`
}

func (m *TLPhotosUploadProfilePhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhotosUploadProfilePhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x388a3b5: func() error {
			x.PutClazzID(0x388a3b5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Fallback == true {
					flags |= 1 << 3
				}
				if m.Bot != nil {
					flags |= 1 << 5
				}
				if m.File != nil {
					flags |= 1 << 0
				}
				if m.Video != nil {
					flags |= 1 << 1
				}
				if m.VideoStartTs != nil {
					flags |= 1 << 2
				}
				if m.VideoEmojiMarkup != nil {
					flags |= 1 << 4
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Bot != nil {
				_ = m.Bot.Encode(x, layer)
			}

			if m.File != nil {
				_ = m.File.Encode(x, layer)
			}

			if m.Video != nil {
				_ = m.Video.Encode(x, layer)
			}

			if m.VideoStartTs != nil {
				x.PutDouble(*m.VideoStartTs)
			}

			if m.VideoEmojiMarkup != nil {
				_ = m.VideoEmojiMarkup.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_photos_uploadProfilePhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_photos_uploadProfilePhoto, layer)
	}
}

// Decode <--
func (m *TLPhotosUploadProfilePhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x388a3b5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 3)) != 0 {
				m.Fallback = true
			}
			if (flags & (1 << 5)) != 0 {
				// m3 := &InputUser{}
				// _ = m3.Decode(d)
				// m.Bot = m3
				m.Bot, _ = DecodeInputUserClazz(d)
			}
			if (flags & (1 << 0)) != 0 {
				// m4 := &InputFile{}
				// _ = m4.Decode(d)
				// m.File = m4
				m.File, _ = DecodeInputFileClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				// m5 := &InputFile{}
				// _ = m5.Decode(d)
				// m.Video = m5
				m.Video, _ = DecodeInputFileClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				m.VideoStartTs = new(float64)
				*m.VideoStartTs, err = d.Double()
			}

			if (flags & (1 << 4)) != 0 {
				// m7 := &VideoSize{}
				// _ = m7.Decode(d)
				// m.VideoEmojiMarkup = m7
				m.VideoEmojiMarkup, _ = DecodeVideoSizeClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhotosDeletePhotos <--
type TLPhotosDeletePhotos struct {
	ClazzID uint32            `json:"_id"`
	Id      []InputPhotoClazz `json:"id"`
}

func (m *TLPhotosDeletePhotos) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhotosDeletePhotos) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x87cf7f2f: func() error {
			x.PutClazzID(0x87cf7f2f)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_photos_deletePhotos, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_photos_deletePhotos, layer)
	}
}

// Decode <--
func (m *TLPhotosDeletePhotos) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x87cf7f2f: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputPhoto, l1)
			v1 := make([]InputPhotoClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputPhoto)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputPhotoClazz(d)
				_ = err3
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhotosGetUserPhotos <--
type TLPhotosGetUserPhotos struct {
	ClazzID uint32         `json:"_id"`
	UserId  InputUserClazz `json:"user_id"`
	Offset  int32          `json:"offset"`
	MaxId   int64          `json:"max_id"`
	Limit   int32          `json:"limit"`
}

func (m *TLPhotosGetUserPhotos) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhotosGetUserPhotos) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x91cd32a8: func() error {
			x.PutClazzID(0x91cd32a8)

			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.Offset)
			x.PutInt64(m.MaxId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_photos_getUserPhotos, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_photos_getUserPhotos, layer)
	}
}

// Decode <--
func (m *TLPhotosGetUserPhotos) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x91cd32a8: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.UserId = m1
			m.UserId, _ = DecodeInputUserClazz(d)

			m.Offset, err = d.Int32()
			m.MaxId, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhotosUploadContactProfilePhoto <--
type TLPhotosUploadContactProfilePhoto struct {
	ClazzID          uint32         `json:"_id"`
	Suggest          bool           `json:"suggest"`
	Save             bool           `json:"save"`
	UserId           InputUserClazz `json:"user_id"`
	File             InputFileClazz `json:"file"`
	Video            InputFileClazz `json:"video"`
	VideoStartTs     *float64       `json:"video_start_ts"`
	VideoEmojiMarkup VideoSizeClazz `json:"video_emoji_markup"`
}

func (m *TLPhotosUploadContactProfilePhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhotosUploadContactProfilePhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe14c4a71: func() error {
			x.PutClazzID(0xe14c4a71)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Suggest == true {
					flags |= 1 << 3
				}
				if m.Save == true {
					flags |= 1 << 4
				}

				if m.File != nil {
					flags |= 1 << 0
				}
				if m.Video != nil {
					flags |= 1 << 1
				}
				if m.VideoStartTs != nil {
					flags |= 1 << 2
				}
				if m.VideoEmojiMarkup != nil {
					flags |= 1 << 5
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.UserId.Encode(x, layer)
			if m.File != nil {
				_ = m.File.Encode(x, layer)
			}

			if m.Video != nil {
				_ = m.Video.Encode(x, layer)
			}

			if m.VideoStartTs != nil {
				x.PutDouble(*m.VideoStartTs)
			}

			if m.VideoEmojiMarkup != nil {
				_ = m.VideoEmojiMarkup.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_photos_uploadContactProfilePhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_photos_uploadContactProfilePhoto, layer)
	}
}

// Decode <--
func (m *TLPhotosUploadContactProfilePhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe14c4a71: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 3)) != 0 {
				m.Suggest = true
			}
			if (flags & (1 << 4)) != 0 {
				m.Save = true
			}

			// m4 := &InputUser{}
			// _ = m4.Decode(d)
			// m.UserId = m4
			m.UserId, _ = DecodeInputUserClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m5 := &InputFile{}
				// _ = m5.Decode(d)
				// m.File = m5
				m.File, _ = DecodeInputFileClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				// m6 := &InputFile{}
				// _ = m6.Decode(d)
				// m.Video = m6
				m.Video, _ = DecodeInputFileClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				m.VideoStartTs = new(float64)
				*m.VideoStartTs, err = d.Double()
			}

			if (flags & (1 << 5)) != 0 {
				// m8 := &VideoSize{}
				// _ = m8.Decode(d)
				// m.VideoEmojiMarkup = m8
				m.VideoEmojiMarkup, _ = DecodeVideoSizeClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadSaveFilePart <--
type TLUploadSaveFilePart struct {
	ClazzID  uint32 `json:"_id"`
	FileId   int64  `json:"file_id"`
	FilePart int32  `json:"file_part"`
	Bytes    []byte `json:"bytes"`
}

func (m *TLUploadSaveFilePart) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadSaveFilePart) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb304a621: func() error {
			x.PutClazzID(0xb304a621)

			x.PutInt64(m.FileId)
			x.PutInt32(m.FilePart)
			x.PutBytes(m.Bytes)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_saveFilePart, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_saveFilePart, layer)
	}
}

// Decode <--
func (m *TLUploadSaveFilePart) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb304a621: func() (err error) {
			m.FileId, err = d.Int64()
			m.FilePart, err = d.Int32()
			m.Bytes, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadGetFile <--
type TLUploadGetFile struct {
	ClazzID      uint32                 `json:"_id"`
	Precise      bool                   `json:"precise"`
	CdnSupported bool                   `json:"cdn_supported"`
	Location     InputFileLocationClazz `json:"location"`
	Offset       int64                  `json:"offset"`
	Limit        int32                  `json:"limit"`
}

func (m *TLUploadGetFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadGetFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbe5335be: func() error {
			x.PutClazzID(0xbe5335be)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Precise == true {
					flags |= 1 << 0
				}
				if m.CdnSupported == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Location.Encode(x, layer)
			x.PutInt64(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_getFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_getFile, layer)
	}
}

// Decode <--
func (m *TLUploadGetFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbe5335be: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Precise = true
			}
			if (flags & (1 << 1)) != 0 {
				m.CdnSupported = true
			}

			// m4 := &InputFileLocation{}
			// _ = m4.Decode(d)
			// m.Location = m4
			m.Location, _ = DecodeInputFileLocationClazz(d)

			m.Offset, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadSaveBigFilePart <--
type TLUploadSaveBigFilePart struct {
	ClazzID        uint32 `json:"_id"`
	FileId         int64  `json:"file_id"`
	FilePart       int32  `json:"file_part"`
	FileTotalParts int32  `json:"file_total_parts"`
	Bytes          []byte `json:"bytes"`
}

func (m *TLUploadSaveBigFilePart) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadSaveBigFilePart) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xde7b673d: func() error {
			x.PutClazzID(0xde7b673d)

			x.PutInt64(m.FileId)
			x.PutInt32(m.FilePart)
			x.PutInt32(m.FileTotalParts)
			x.PutBytes(m.Bytes)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_saveBigFilePart, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_saveBigFilePart, layer)
	}
}

// Decode <--
func (m *TLUploadSaveBigFilePart) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xde7b673d: func() (err error) {
			m.FileId, err = d.Int64()
			m.FilePart, err = d.Int32()
			m.FileTotalParts, err = d.Int32()
			m.Bytes, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadGetWebFile <--
type TLUploadGetWebFile struct {
	ClazzID  uint32                    `json:"_id"`
	Location InputWebFileLocationClazz `json:"location"`
	Offset   int32                     `json:"offset"`
	Limit    int32                     `json:"limit"`
}

func (m *TLUploadGetWebFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadGetWebFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x24e6818d: func() error {
			x.PutClazzID(0x24e6818d)

			_ = m.Location.Encode(x, layer)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_getWebFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_getWebFile, layer)
	}
}

// Decode <--
func (m *TLUploadGetWebFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x24e6818d: func() (err error) {

			// m1 := &InputWebFileLocation{}
			// _ = m1.Decode(d)
			// m.Location = m1
			m.Location, _ = DecodeInputWebFileLocationClazz(d)

			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadGetCdnFile <--
type TLUploadGetCdnFile struct {
	ClazzID   uint32 `json:"_id"`
	FileToken []byte `json:"file_token"`
	Offset    int64  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (m *TLUploadGetCdnFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadGetCdnFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x395f69da: func() error {
			x.PutClazzID(0x395f69da)

			x.PutBytes(m.FileToken)
			x.PutInt64(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_getCdnFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_getCdnFile, layer)
	}
}

// Decode <--
func (m *TLUploadGetCdnFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x395f69da: func() (err error) {
			m.FileToken, err = d.Bytes()
			m.Offset, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadReuploadCdnFile <--
type TLUploadReuploadCdnFile struct {
	ClazzID      uint32 `json:"_id"`
	FileToken    []byte `json:"file_token"`
	RequestToken []byte `json:"request_token"`
}

func (m *TLUploadReuploadCdnFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadReuploadCdnFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9b2754a8: func() error {
			x.PutClazzID(0x9b2754a8)

			x.PutBytes(m.FileToken)
			x.PutBytes(m.RequestToken)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_reuploadCdnFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_reuploadCdnFile, layer)
	}
}

// Decode <--
func (m *TLUploadReuploadCdnFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9b2754a8: func() (err error) {
			m.FileToken, err = d.Bytes()
			m.RequestToken, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadGetCdnFileHashes <--
type TLUploadGetCdnFileHashes struct {
	ClazzID   uint32 `json:"_id"`
	FileToken []byte `json:"file_token"`
	Offset    int64  `json:"offset"`
}

func (m *TLUploadGetCdnFileHashes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadGetCdnFileHashes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x91dc3f31: func() error {
			x.PutClazzID(0x91dc3f31)

			x.PutBytes(m.FileToken)
			x.PutInt64(m.Offset)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_getCdnFileHashes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_getCdnFileHashes, layer)
	}
}

// Decode <--
func (m *TLUploadGetCdnFileHashes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x91dc3f31: func() (err error) {
			m.FileToken, err = d.Bytes()
			m.Offset, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadGetFileHashes <--
type TLUploadGetFileHashes struct {
	ClazzID  uint32                 `json:"_id"`
	Location InputFileLocationClazz `json:"location"`
	Offset   int64                  `json:"offset"`
}

func (m *TLUploadGetFileHashes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadGetFileHashes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9156982a: func() error {
			x.PutClazzID(0x9156982a)

			_ = m.Location.Encode(x, layer)
			x.PutInt64(m.Offset)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_getFileHashes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_getFileHashes, layer)
	}
}

// Decode <--
func (m *TLUploadGetFileHashes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9156982a: func() (err error) {

			// m1 := &InputFileLocation{}
			// _ = m1.Decode(d)
			// m.Location = m1
			m.Location, _ = DecodeInputFileLocationClazz(d)

			m.Offset, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetConfig <--
type TLHelpGetConfig struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc4f9186b: func() error {
			x.PutClazzID(0xc4f9186b)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getConfig, layer)
	}
}

// Decode <--
func (m *TLHelpGetConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc4f9186b: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetNearestDc <--
type TLHelpGetNearestDc struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetNearestDc) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetNearestDc) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1fb33026: func() error {
			x.PutClazzID(0x1fb33026)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getNearestDc, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getNearestDc, layer)
	}
}

// Decode <--
func (m *TLHelpGetNearestDc) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1fb33026: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetAppUpdate <--
type TLHelpGetAppUpdate struct {
	ClazzID uint32 `json:"_id"`
	Source  string `json:"source"`
}

func (m *TLHelpGetAppUpdate) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetAppUpdate) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x522d5a7d: func() error {
			x.PutClazzID(0x522d5a7d)

			x.PutString(m.Source)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getAppUpdate, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getAppUpdate, layer)
	}
}

// Decode <--
func (m *TLHelpGetAppUpdate) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x522d5a7d: func() (err error) {
			m.Source, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetInviteText <--
type TLHelpGetInviteText struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetInviteText) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetInviteText) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4d392343: func() error {
			x.PutClazzID(0x4d392343)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getInviteText, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getInviteText, layer)
	}
}

// Decode <--
func (m *TLHelpGetInviteText) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4d392343: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetSupport <--
type TLHelpGetSupport struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetSupport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetSupport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9cdf08cd: func() error {
			x.PutClazzID(0x9cdf08cd)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getSupport, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getSupport, layer)
	}
}

// Decode <--
func (m *TLHelpGetSupport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9cdf08cd: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpSetBotUpdatesStatus <--
type TLHelpSetBotUpdatesStatus struct {
	ClazzID             uint32 `json:"_id"`
	PendingUpdatesCount int32  `json:"pending_updates_count"`
	Message             string `json:"message"`
}

func (m *TLHelpSetBotUpdatesStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpSetBotUpdatesStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xec22cfcd: func() error {
			x.PutClazzID(0xec22cfcd)

			x.PutInt32(m.PendingUpdatesCount)
			x.PutString(m.Message)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_setBotUpdatesStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_setBotUpdatesStatus, layer)
	}
}

// Decode <--
func (m *TLHelpSetBotUpdatesStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xec22cfcd: func() (err error) {
			m.PendingUpdatesCount, err = d.Int32()
			m.Message, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetCdnConfig <--
type TLHelpGetCdnConfig struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetCdnConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetCdnConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x52029342: func() error {
			x.PutClazzID(0x52029342)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getCdnConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getCdnConfig, layer)
	}
}

// Decode <--
func (m *TLHelpGetCdnConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x52029342: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetRecentMeUrls <--
type TLHelpGetRecentMeUrls struct {
	ClazzID uint32 `json:"_id"`
	Referer string `json:"referer"`
}

func (m *TLHelpGetRecentMeUrls) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetRecentMeUrls) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3dc0f114: func() error {
			x.PutClazzID(0x3dc0f114)

			x.PutString(m.Referer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getRecentMeUrls, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getRecentMeUrls, layer)
	}
}

// Decode <--
func (m *TLHelpGetRecentMeUrls) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3dc0f114: func() (err error) {
			m.Referer, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetTermsOfServiceUpdate <--
type TLHelpGetTermsOfServiceUpdate struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetTermsOfServiceUpdate) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetTermsOfServiceUpdate) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2ca51fd1: func() error {
			x.PutClazzID(0x2ca51fd1)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getTermsOfServiceUpdate, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getTermsOfServiceUpdate, layer)
	}
}

// Decode <--
func (m *TLHelpGetTermsOfServiceUpdate) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2ca51fd1: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpAcceptTermsOfService <--
type TLHelpAcceptTermsOfService struct {
	ClazzID uint32        `json:"_id"`
	Id      DataJSONClazz `json:"id"`
}

func (m *TLHelpAcceptTermsOfService) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpAcceptTermsOfService) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xee72f79a: func() error {
			x.PutClazzID(0xee72f79a)

			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_acceptTermsOfService, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_acceptTermsOfService, layer)
	}
}

// Decode <--
func (m *TLHelpAcceptTermsOfService) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xee72f79a: func() (err error) {

			// m1 := &DataJSON{}
			// _ = m1.Decode(d)
			// m.Id = m1
			m.Id, _ = DecodeDataJSONClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetDeepLinkInfo <--
type TLHelpGetDeepLinkInfo struct {
	ClazzID uint32 `json:"_id"`
	Path    string `json:"path"`
}

func (m *TLHelpGetDeepLinkInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetDeepLinkInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3fedc75f: func() error {
			x.PutClazzID(0x3fedc75f)

			x.PutString(m.Path)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getDeepLinkInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getDeepLinkInfo, layer)
	}
}

// Decode <--
func (m *TLHelpGetDeepLinkInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3fedc75f: func() (err error) {
			m.Path, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetAppConfig <--
type TLHelpGetAppConfig struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLHelpGetAppConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetAppConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x61e3f854: func() error {
			x.PutClazzID(0x61e3f854)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getAppConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getAppConfig, layer)
	}
}

// Decode <--
func (m *TLHelpGetAppConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x61e3f854: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpSaveAppLog <--
type TLHelpSaveAppLog struct {
	ClazzID uint32               `json:"_id"`
	Events  []InputAppEventClazz `json:"events"`
}

func (m *TLHelpSaveAppLog) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpSaveAppLog) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6f02f748: func() error {
			x.PutClazzID(0x6f02f748)

			_ = iface.EncodeObjectList(x, m.Events, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_saveAppLog, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_saveAppLog, layer)
	}
}

// Decode <--
func (m *TLHelpSaveAppLog) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6f02f748: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputAppEvent, l1)
			v1 := make([]InputAppEventClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputAppEvent)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputAppEventClazz(d)
				_ = err3
			}
			m.Events = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetPassportConfig <--
type TLHelpGetPassportConfig struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLHelpGetPassportConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetPassportConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc661ad08: func() error {
			x.PutClazzID(0xc661ad08)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getPassportConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getPassportConfig, layer)
	}
}

// Decode <--
func (m *TLHelpGetPassportConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc661ad08: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetSupportName <--
type TLHelpGetSupportName struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetSupportName) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetSupportName) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd360e72c: func() error {
			x.PutClazzID(0xd360e72c)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getSupportName, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getSupportName, layer)
	}
}

// Decode <--
func (m *TLHelpGetSupportName) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd360e72c: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetUserInfo <--
type TLHelpGetUserInfo struct {
	ClazzID uint32         `json:"_id"`
	UserId  InputUserClazz `json:"user_id"`
}

func (m *TLHelpGetUserInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetUserInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x38a08d3: func() error {
			x.PutClazzID(0x38a08d3)

			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getUserInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getUserInfo, layer)
	}
}

// Decode <--
func (m *TLHelpGetUserInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x38a08d3: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.UserId = m1
			m.UserId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpEditUserInfo <--
type TLHelpEditUserInfo struct {
	ClazzID  uint32               `json:"_id"`
	UserId   InputUserClazz       `json:"user_id"`
	Message  string               `json:"message"`
	Entities []MessageEntityClazz `json:"entities"`
}

func (m *TLHelpEditUserInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpEditUserInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x66b91b70: func() error {
			x.PutClazzID(0x66b91b70)

			_ = m.UserId.Encode(x, layer)
			x.PutString(m.Message)

			_ = iface.EncodeObjectList(x, m.Entities, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_editUserInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_editUserInfo, layer)
	}
}

// Decode <--
func (m *TLHelpEditUserInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x66b91b70: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.UserId = m1
			m.UserId, _ = DecodeInputUserClazz(d)

			m.Message, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			// v3 := make([]*MessageEntity, l3)
			v3 := make([]MessageEntityClazz, l3)
			for i := 0; i < l3; i++ {
				// vv := new(MessageEntity)
				// err3 = vv.Decode(d)
				// _ = err3
				// v3[i] = vv
				v3[i], _ = DecodeMessageEntityClazz(d)
				_ = err3
			}
			m.Entities = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetPromoData <--
type TLHelpGetPromoData struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetPromoData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetPromoData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc0977421: func() error {
			x.PutClazzID(0xc0977421)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getPromoData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getPromoData, layer)
	}
}

// Decode <--
func (m *TLHelpGetPromoData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc0977421: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpHidePromoData <--
type TLHelpHidePromoData struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLHelpHidePromoData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpHidePromoData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1e251c95: func() error {
			x.PutClazzID(0x1e251c95)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_hidePromoData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_hidePromoData, layer)
	}
}

// Decode <--
func (m *TLHelpHidePromoData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1e251c95: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpDismissSuggestion <--
type TLHelpDismissSuggestion struct {
	ClazzID    uint32         `json:"_id"`
	Peer       InputPeerClazz `json:"peer"`
	Suggestion string         `json:"suggestion"`
}

func (m *TLHelpDismissSuggestion) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpDismissSuggestion) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf50dbaa1: func() error {
			x.PutClazzID(0xf50dbaa1)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Suggestion)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_dismissSuggestion, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_dismissSuggestion, layer)
	}
}

// Decode <--
func (m *TLHelpDismissSuggestion) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf50dbaa1: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Suggestion, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetCountriesList <--
type TLHelpGetCountriesList struct {
	ClazzID  uint32 `json:"_id"`
	LangCode string `json:"lang_code"`
	Hash     int32  `json:"hash"`
}

func (m *TLHelpGetCountriesList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetCountriesList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x735787a8: func() error {
			x.PutClazzID(0x735787a8)

			x.PutString(m.LangCode)
			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getCountriesList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getCountriesList, layer)
	}
}

// Decode <--
func (m *TLHelpGetCountriesList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x735787a8: func() (err error) {
			m.LangCode, err = d.String()
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetPremiumPromo <--
type TLHelpGetPremiumPromo struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetPremiumPromo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetPremiumPromo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb81b93d4: func() error {
			x.PutClazzID(0xb81b93d4)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getPremiumPromo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getPremiumPromo, layer)
	}
}

// Decode <--
func (m *TLHelpGetPremiumPromo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb81b93d4: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetPeerColors <--
type TLHelpGetPeerColors struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLHelpGetPeerColors) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetPeerColors) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xda80f42f: func() error {
			x.PutClazzID(0xda80f42f)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getPeerColors, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getPeerColors, layer)
	}
}

// Decode <--
func (m *TLHelpGetPeerColors) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xda80f42f: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetPeerProfileColors <--
type TLHelpGetPeerProfileColors struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLHelpGetPeerProfileColors) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetPeerProfileColors) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xabcfa9fd: func() error {
			x.PutClazzID(0xabcfa9fd)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getPeerProfileColors, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getPeerProfileColors, layer)
	}
}

// Decode <--
func (m *TLHelpGetPeerProfileColors) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xabcfa9fd: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetTimezonesList <--
type TLHelpGetTimezonesList struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLHelpGetTimezonesList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetTimezonesList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x49b30240: func() error {
			x.PutClazzID(0x49b30240)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getTimezonesList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getTimezonesList, layer)
	}
}

// Decode <--
func (m *TLHelpGetTimezonesList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x49b30240: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReadHistory <--
type TLChannelsReadHistory struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	MaxId   int32             `json:"max_id"`
}

func (m *TLChannelsReadHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReadHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcc104937: func() error {
			x.PutClazzID(0xcc104937)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_readHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_readHistory, layer)
	}
}

// Decode <--
func (m *TLChannelsReadHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcc104937: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeleteMessages <--
type TLChannelsDeleteMessages struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Id      []int32           `json:"id"`
}

func (m *TLChannelsDeleteMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeleteMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x84c1fd4e: func() error {
			x.PutClazzID(0x84c1fd4e)

			_ = m.Channel.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deleteMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deleteMessages, layer)
	}
}

// Decode <--
func (m *TLChannelsDeleteMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x84c1fd4e: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReportSpam <--
type TLChannelsReportSpam struct {
	ClazzID     uint32            `json:"_id"`
	Channel     InputChannelClazz `json:"channel"`
	Participant InputPeerClazz    `json:"participant"`
	Id          []int32           `json:"id"`
}

func (m *TLChannelsReportSpam) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReportSpam) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf44a8315: func() error {
			x.PutClazzID(0xf44a8315)

			_ = m.Channel.Encode(x, layer)
			_ = m.Participant.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_reportSpam, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_reportSpam, layer)
	}
}

// Decode <--
func (m *TLChannelsReportSpam) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf44a8315: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Participant = m2
			m.Participant, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetMessages <--
type TLChannelsGetMessages struct {
	ClazzID               uint32              `json:"_id"`
	Channel               InputChannelClazz   `json:"channel"`
	Id_VECTORINPUTMESSAGE []InputMessageClazz `json:"id_VECTORINPUTMESSAGE"`
	Id_VECTORINT32        []int32             `json:"id_VECTORINT32"`
}

func (m *TLChannelsGetMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xad8c9a23: func() error {
			x.PutClazzID(0xad8c9a23)

			_ = m.Channel.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Id_VECTORINPUTMESSAGE, layer)

			return nil
		},
		0x93d7b347: func() error {
			x.PutClazzID(0x93d7b347)

			_ = m.Channel.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id_VECTORINT32)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getMessages, layer)
	}
}

// Decode <--
func (m *TLChannelsGetMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xad8c9a23: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputMessage, l2)
			v2 := make([]InputMessageClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputMessage)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputMessageClazz(d)
				_ = err3
			}
			m.Id_VECTORINPUTMESSAGE = v2

			return nil
		},
		0x93d7b347: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Id_VECTORINT32, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetParticipants <--
type TLChannelsGetParticipants struct {
	ClazzID uint32                         `json:"_id"`
	Channel InputChannelClazz              `json:"channel"`
	Filter  ChannelParticipantsFilterClazz `json:"filter"`
	Offset  int32                          `json:"offset"`
	Limit   int32                          `json:"limit"`
	Hash    int64                          `json:"hash"`
}

func (m *TLChannelsGetParticipants) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetParticipants) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x77ced9d0: func() error {
			x.PutClazzID(0x77ced9d0)

			_ = m.Channel.Encode(x, layer)
			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getParticipants, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getParticipants, layer)
	}
}

// Decode <--
func (m *TLChannelsGetParticipants) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x77ced9d0: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &ChannelParticipantsFilter{}
			// _ = m2.Decode(d)
			// m.Filter = m2
			m.Filter, _ = DecodeChannelParticipantsFilterClazz(d)

			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetParticipant <--
type TLChannelsGetParticipant struct {
	ClazzID     uint32            `json:"_id"`
	Channel     InputChannelClazz `json:"channel"`
	Participant InputPeerClazz    `json:"participant"`
}

func (m *TLChannelsGetParticipant) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetParticipant) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa0ab6cc6: func() error {
			x.PutClazzID(0xa0ab6cc6)

			_ = m.Channel.Encode(x, layer)
			_ = m.Participant.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getParticipant, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getParticipant, layer)
	}
}

// Decode <--
func (m *TLChannelsGetParticipant) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa0ab6cc6: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Participant = m2
			m.Participant, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetChannels <--
type TLChannelsGetChannels struct {
	ClazzID uint32              `json:"_id"`
	Id      []InputChannelClazz `json:"id"`
}

func (m *TLChannelsGetChannels) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetChannels) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa7f6bbb: func() error {
			x.PutClazzID(0xa7f6bbb)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getChannels, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getChannels, layer)
	}
}

// Decode <--
func (m *TLChannelsGetChannels) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa7f6bbb: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputChannel, l1)
			v1 := make([]InputChannelClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputChannel)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputChannelClazz(d)
				_ = err3
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetFullChannel <--
type TLChannelsGetFullChannel struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
}

func (m *TLChannelsGetFullChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetFullChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8736a09: func() error {
			x.PutClazzID(0x8736a09)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getFullChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getFullChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsGetFullChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8736a09: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsCreateChannel <--
type TLChannelsCreateChannel struct {
	ClazzID   uint32             `json:"_id"`
	Broadcast bool               `json:"broadcast"`
	Megagroup bool               `json:"megagroup"`
	ForImport bool               `json:"for_import"`
	Forum     bool               `json:"forum"`
	Title     string             `json:"title"`
	About     string             `json:"about"`
	GeoPoint  InputGeoPointClazz `json:"geo_point"`
	Address   *string            `json:"address"`
	TtlPeriod *int32             `json:"ttl_period"`
}

func (m *TLChannelsCreateChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsCreateChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x91006707: func() error {
			x.PutClazzID(0x91006707)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Broadcast == true {
					flags |= 1 << 0
				}
				if m.Megagroup == true {
					flags |= 1 << 1
				}
				if m.ForImport == true {
					flags |= 1 << 3
				}
				if m.Forum == true {
					flags |= 1 << 5
				}

				if m.GeoPoint != nil {
					flags |= 1 << 2
				}
				if m.Address != nil {
					flags |= 1 << 2
				}
				if m.TtlPeriod != nil {
					flags |= 1 << 4
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Title)
			x.PutString(m.About)
			if m.GeoPoint != nil {
				_ = m.GeoPoint.Encode(x, layer)
			}

			if m.Address != nil {
				x.PutString(*m.Address)
			}

			if m.TtlPeriod != nil {
				x.PutInt32(*m.TtlPeriod)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_createChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_createChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsCreateChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x91006707: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Broadcast = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Megagroup = true
			}
			if (flags & (1 << 3)) != 0 {
				m.ForImport = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Forum = true
			}
			m.Title, err = d.String()
			m.About, err = d.String()
			if (flags & (1 << 2)) != 0 {
				// m8 := &InputGeoPoint{}
				// _ = m8.Decode(d)
				// m.GeoPoint = m8
				m.GeoPoint, _ = DecodeInputGeoPointClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				m.Address = new(string)
				*m.Address, err = d.String()
			}

			if (flags & (1 << 4)) != 0 {
				m.TtlPeriod = new(int32)
				*m.TtlPeriod, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditAdmin <--
type TLChannelsEditAdmin struct {
	ClazzID     uint32               `json:"_id"`
	Channel     InputChannelClazz    `json:"channel"`
	UserId      InputUserClazz       `json:"user_id"`
	AdminRights ChatAdminRightsClazz `json:"admin_rights"`
	Rank        string               `json:"rank"`
}

func (m *TLChannelsEditAdmin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditAdmin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd33c8902: func() error {
			x.PutClazzID(0xd33c8902)

			_ = m.Channel.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)
			_ = m.AdminRights.Encode(x, layer)
			x.PutString(m.Rank)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editAdmin, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editAdmin, layer)
	}
}

// Decode <--
func (m *TLChannelsEditAdmin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd33c8902: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.UserId = m2
			m.UserId, _ = DecodeInputUserClazz(d)

			// m3 := &ChatAdminRights{}
			// _ = m3.Decode(d)
			// m.AdminRights = m3
			m.AdminRights, _ = DecodeChatAdminRightsClazz(d)

			m.Rank, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditTitle <--
type TLChannelsEditTitle struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Title   string            `json:"title"`
}

func (m *TLChannelsEditTitle) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditTitle) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x566decd0: func() error {
			x.PutClazzID(0x566decd0)

			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Title)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editTitle, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editTitle, layer)
	}
}

// Decode <--
func (m *TLChannelsEditTitle) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x566decd0: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Title, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditPhoto <--
type TLChannelsEditPhoto struct {
	ClazzID uint32              `json:"_id"`
	Channel InputChannelClazz   `json:"channel"`
	Photo   InputChatPhotoClazz `json:"photo"`
}

func (m *TLChannelsEditPhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditPhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf12e57c9: func() error {
			x.PutClazzID(0xf12e57c9)

			_ = m.Channel.Encode(x, layer)
			_ = m.Photo.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editPhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editPhoto, layer)
	}
}

// Decode <--
func (m *TLChannelsEditPhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf12e57c9: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &InputChatPhoto{}
			// _ = m2.Decode(d)
			// m.Photo = m2
			m.Photo, _ = DecodeInputChatPhotoClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsCheckUsername <--
type TLChannelsCheckUsername struct {
	ClazzID  uint32            `json:"_id"`
	Channel  InputChannelClazz `json:"channel"`
	Username string            `json:"username"`
}

func (m *TLChannelsCheckUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsCheckUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x10e6bd2c: func() error {
			x.PutClazzID(0x10e6bd2c)

			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Username)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_checkUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_checkUsername, layer)
	}
}

// Decode <--
func (m *TLChannelsCheckUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x10e6bd2c: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Username, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsUpdateUsername <--
type TLChannelsUpdateUsername struct {
	ClazzID  uint32            `json:"_id"`
	Channel  InputChannelClazz `json:"channel"`
	Username string            `json:"username"`
}

func (m *TLChannelsUpdateUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsUpdateUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3514b3de: func() error {
			x.PutClazzID(0x3514b3de)

			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Username)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_updateUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_updateUsername, layer)
	}
}

// Decode <--
func (m *TLChannelsUpdateUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3514b3de: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Username, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsJoinChannel <--
type TLChannelsJoinChannel struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
}

func (m *TLChannelsJoinChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsJoinChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x24b524c5: func() error {
			x.PutClazzID(0x24b524c5)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_joinChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_joinChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsJoinChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x24b524c5: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsLeaveChannel <--
type TLChannelsLeaveChannel struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
}

func (m *TLChannelsLeaveChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsLeaveChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf836aa95: func() error {
			x.PutClazzID(0xf836aa95)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_leaveChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_leaveChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsLeaveChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf836aa95: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsInviteToChannel <--
type TLChannelsInviteToChannel struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Users   []InputUserClazz  `json:"users"`
}

func (m *TLChannelsInviteToChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsInviteToChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc9e33d54: func() error {
			x.PutClazzID(0xc9e33d54)

			_ = m.Channel.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Users, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_inviteToChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_inviteToChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsInviteToChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc9e33d54: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputUser, l2)
			v2 := make([]InputUserClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputUser)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputUserClazz(d)
				_ = err3
			}
			m.Users = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeleteChannel <--
type TLChannelsDeleteChannel struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
}

func (m *TLChannelsDeleteChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeleteChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc0111fe3: func() error {
			x.PutClazzID(0xc0111fe3)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deleteChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deleteChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsDeleteChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc0111fe3: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsExportMessageLink <--
type TLChannelsExportMessageLink struct {
	ClazzID uint32            `json:"_id"`
	Grouped bool              `json:"grouped"`
	Thread  bool              `json:"thread"`
	Channel InputChannelClazz `json:"channel"`
	Id      int32             `json:"id"`
}

func (m *TLChannelsExportMessageLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsExportMessageLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe63fadeb: func() error {
			x.PutClazzID(0xe63fadeb)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Grouped == true {
					flags |= 1 << 0
				}
				if m.Thread == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_exportMessageLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_exportMessageLink, layer)
	}
}

// Decode <--
func (m *TLChannelsExportMessageLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe63fadeb: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Grouped = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Thread = true
			}

			// m4 := &InputChannel{}
			// _ = m4.Decode(d)
			// m.Channel = m4
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleSignatures <--
type TLChannelsToggleSignatures struct {
	ClazzID           uint32            `json:"_id"`
	SignaturesEnabled bool              `json:"signatures_enabled"`
	ProfilesEnabled   bool              `json:"profiles_enabled"`
	Channel           InputChannelClazz `json:"channel"`
}

func (m *TLChannelsToggleSignatures) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleSignatures) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x418d549c: func() error {
			x.PutClazzID(0x418d549c)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SignaturesEnabled == true {
					flags |= 1 << 0
				}
				if m.ProfilesEnabled == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleSignatures, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleSignatures, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleSignatures) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x418d549c: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.SignaturesEnabled = true
			}
			if (flags & (1 << 1)) != 0 {
				m.ProfilesEnabled = true
			}

			// m4 := &InputChannel{}
			// _ = m4.Decode(d)
			// m.Channel = m4
			m.Channel, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetAdminedPublicChannels <--
type TLChannelsGetAdminedPublicChannels struct {
	ClazzID     uint32 `json:"_id"`
	ByLocation  bool   `json:"by_location"`
	CheckLimit  bool   `json:"check_limit"`
	ForPersonal bool   `json:"for_personal"`
}

func (m *TLChannelsGetAdminedPublicChannels) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetAdminedPublicChannels) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf8b036af: func() error {
			x.PutClazzID(0xf8b036af)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ByLocation == true {
					flags |= 1 << 0
				}
				if m.CheckLimit == true {
					flags |= 1 << 1
				}
				if m.ForPersonal == true {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getAdminedPublicChannels, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getAdminedPublicChannels, layer)
	}
}

// Decode <--
func (m *TLChannelsGetAdminedPublicChannels) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf8b036af: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ByLocation = true
			}
			if (flags & (1 << 1)) != 0 {
				m.CheckLimit = true
			}
			if (flags & (1 << 2)) != 0 {
				m.ForPersonal = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditBanned <--
type TLChannelsEditBanned struct {
	ClazzID      uint32                `json:"_id"`
	Channel      InputChannelClazz     `json:"channel"`
	Participant  InputPeerClazz        `json:"participant"`
	BannedRights ChatBannedRightsClazz `json:"banned_rights"`
}

func (m *TLChannelsEditBanned) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditBanned) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x96e6cd81: func() error {
			x.PutClazzID(0x96e6cd81)

			_ = m.Channel.Encode(x, layer)
			_ = m.Participant.Encode(x, layer)
			_ = m.BannedRights.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editBanned, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editBanned, layer)
	}
}

// Decode <--
func (m *TLChannelsEditBanned) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x96e6cd81: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Participant = m2
			m.Participant, _ = DecodeInputPeerClazz(d)

			// m3 := &ChatBannedRights{}
			// _ = m3.Decode(d)
			// m.BannedRights = m3
			m.BannedRights, _ = DecodeChatBannedRightsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetAdminLog <--
type TLChannelsGetAdminLog struct {
	ClazzID      uint32                           `json:"_id"`
	Channel      InputChannelClazz                `json:"channel"`
	Q            string                           `json:"q"`
	EventsFilter ChannelAdminLogEventsFilterClazz `json:"events_filter"`
	Admins       []InputUserClazz                 `json:"admins"`
	MaxId        int64                            `json:"max_id"`
	MinId        int64                            `json:"min_id"`
	Limit        int32                            `json:"limit"`
}

func (m *TLChannelsGetAdminLog) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetAdminLog) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x33ddf480: func() error {
			x.PutClazzID(0x33ddf480)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.EventsFilter != nil {
					flags |= 1 << 0
				}
				if m.Admins != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Q)
			if m.EventsFilter != nil {
				_ = m.EventsFilter.Encode(x, layer)
			}

			if m.Admins != nil {
				_ = iface.EncodeObjectList(x, m.Admins, layer)
			}
			x.PutInt64(m.MaxId)
			x.PutInt64(m.MinId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getAdminLog, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getAdminLog, layer)
	}
}

// Decode <--
func (m *TLChannelsGetAdminLog) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x33ddf480: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputChannel{}
			// _ = m2.Decode(d)
			// m.Channel = m2
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Q, err = d.String()
			if (flags & (1 << 0)) != 0 {
				// m4 := &ChannelAdminLogEventsFilter{}
				// _ = m4.Decode(d)
				// m.EventsFilter = m4
				m.EventsFilter, _ = DecodeChannelAdminLogEventsFilterClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				c5, err2 := d.ClazzID()
				if c5 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
					return err2
				}
				l5, err3 := d.Int()
				// v5 := make([]*InputUser, l5)
				v5 := make([]InputUserClazz, l5)
				for i := 0; i < l5; i++ {
					// vv := new(InputUser)
					// err3 = vv.Decode(d)
					// _ = err3
					// v5[i] = vv
					v5[i], _ = DecodeInputUserClazz(d)
					_ = err3
				}
				m.Admins = v5
			}
			m.MaxId, err = d.Int64()
			m.MinId, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSetStickers <--
type TLChannelsSetStickers struct {
	ClazzID    uint32               `json:"_id"`
	Channel    InputChannelClazz    `json:"channel"`
	Stickerset InputStickerSetClazz `json:"stickerset"`
}

func (m *TLChannelsSetStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSetStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xea8ca4f9: func() error {
			x.PutClazzID(0xea8ca4f9)

			_ = m.Channel.Encode(x, layer)
			_ = m.Stickerset.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_setStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_setStickers, layer)
	}
}

// Decode <--
func (m *TLChannelsSetStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xea8ca4f9: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &InputStickerSet{}
			// _ = m2.Decode(d)
			// m.Stickerset = m2
			m.Stickerset, _ = DecodeInputStickerSetClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReadMessageContents <--
type TLChannelsReadMessageContents struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Id      []int32           `json:"id"`
}

func (m *TLChannelsReadMessageContents) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReadMessageContents) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xeab5dc38: func() error {
			x.PutClazzID(0xeab5dc38)

			_ = m.Channel.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_readMessageContents, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_readMessageContents, layer)
	}
}

// Decode <--
func (m *TLChannelsReadMessageContents) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xeab5dc38: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeleteHistory <--
type TLChannelsDeleteHistory struct {
	ClazzID     uint32            `json:"_id"`
	ForEveryone bool              `json:"for_everyone"`
	Channel     InputChannelClazz `json:"channel"`
	MaxId       int32             `json:"max_id"`
}

func (m *TLChannelsDeleteHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeleteHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9baa9647: func() error {
			x.PutClazzID(0x9baa9647)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForEveryone == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deleteHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deleteHistory, layer)
	}
}

// Decode <--
func (m *TLChannelsDeleteHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9baa9647: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ForEveryone = true
			}

			// m3 := &InputChannel{}
			// _ = m3.Decode(d)
			// m.Channel = m3
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsTogglePreHistoryHidden <--
type TLChannelsTogglePreHistoryHidden struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Enabled BoolClazz         `json:"enabled"`
}

func (m *TLChannelsTogglePreHistoryHidden) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsTogglePreHistoryHidden) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xeabbb94c: func() error {
			x.PutClazzID(0xeabbb94c)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_togglePreHistoryHidden, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_togglePreHistoryHidden, layer)
	}
}

// Decode <--
func (m *TLChannelsTogglePreHistoryHidden) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xeabbb94c: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Enabled = m2
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetLeftChannels <--
type TLChannelsGetLeftChannels struct {
	ClazzID uint32 `json:"_id"`
	Offset  int32  `json:"offset"`
}

func (m *TLChannelsGetLeftChannels) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetLeftChannels) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8341ecc0: func() error {
			x.PutClazzID(0x8341ecc0)

			x.PutInt32(m.Offset)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getLeftChannels, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getLeftChannels, layer)
	}
}

// Decode <--
func (m *TLChannelsGetLeftChannels) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8341ecc0: func() (err error) {
			m.Offset, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetGroupsForDiscussion <--
type TLChannelsGetGroupsForDiscussion struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLChannelsGetGroupsForDiscussion) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetGroupsForDiscussion) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf5dad378: func() error {
			x.PutClazzID(0xf5dad378)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getGroupsForDiscussion, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getGroupsForDiscussion, layer)
	}
}

// Decode <--
func (m *TLChannelsGetGroupsForDiscussion) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf5dad378: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSetDiscussionGroup <--
type TLChannelsSetDiscussionGroup struct {
	ClazzID   uint32            `json:"_id"`
	Broadcast InputChannelClazz `json:"broadcast"`
	Group     InputChannelClazz `json:"group"`
}

func (m *TLChannelsSetDiscussionGroup) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSetDiscussionGroup) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x40582bb2: func() error {
			x.PutClazzID(0x40582bb2)

			_ = m.Broadcast.Encode(x, layer)
			_ = m.Group.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_setDiscussionGroup, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_setDiscussionGroup, layer)
	}
}

// Decode <--
func (m *TLChannelsSetDiscussionGroup) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x40582bb2: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Broadcast = m1
			m.Broadcast, _ = DecodeInputChannelClazz(d)

			// m2 := &InputChannel{}
			// _ = m2.Decode(d)
			// m.Group = m2
			m.Group, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditCreator <--
type TLChannelsEditCreator struct {
	ClazzID  uint32                     `json:"_id"`
	Channel  InputChannelClazz          `json:"channel"`
	UserId   InputUserClazz             `json:"user_id"`
	Password InputCheckPasswordSRPClazz `json:"password"`
}

func (m *TLChannelsEditCreator) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditCreator) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8f38cd1f: func() error {
			x.PutClazzID(0x8f38cd1f)

			_ = m.Channel.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)
			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editCreator, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editCreator, layer)
	}
}

// Decode <--
func (m *TLChannelsEditCreator) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8f38cd1f: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.UserId = m2
			m.UserId, _ = DecodeInputUserClazz(d)

			// m3 := &InputCheckPasswordSRP{}
			// _ = m3.Decode(d)
			// m.Password = m3
			m.Password, _ = DecodeInputCheckPasswordSRPClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditLocation <--
type TLChannelsEditLocation struct {
	ClazzID  uint32             `json:"_id"`
	Channel  InputChannelClazz  `json:"channel"`
	GeoPoint InputGeoPointClazz `json:"geo_point"`
	Address  string             `json:"address"`
}

func (m *TLChannelsEditLocation) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditLocation) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x58e63f6d: func() error {
			x.PutClazzID(0x58e63f6d)

			_ = m.Channel.Encode(x, layer)
			_ = m.GeoPoint.Encode(x, layer)
			x.PutString(m.Address)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editLocation, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editLocation, layer)
	}
}

// Decode <--
func (m *TLChannelsEditLocation) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x58e63f6d: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &InputGeoPoint{}
			// _ = m2.Decode(d)
			// m.GeoPoint = m2
			m.GeoPoint, _ = DecodeInputGeoPointClazz(d)

			m.Address, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleSlowMode <--
type TLChannelsToggleSlowMode struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Seconds int32             `json:"seconds"`
}

func (m *TLChannelsToggleSlowMode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleSlowMode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xedd49ef0: func() error {
			x.PutClazzID(0xedd49ef0)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.Seconds)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleSlowMode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleSlowMode, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleSlowMode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xedd49ef0: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Seconds, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetInactiveChannels <--
type TLChannelsGetInactiveChannels struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLChannelsGetInactiveChannels) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetInactiveChannels) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x11e831ee: func() error {
			x.PutClazzID(0x11e831ee)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getInactiveChannels, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getInactiveChannels, layer)
	}
}

// Decode <--
func (m *TLChannelsGetInactiveChannels) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x11e831ee: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsConvertToGigagroup <--
type TLChannelsConvertToGigagroup struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
}

func (m *TLChannelsConvertToGigagroup) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsConvertToGigagroup) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb290c69: func() error {
			x.PutClazzID(0xb290c69)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_convertToGigagroup, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_convertToGigagroup, layer)
	}
}

// Decode <--
func (m *TLChannelsConvertToGigagroup) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb290c69: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetSendAs <--
type TLChannelsGetSendAs struct {
	ClazzID          uint32         `json:"_id"`
	ForPaidReactions bool           `json:"for_paid_reactions"`
	Peer             InputPeerClazz `json:"peer"`
}

func (m *TLChannelsGetSendAs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetSendAs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe785a43f: func() error {
			x.PutClazzID(0xe785a43f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForPaidReactions == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getSendAs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getSendAs, layer)
	}
}

// Decode <--
func (m *TLChannelsGetSendAs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe785a43f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ForPaidReactions = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeleteParticipantHistory <--
type TLChannelsDeleteParticipantHistory struct {
	ClazzID     uint32            `json:"_id"`
	Channel     InputChannelClazz `json:"channel"`
	Participant InputPeerClazz    `json:"participant"`
}

func (m *TLChannelsDeleteParticipantHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeleteParticipantHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x367544db: func() error {
			x.PutClazzID(0x367544db)

			_ = m.Channel.Encode(x, layer)
			_ = m.Participant.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deleteParticipantHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deleteParticipantHistory, layer)
	}
}

// Decode <--
func (m *TLChannelsDeleteParticipantHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x367544db: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Participant = m2
			m.Participant, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleJoinToSend <--
type TLChannelsToggleJoinToSend struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Enabled BoolClazz         `json:"enabled"`
}

func (m *TLChannelsToggleJoinToSend) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleJoinToSend) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe4cb9580: func() error {
			x.PutClazzID(0xe4cb9580)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleJoinToSend, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleJoinToSend, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleJoinToSend) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe4cb9580: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Enabled = m2
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleJoinRequest <--
type TLChannelsToggleJoinRequest struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Enabled BoolClazz         `json:"enabled"`
}

func (m *TLChannelsToggleJoinRequest) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleJoinRequest) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4c2985b6: func() error {
			x.PutClazzID(0x4c2985b6)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleJoinRequest, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleJoinRequest, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleJoinRequest) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4c2985b6: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Enabled = m2
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReorderUsernames <--
type TLChannelsReorderUsernames struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Order   []string          `json:"order"`
}

func (m *TLChannelsReorderUsernames) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReorderUsernames) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb45ced1d: func() error {
			x.PutClazzID(0xb45ced1d)

			_ = m.Channel.Encode(x, layer)

			iface.EncodeStringList(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_reorderUsernames, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_reorderUsernames, layer)
	}
}

// Decode <--
func (m *TLChannelsReorderUsernames) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb45ced1d: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Order, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleUsername <--
type TLChannelsToggleUsername struct {
	ClazzID  uint32            `json:"_id"`
	Channel  InputChannelClazz `json:"channel"`
	Username string            `json:"username"`
	Active   BoolClazz         `json:"active"`
}

func (m *TLChannelsToggleUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x50f24105: func() error {
			x.PutClazzID(0x50f24105)

			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Username)
			_ = m.Active.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleUsername, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x50f24105: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Username, err = d.String()

			// m3 := &Bool{}
			// _ = m3.Decode(d)
			// m.Active = m3
			m.Active, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeactivateAllUsernames <--
type TLChannelsDeactivateAllUsernames struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
}

func (m *TLChannelsDeactivateAllUsernames) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeactivateAllUsernames) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa245dd3: func() error {
			x.PutClazzID(0xa245dd3)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deactivateAllUsernames, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deactivateAllUsernames, layer)
	}
}

// Decode <--
func (m *TLChannelsDeactivateAllUsernames) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa245dd3: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleForum <--
type TLChannelsToggleForum struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Enabled BoolClazz         `json:"enabled"`
	Tabs    BoolClazz         `json:"tabs"`
}

func (m *TLChannelsToggleForum) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleForum) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3ff75734: func() error {
			x.PutClazzID(0x3ff75734)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)
			_ = m.Tabs.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleForum, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleForum, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleForum) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3ff75734: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Enabled = m2
			m.Enabled, _ = DecodeBoolClazz(d)

			// m3 := &Bool{}
			// _ = m3.Decode(d)
			// m.Tabs = m3
			m.Tabs, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleAntiSpam <--
type TLChannelsToggleAntiSpam struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Enabled BoolClazz         `json:"enabled"`
}

func (m *TLChannelsToggleAntiSpam) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleAntiSpam) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x68f3e4eb: func() error {
			x.PutClazzID(0x68f3e4eb)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleAntiSpam, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleAntiSpam, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleAntiSpam) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x68f3e4eb: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Enabled = m2
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReportAntiSpamFalsePositive <--
type TLChannelsReportAntiSpamFalsePositive struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	MsgId   int32             `json:"msg_id"`
}

func (m *TLChannelsReportAntiSpamFalsePositive) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReportAntiSpamFalsePositive) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa850a693: func() error {
			x.PutClazzID(0xa850a693)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_reportAntiSpamFalsePositive, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_reportAntiSpamFalsePositive, layer)
	}
}

// Decode <--
func (m *TLChannelsReportAntiSpamFalsePositive) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa850a693: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleParticipantsHidden <--
type TLChannelsToggleParticipantsHidden struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Enabled BoolClazz         `json:"enabled"`
}

func (m *TLChannelsToggleParticipantsHidden) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleParticipantsHidden) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6a6e7854: func() error {
			x.PutClazzID(0x6a6e7854)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleParticipantsHidden, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleParticipantsHidden, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleParticipantsHidden) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6a6e7854: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Enabled = m2
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsUpdateColor <--
type TLChannelsUpdateColor struct {
	ClazzID           uint32            `json:"_id"`
	ForProfile        bool              `json:"for_profile"`
	Channel           InputChannelClazz `json:"channel"`
	Color             *int32            `json:"color"`
	BackgroundEmojiId *int64            `json:"background_emoji_id"`
}

func (m *TLChannelsUpdateColor) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsUpdateColor) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd8aa3671: func() error {
			x.PutClazzID(0xd8aa3671)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForProfile == true {
					flags |= 1 << 1
				}

				if m.Color != nil {
					flags |= 1 << 2
				}
				if m.BackgroundEmojiId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			if m.Color != nil {
				x.PutInt32(*m.Color)
			}

			if m.BackgroundEmojiId != nil {
				x.PutInt64(*m.BackgroundEmojiId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_updateColor, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_updateColor, layer)
	}
}

// Decode <--
func (m *TLChannelsUpdateColor) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd8aa3671: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.ForProfile = true
			}

			// m3 := &InputChannel{}
			// _ = m3.Decode(d)
			// m.Channel = m3
			m.Channel, _ = DecodeInputChannelClazz(d)

			if (flags & (1 << 2)) != 0 {
				m.Color = new(int32)
				*m.Color, err = d.Int32()
			}
			if (flags & (1 << 0)) != 0 {
				m.BackgroundEmojiId = new(int64)
				*m.BackgroundEmojiId, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleViewForumAsMessages <--
type TLChannelsToggleViewForumAsMessages struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Enabled BoolClazz         `json:"enabled"`
}

func (m *TLChannelsToggleViewForumAsMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleViewForumAsMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9738bb15: func() error {
			x.PutClazzID(0x9738bb15)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleViewForumAsMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleViewForumAsMessages, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleViewForumAsMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9738bb15: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Enabled = m2
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetChannelRecommendations <--
type TLChannelsGetChannelRecommendations struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
}

func (m *TLChannelsGetChannelRecommendations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetChannelRecommendations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x25a71742: func() error {
			x.PutClazzID(0x25a71742)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Channel != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Channel != nil {
				_ = m.Channel.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getChannelRecommendations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getChannelRecommendations, layer)
	}
}

// Decode <--
func (m *TLChannelsGetChannelRecommendations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x25a71742: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputChannel{}
				// _ = m2.Decode(d)
				// m.Channel = m2
				m.Channel, _ = DecodeInputChannelClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsUpdateEmojiStatus <--
type TLChannelsUpdateEmojiStatus struct {
	ClazzID     uint32            `json:"_id"`
	Channel     InputChannelClazz `json:"channel"`
	EmojiStatus EmojiStatusClazz  `json:"emoji_status"`
}

func (m *TLChannelsUpdateEmojiStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsUpdateEmojiStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf0d3e6a8: func() error {
			x.PutClazzID(0xf0d3e6a8)

			_ = m.Channel.Encode(x, layer)
			_ = m.EmojiStatus.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_updateEmojiStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_updateEmojiStatus, layer)
	}
}

// Decode <--
func (m *TLChannelsUpdateEmojiStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf0d3e6a8: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &EmojiStatus{}
			// _ = m2.Decode(d)
			// m.EmojiStatus = m2
			m.EmojiStatus, _ = DecodeEmojiStatusClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSetBoostsToUnblockRestrictions <--
type TLChannelsSetBoostsToUnblockRestrictions struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Boosts  int32             `json:"boosts"`
}

func (m *TLChannelsSetBoostsToUnblockRestrictions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSetBoostsToUnblockRestrictions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xad399cee: func() error {
			x.PutClazzID(0xad399cee)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.Boosts)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_setBoostsToUnblockRestrictions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_setBoostsToUnblockRestrictions, layer)
	}
}

// Decode <--
func (m *TLChannelsSetBoostsToUnblockRestrictions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xad399cee: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Boosts, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSetEmojiStickers <--
type TLChannelsSetEmojiStickers struct {
	ClazzID    uint32               `json:"_id"`
	Channel    InputChannelClazz    `json:"channel"`
	Stickerset InputStickerSetClazz `json:"stickerset"`
}

func (m *TLChannelsSetEmojiStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSetEmojiStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3cd930b7: func() error {
			x.PutClazzID(0x3cd930b7)

			_ = m.Channel.Encode(x, layer)
			_ = m.Stickerset.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_setEmojiStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_setEmojiStickers, layer)
	}
}

// Decode <--
func (m *TLChannelsSetEmojiStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3cd930b7: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &InputStickerSet{}
			// _ = m2.Decode(d)
			// m.Stickerset = m2
			m.Stickerset, _ = DecodeInputStickerSetClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsRestrictSponsoredMessages <--
type TLChannelsRestrictSponsoredMessages struct {
	ClazzID    uint32            `json:"_id"`
	Channel    InputChannelClazz `json:"channel"`
	Restricted BoolClazz         `json:"restricted"`
}

func (m *TLChannelsRestrictSponsoredMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsRestrictSponsoredMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9ae91519: func() error {
			x.PutClazzID(0x9ae91519)

			_ = m.Channel.Encode(x, layer)
			_ = m.Restricted.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_restrictSponsoredMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_restrictSponsoredMessages, layer)
	}
}

// Decode <--
func (m *TLChannelsRestrictSponsoredMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9ae91519: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Restricted = m2
			m.Restricted, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSearchPosts <--
type TLChannelsSearchPosts struct {
	ClazzID        uint32         `json:"_id"`
	Hashtag        *string        `json:"hashtag"`
	Query          *string        `json:"query"`
	OffsetRate     int32          `json:"offset_rate"`
	OffsetPeer     InputPeerClazz `json:"offset_peer"`
	OffsetId       int32          `json:"offset_id"`
	Limit          int32          `json:"limit"`
	AllowPaidStars *int64         `json:"allow_paid_stars"`
}

func (m *TLChannelsSearchPosts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSearchPosts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf2c4f24d: func() error {
			x.PutClazzID(0xf2c4f24d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Hashtag != nil {
					flags |= 1 << 0
				}
				if m.Query != nil {
					flags |= 1 << 1
				}

				if m.AllowPaidStars != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Hashtag != nil {
				x.PutString(*m.Hashtag)
			}

			if m.Query != nil {
				x.PutString(*m.Query)
			}

			x.PutInt32(m.OffsetRate)
			_ = m.OffsetPeer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.Limit)
			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_searchPosts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_searchPosts, layer)
	}
}

// Decode <--
func (m *TLChannelsSearchPosts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf2c4f24d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Hashtag = new(string)
				*m.Hashtag, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.Query = new(string)
				*m.Query, err = d.String()
			}

			m.OffsetRate, err = d.Int32()

			// m5 := &InputPeer{}
			// _ = m5.Decode(d)
			// m.OffsetPeer = m5
			m.OffsetPeer, _ = DecodeInputPeerClazz(d)

			m.OffsetId, err = d.Int32()
			m.Limit, err = d.Int32()
			if (flags & (1 << 2)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsUpdatePaidMessagesPrice <--
type TLChannelsUpdatePaidMessagesPrice struct {
	ClazzID                  uint32            `json:"_id"`
	BroadcastMessagesAllowed bool              `json:"broadcast_messages_allowed"`
	Channel                  InputChannelClazz `json:"channel"`
	SendPaidMessagesStars    int64             `json:"send_paid_messages_stars"`
}

func (m *TLChannelsUpdatePaidMessagesPrice) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsUpdatePaidMessagesPrice) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4b12327b: func() error {
			x.PutClazzID(0x4b12327b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.BroadcastMessagesAllowed == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutInt64(m.SendPaidMessagesStars)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_updatePaidMessagesPrice, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_updatePaidMessagesPrice, layer)
	}
}

// Decode <--
func (m *TLChannelsUpdatePaidMessagesPrice) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4b12327b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.BroadcastMessagesAllowed = true
			}

			// m3 := &InputChannel{}
			// _ = m3.Decode(d)
			// m.Channel = m3
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.SendPaidMessagesStars, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleAutotranslation <--
type TLChannelsToggleAutotranslation struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Enabled BoolClazz         `json:"enabled"`
}

func (m *TLChannelsToggleAutotranslation) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleAutotranslation) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x167fc0a1: func() error {
			x.PutClazzID(0x167fc0a1)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleAutotranslation, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleAutotranslation, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleAutotranslation) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x167fc0a1: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Enabled = m2
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetMessageAuthor <--
type TLChannelsGetMessageAuthor struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Id      int32             `json:"id"`
}

func (m *TLChannelsGetMessageAuthor) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetMessageAuthor) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xece2a0e6: func() error {
			x.PutClazzID(0xece2a0e6)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getMessageAuthor, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getMessageAuthor, layer)
	}
}

// Decode <--
func (m *TLChannelsGetMessageAuthor) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xece2a0e6: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsCheckSearchPostsFlood <--
type TLChannelsCheckSearchPostsFlood struct {
	ClazzID uint32  `json:"_id"`
	Query   *string `json:"query"`
}

func (m *TLChannelsCheckSearchPostsFlood) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsCheckSearchPostsFlood) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x22567115: func() error {
			x.PutClazzID(0x22567115)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Query != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Query != nil {
				x.PutString(*m.Query)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_checkSearchPostsFlood, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_checkSearchPostsFlood, layer)
	}
}

// Decode <--
func (m *TLChannelsCheckSearchPostsFlood) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x22567115: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Query = new(string)
				*m.Query, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSetMainProfileTab <--
type TLChannelsSetMainProfileTab struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	Tab     ProfileTabClazz   `json:"tab"`
}

func (m *TLChannelsSetMainProfileTab) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSetMainProfileTab) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3583fcb1: func() error {
			x.PutClazzID(0x3583fcb1)

			_ = m.Channel.Encode(x, layer)
			_ = m.Tab.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_setMainProfileTab, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_setMainProfileTab, layer)
	}
}

// Decode <--
func (m *TLChannelsSetMainProfileTab) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3583fcb1: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			// m2 := &ProfileTab{}
			// _ = m2.Decode(d)
			// m.Tab = m2
			m.Tab, _ = DecodeProfileTabClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSendCustomRequest <--
type TLBotsSendCustomRequest struct {
	ClazzID      uint32        `json:"_id"`
	CustomMethod string        `json:"custom_method"`
	Params       DataJSONClazz `json:"params"`
}

func (m *TLBotsSendCustomRequest) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSendCustomRequest) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaa2769ed: func() error {
			x.PutClazzID(0xaa2769ed)

			x.PutString(m.CustomMethod)
			_ = m.Params.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_sendCustomRequest, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_sendCustomRequest, layer)
	}
}

// Decode <--
func (m *TLBotsSendCustomRequest) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaa2769ed: func() (err error) {
			m.CustomMethod, err = d.String()

			// m2 := &DataJSON{}
			// _ = m2.Decode(d)
			// m.Params = m2
			m.Params, _ = DecodeDataJSONClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsAnswerWebhookJSONQuery <--
type TLBotsAnswerWebhookJSONQuery struct {
	ClazzID uint32        `json:"_id"`
	QueryId int64         `json:"query_id"`
	Data    DataJSONClazz `json:"data"`
}

func (m *TLBotsAnswerWebhookJSONQuery) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsAnswerWebhookJSONQuery) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe6213f4d: func() error {
			x.PutClazzID(0xe6213f4d)

			x.PutInt64(m.QueryId)
			_ = m.Data.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_answerWebhookJSONQuery, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_answerWebhookJSONQuery, layer)
	}
}

// Decode <--
func (m *TLBotsAnswerWebhookJSONQuery) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe6213f4d: func() (err error) {
			m.QueryId, err = d.Int64()

			// m2 := &DataJSON{}
			// _ = m2.Decode(d)
			// m.Data = m2
			m.Data, _ = DecodeDataJSONClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetBotCommands <--
type TLBotsSetBotCommands struct {
	ClazzID  uint32               `json:"_id"`
	Scope    BotCommandScopeClazz `json:"scope"`
	LangCode string               `json:"lang_code"`
	Commands []BotCommandClazz    `json:"commands"`
}

func (m *TLBotsSetBotCommands) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetBotCommands) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x517165a: func() error {
			x.PutClazzID(0x517165a)

			_ = m.Scope.Encode(x, layer)
			x.PutString(m.LangCode)

			_ = iface.EncodeObjectList(x, m.Commands, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setBotCommands, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setBotCommands, layer)
	}
}

// Decode <--
func (m *TLBotsSetBotCommands) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x517165a: func() (err error) {

			// m1 := &BotCommandScope{}
			// _ = m1.Decode(d)
			// m.Scope = m1
			m.Scope, _ = DecodeBotCommandScopeClazz(d)

			m.LangCode, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			// v3 := make([]*BotCommand, l3)
			v3 := make([]BotCommandClazz, l3)
			for i := 0; i < l3; i++ {
				// vv := new(BotCommand)
				// err3 = vv.Decode(d)
				// _ = err3
				// v3[i] = vv
				v3[i], _ = DecodeBotCommandClazz(d)
				_ = err3
			}
			m.Commands = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsResetBotCommands <--
type TLBotsResetBotCommands struct {
	ClazzID  uint32               `json:"_id"`
	Scope    BotCommandScopeClazz `json:"scope"`
	LangCode string               `json:"lang_code"`
}

func (m *TLBotsResetBotCommands) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsResetBotCommands) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3d8de0f9: func() error {
			x.PutClazzID(0x3d8de0f9)

			_ = m.Scope.Encode(x, layer)
			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_resetBotCommands, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_resetBotCommands, layer)
	}
}

// Decode <--
func (m *TLBotsResetBotCommands) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3d8de0f9: func() (err error) {

			// m1 := &BotCommandScope{}
			// _ = m1.Decode(d)
			// m.Scope = m1
			m.Scope, _ = DecodeBotCommandScopeClazz(d)

			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetBotCommands <--
type TLBotsGetBotCommands struct {
	ClazzID  uint32               `json:"_id"`
	Scope    BotCommandScopeClazz `json:"scope"`
	LangCode string               `json:"lang_code"`
}

func (m *TLBotsGetBotCommands) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetBotCommands) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe34c0dd6: func() error {
			x.PutClazzID(0xe34c0dd6)

			_ = m.Scope.Encode(x, layer)
			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getBotCommands, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getBotCommands, layer)
	}
}

// Decode <--
func (m *TLBotsGetBotCommands) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe34c0dd6: func() (err error) {

			// m1 := &BotCommandScope{}
			// _ = m1.Decode(d)
			// m.Scope = m1
			m.Scope, _ = DecodeBotCommandScopeClazz(d)

			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetBotMenuButton <--
type TLBotsSetBotMenuButton struct {
	ClazzID uint32             `json:"_id"`
	UserId  InputUserClazz     `json:"user_id"`
	Button  BotMenuButtonClazz `json:"button"`
}

func (m *TLBotsSetBotMenuButton) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetBotMenuButton) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4504d54f: func() error {
			x.PutClazzID(0x4504d54f)

			_ = m.UserId.Encode(x, layer)
			_ = m.Button.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setBotMenuButton, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setBotMenuButton, layer)
	}
}

// Decode <--
func (m *TLBotsSetBotMenuButton) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4504d54f: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.UserId = m1
			m.UserId, _ = DecodeInputUserClazz(d)

			// m2 := &BotMenuButton{}
			// _ = m2.Decode(d)
			// m.Button = m2
			m.Button, _ = DecodeBotMenuButtonClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetBotMenuButton <--
type TLBotsGetBotMenuButton struct {
	ClazzID uint32         `json:"_id"`
	UserId  InputUserClazz `json:"user_id"`
}

func (m *TLBotsGetBotMenuButton) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetBotMenuButton) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9c60eb28: func() error {
			x.PutClazzID(0x9c60eb28)

			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getBotMenuButton, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getBotMenuButton, layer)
	}
}

// Decode <--
func (m *TLBotsGetBotMenuButton) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9c60eb28: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.UserId = m1
			m.UserId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetBotBroadcastDefaultAdminRights <--
type TLBotsSetBotBroadcastDefaultAdminRights struct {
	ClazzID     uint32               `json:"_id"`
	AdminRights ChatAdminRightsClazz `json:"admin_rights"`
}

func (m *TLBotsSetBotBroadcastDefaultAdminRights) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetBotBroadcastDefaultAdminRights) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x788464e1: func() error {
			x.PutClazzID(0x788464e1)

			_ = m.AdminRights.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setBotBroadcastDefaultAdminRights, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setBotBroadcastDefaultAdminRights, layer)
	}
}

// Decode <--
func (m *TLBotsSetBotBroadcastDefaultAdminRights) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x788464e1: func() (err error) {

			// m1 := &ChatAdminRights{}
			// _ = m1.Decode(d)
			// m.AdminRights = m1
			m.AdminRights, _ = DecodeChatAdminRightsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetBotGroupDefaultAdminRights <--
type TLBotsSetBotGroupDefaultAdminRights struct {
	ClazzID     uint32               `json:"_id"`
	AdminRights ChatAdminRightsClazz `json:"admin_rights"`
}

func (m *TLBotsSetBotGroupDefaultAdminRights) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetBotGroupDefaultAdminRights) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x925ec9ea: func() error {
			x.PutClazzID(0x925ec9ea)

			_ = m.AdminRights.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setBotGroupDefaultAdminRights, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setBotGroupDefaultAdminRights, layer)
	}
}

// Decode <--
func (m *TLBotsSetBotGroupDefaultAdminRights) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x925ec9ea: func() (err error) {

			// m1 := &ChatAdminRights{}
			// _ = m1.Decode(d)
			// m.AdminRights = m1
			m.AdminRights, _ = DecodeChatAdminRightsClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetBotInfo <--
type TLBotsSetBotInfo struct {
	ClazzID     uint32         `json:"_id"`
	Bot         InputUserClazz `json:"bot"`
	LangCode    string         `json:"lang_code"`
	Name        *string        `json:"name"`
	About       *string        `json:"about"`
	Description *string        `json:"description"`
}

func (m *TLBotsSetBotInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetBotInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x10cf3123: func() error {
			x.PutClazzID(0x10cf3123)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Bot != nil {
					flags |= 1 << 2
				}

				if m.Name != nil {
					flags |= 1 << 3
				}
				if m.About != nil {
					flags |= 1 << 0
				}
				if m.Description != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Bot != nil {
				_ = m.Bot.Encode(x, layer)
			}

			x.PutString(m.LangCode)
			if m.Name != nil {
				x.PutString(*m.Name)
			}

			if m.About != nil {
				x.PutString(*m.About)
			}

			if m.Description != nil {
				x.PutString(*m.Description)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setBotInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setBotInfo, layer)
	}
}

// Decode <--
func (m *TLBotsSetBotInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x10cf3123: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				// m2 := &InputUser{}
				// _ = m2.Decode(d)
				// m.Bot = m2
				m.Bot, _ = DecodeInputUserClazz(d)
			}
			m.LangCode, err = d.String()
			if (flags & (1 << 3)) != 0 {
				m.Name = new(string)
				*m.Name, err = d.String()
			}

			if (flags & (1 << 0)) != 0 {
				m.About = new(string)
				*m.About, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.Description = new(string)
				*m.Description, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetBotInfo <--
type TLBotsGetBotInfo struct {
	ClazzID  uint32         `json:"_id"`
	Bot      InputUserClazz `json:"bot"`
	LangCode string         `json:"lang_code"`
}

func (m *TLBotsGetBotInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetBotInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdcd914fd: func() error {
			x.PutClazzID(0xdcd914fd)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Bot != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Bot != nil {
				_ = m.Bot.Encode(x, layer)
			}

			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getBotInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getBotInfo, layer)
	}
}

// Decode <--
func (m *TLBotsGetBotInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdcd914fd: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputUser{}
				// _ = m2.Decode(d)
				// m.Bot = m2
				m.Bot, _ = DecodeInputUserClazz(d)
			}
			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsReorderUsernames <--
type TLBotsReorderUsernames struct {
	ClazzID uint32         `json:"_id"`
	Bot     InputUserClazz `json:"bot"`
	Order   []string       `json:"order"`
}

func (m *TLBotsReorderUsernames) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsReorderUsernames) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9709b1c2: func() error {
			x.PutClazzID(0x9709b1c2)

			_ = m.Bot.Encode(x, layer)

			iface.EncodeStringList(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_reorderUsernames, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_reorderUsernames, layer)
	}
}

// Decode <--
func (m *TLBotsReorderUsernames) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9709b1c2: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.Order, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsToggleUsername <--
type TLBotsToggleUsername struct {
	ClazzID  uint32         `json:"_id"`
	Bot      InputUserClazz `json:"bot"`
	Username string         `json:"username"`
	Active   BoolClazz      `json:"active"`
}

func (m *TLBotsToggleUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsToggleUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x53ca973: func() error {
			x.PutClazzID(0x53ca973)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.Username)
			_ = m.Active.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_toggleUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_toggleUsername, layer)
	}
}

// Decode <--
func (m *TLBotsToggleUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x53ca973: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.Username, err = d.String()

			// m3 := &Bool{}
			// _ = m3.Decode(d)
			// m.Active = m3
			m.Active, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsCanSendMessage <--
type TLBotsCanSendMessage struct {
	ClazzID uint32         `json:"_id"`
	Bot     InputUserClazz `json:"bot"`
}

func (m *TLBotsCanSendMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsCanSendMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1359f4e6: func() error {
			x.PutClazzID(0x1359f4e6)

			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_canSendMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_canSendMessage, layer)
	}
}

// Decode <--
func (m *TLBotsCanSendMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1359f4e6: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsAllowSendMessage <--
type TLBotsAllowSendMessage struct {
	ClazzID uint32         `json:"_id"`
	Bot     InputUserClazz `json:"bot"`
}

func (m *TLBotsAllowSendMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsAllowSendMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf132e3ef: func() error {
			x.PutClazzID(0xf132e3ef)

			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_allowSendMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_allowSendMessage, layer)
	}
}

// Decode <--
func (m *TLBotsAllowSendMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf132e3ef: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsInvokeWebViewCustomMethod <--
type TLBotsInvokeWebViewCustomMethod struct {
	ClazzID      uint32         `json:"_id"`
	Bot          InputUserClazz `json:"bot"`
	CustomMethod string         `json:"custom_method"`
	Params       DataJSONClazz  `json:"params"`
}

func (m *TLBotsInvokeWebViewCustomMethod) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsInvokeWebViewCustomMethod) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x87fc5e7: func() error {
			x.PutClazzID(0x87fc5e7)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.CustomMethod)
			_ = m.Params.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_invokeWebViewCustomMethod, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_invokeWebViewCustomMethod, layer)
	}
}

// Decode <--
func (m *TLBotsInvokeWebViewCustomMethod) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x87fc5e7: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.CustomMethod, err = d.String()

			// m3 := &DataJSON{}
			// _ = m3.Decode(d)
			// m.Params = m3
			m.Params, _ = DecodeDataJSONClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetPopularAppBots <--
type TLBotsGetPopularAppBots struct {
	ClazzID uint32 `json:"_id"`
	Offset  string `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (m *TLBotsGetPopularAppBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetPopularAppBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc2510192: func() error {
			x.PutClazzID(0xc2510192)

			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getPopularAppBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getPopularAppBots, layer)
	}
}

// Decode <--
func (m *TLBotsGetPopularAppBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc2510192: func() (err error) {
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsAddPreviewMedia <--
type TLBotsAddPreviewMedia struct {
	ClazzID  uint32          `json:"_id"`
	Bot      InputUserClazz  `json:"bot"`
	LangCode string          `json:"lang_code"`
	Media    InputMediaClazz `json:"media"`
}

func (m *TLBotsAddPreviewMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsAddPreviewMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x17aeb75a: func() error {
			x.PutClazzID(0x17aeb75a)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.LangCode)
			_ = m.Media.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_addPreviewMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_addPreviewMedia, layer)
	}
}

// Decode <--
func (m *TLBotsAddPreviewMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x17aeb75a: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.LangCode, err = d.String()

			// m3 := &InputMedia{}
			// _ = m3.Decode(d)
			// m.Media = m3
			m.Media, _ = DecodeInputMediaClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsEditPreviewMedia <--
type TLBotsEditPreviewMedia struct {
	ClazzID  uint32          `json:"_id"`
	Bot      InputUserClazz  `json:"bot"`
	LangCode string          `json:"lang_code"`
	Media    InputMediaClazz `json:"media"`
	NewMedia InputMediaClazz `json:"new_media"`
}

func (m *TLBotsEditPreviewMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsEditPreviewMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8525606f: func() error {
			x.PutClazzID(0x8525606f)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.LangCode)
			_ = m.Media.Encode(x, layer)
			_ = m.NewMedia.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_editPreviewMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_editPreviewMedia, layer)
	}
}

// Decode <--
func (m *TLBotsEditPreviewMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8525606f: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.LangCode, err = d.String()

			// m3 := &InputMedia{}
			// _ = m3.Decode(d)
			// m.Media = m3
			m.Media, _ = DecodeInputMediaClazz(d)

			// m4 := &InputMedia{}
			// _ = m4.Decode(d)
			// m.NewMedia = m4
			m.NewMedia, _ = DecodeInputMediaClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsDeletePreviewMedia <--
type TLBotsDeletePreviewMedia struct {
	ClazzID  uint32            `json:"_id"`
	Bot      InputUserClazz    `json:"bot"`
	LangCode string            `json:"lang_code"`
	Media    []InputMediaClazz `json:"media"`
}

func (m *TLBotsDeletePreviewMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsDeletePreviewMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2d0135b3: func() error {
			x.PutClazzID(0x2d0135b3)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.LangCode)

			_ = iface.EncodeObjectList(x, m.Media, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_deletePreviewMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_deletePreviewMedia, layer)
	}
}

// Decode <--
func (m *TLBotsDeletePreviewMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2d0135b3: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.LangCode, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			// v3 := make([]*InputMedia, l3)
			v3 := make([]InputMediaClazz, l3)
			for i := 0; i < l3; i++ {
				// vv := new(InputMedia)
				// err3 = vv.Decode(d)
				// _ = err3
				// v3[i] = vv
				v3[i], _ = DecodeInputMediaClazz(d)
				_ = err3
			}
			m.Media = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsReorderPreviewMedias <--
type TLBotsReorderPreviewMedias struct {
	ClazzID  uint32            `json:"_id"`
	Bot      InputUserClazz    `json:"bot"`
	LangCode string            `json:"lang_code"`
	Order    []InputMediaClazz `json:"order"`
}

func (m *TLBotsReorderPreviewMedias) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsReorderPreviewMedias) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb627f3aa: func() error {
			x.PutClazzID(0xb627f3aa)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.LangCode)

			_ = iface.EncodeObjectList(x, m.Order, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_reorderPreviewMedias, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_reorderPreviewMedias, layer)
	}
}

// Decode <--
func (m *TLBotsReorderPreviewMedias) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb627f3aa: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.LangCode, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			// v3 := make([]*InputMedia, l3)
			v3 := make([]InputMediaClazz, l3)
			for i := 0; i < l3; i++ {
				// vv := new(InputMedia)
				// err3 = vv.Decode(d)
				// _ = err3
				// v3[i] = vv
				v3[i], _ = DecodeInputMediaClazz(d)
				_ = err3
			}
			m.Order = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetPreviewInfo <--
type TLBotsGetPreviewInfo struct {
	ClazzID  uint32         `json:"_id"`
	Bot      InputUserClazz `json:"bot"`
	LangCode string         `json:"lang_code"`
}

func (m *TLBotsGetPreviewInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetPreviewInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x423ab3ad: func() error {
			x.PutClazzID(0x423ab3ad)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getPreviewInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getPreviewInfo, layer)
	}
}

// Decode <--
func (m *TLBotsGetPreviewInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x423ab3ad: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetPreviewMedias <--
type TLBotsGetPreviewMedias struct {
	ClazzID uint32         `json:"_id"`
	Bot     InputUserClazz `json:"bot"`
}

func (m *TLBotsGetPreviewMedias) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetPreviewMedias) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa2a5594d: func() error {
			x.PutClazzID(0xa2a5594d)

			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getPreviewMedias, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getPreviewMedias, layer)
	}
}

// Decode <--
func (m *TLBotsGetPreviewMedias) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa2a5594d: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsUpdateUserEmojiStatus <--
type TLBotsUpdateUserEmojiStatus struct {
	ClazzID     uint32           `json:"_id"`
	UserId      InputUserClazz   `json:"user_id"`
	EmojiStatus EmojiStatusClazz `json:"emoji_status"`
}

func (m *TLBotsUpdateUserEmojiStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsUpdateUserEmojiStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xed9f30c5: func() error {
			x.PutClazzID(0xed9f30c5)

			_ = m.UserId.Encode(x, layer)
			_ = m.EmojiStatus.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_updateUserEmojiStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_updateUserEmojiStatus, layer)
	}
}

// Decode <--
func (m *TLBotsUpdateUserEmojiStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xed9f30c5: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.UserId = m1
			m.UserId, _ = DecodeInputUserClazz(d)

			// m2 := &EmojiStatus{}
			// _ = m2.Decode(d)
			// m.EmojiStatus = m2
			m.EmojiStatus, _ = DecodeEmojiStatusClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsToggleUserEmojiStatusPermission <--
type TLBotsToggleUserEmojiStatusPermission struct {
	ClazzID uint32         `json:"_id"`
	Bot     InputUserClazz `json:"bot"`
	Enabled BoolClazz      `json:"enabled"`
}

func (m *TLBotsToggleUserEmojiStatusPermission) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsToggleUserEmojiStatusPermission) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6de6392: func() error {
			x.PutClazzID(0x6de6392)

			_ = m.Bot.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_toggleUserEmojiStatusPermission, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_toggleUserEmojiStatusPermission, layer)
	}
}

// Decode <--
func (m *TLBotsToggleUserEmojiStatusPermission) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6de6392: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Enabled = m2
			m.Enabled, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsCheckDownloadFileParams <--
type TLBotsCheckDownloadFileParams struct {
	ClazzID  uint32         `json:"_id"`
	Bot      InputUserClazz `json:"bot"`
	FileName string         `json:"file_name"`
	Url      string         `json:"url"`
}

func (m *TLBotsCheckDownloadFileParams) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsCheckDownloadFileParams) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x50077589: func() error {
			x.PutClazzID(0x50077589)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.FileName)
			x.PutString(m.Url)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_checkDownloadFileParams, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_checkDownloadFileParams, layer)
	}
}

// Decode <--
func (m *TLBotsCheckDownloadFileParams) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x50077589: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			m.FileName, err = d.String()
			m.Url, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetAdminedBots <--
type TLBotsGetAdminedBots struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLBotsGetAdminedBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetAdminedBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb0711d83: func() error {
			x.PutClazzID(0xb0711d83)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getAdminedBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getAdminedBots, layer)
	}
}

// Decode <--
func (m *TLBotsGetAdminedBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb0711d83: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsUpdateStarRefProgram <--
type TLBotsUpdateStarRefProgram struct {
	ClazzID            uint32         `json:"_id"`
	Bot                InputUserClazz `json:"bot"`
	CommissionPermille int32          `json:"commission_permille"`
	DurationMonths     *int32         `json:"duration_months"`
}

func (m *TLBotsUpdateStarRefProgram) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsUpdateStarRefProgram) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x778b5ab3: func() error {
			x.PutClazzID(0x778b5ab3)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.DurationMonths != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Bot.Encode(x, layer)
			x.PutInt32(m.CommissionPermille)
			if m.DurationMonths != nil {
				x.PutInt32(*m.DurationMonths)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_updateStarRefProgram, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_updateStarRefProgram, layer)
	}
}

// Decode <--
func (m *TLBotsUpdateStarRefProgram) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x778b5ab3: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.Bot = m2
			m.Bot, _ = DecodeInputUserClazz(d)

			m.CommissionPermille, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.DurationMonths = new(int32)
				*m.DurationMonths, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetCustomVerification <--
type TLBotsSetCustomVerification struct {
	ClazzID           uint32         `json:"_id"`
	Enabled           bool           `json:"enabled"`
	Bot               InputUserClazz `json:"bot"`
	Peer              InputPeerClazz `json:"peer"`
	CustomDescription *string        `json:"custom_description"`
}

func (m *TLBotsSetCustomVerification) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetCustomVerification) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8b89dfbd: func() error {
			x.PutClazzID(0x8b89dfbd)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Enabled == true {
					flags |= 1 << 1
				}
				if m.Bot != nil {
					flags |= 1 << 0
				}

				if m.CustomDescription != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Bot != nil {
				_ = m.Bot.Encode(x, layer)
			}

			_ = m.Peer.Encode(x, layer)
			if m.CustomDescription != nil {
				x.PutString(*m.CustomDescription)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setCustomVerification, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setCustomVerification, layer)
	}
}

// Decode <--
func (m *TLBotsSetCustomVerification) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8b89dfbd: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Enabled = true
			}
			if (flags & (1 << 0)) != 0 {
				// m3 := &InputUser{}
				// _ = m3.Decode(d)
				// m.Bot = m3
				m.Bot, _ = DecodeInputUserClazz(d)
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 2)) != 0 {
				m.CustomDescription = new(string)
				*m.CustomDescription, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetBotRecommendations <--
type TLBotsGetBotRecommendations struct {
	ClazzID uint32         `json:"_id"`
	Bot     InputUserClazz `json:"bot"`
}

func (m *TLBotsGetBotRecommendations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetBotRecommendations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa1b70815: func() error {
			x.PutClazzID(0xa1b70815)

			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getBotRecommendations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getBotRecommendations, layer)
	}
}

// Decode <--
func (m *TLBotsGetBotRecommendations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa1b70815: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.Bot = m1
			m.Bot, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetPaymentForm <--
type TLPaymentsGetPaymentForm struct {
	ClazzID     uint32            `json:"_id"`
	Invoice     InputInvoiceClazz `json:"invoice"`
	ThemeParams DataJSONClazz     `json:"theme_params"`
}

func (m *TLPaymentsGetPaymentForm) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetPaymentForm) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x37148dbb: func() error {
			x.PutClazzID(0x37148dbb)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ThemeParams != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Invoice.Encode(x, layer)
			if m.ThemeParams != nil {
				_ = m.ThemeParams.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getPaymentForm, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getPaymentForm, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetPaymentForm) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x37148dbb: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputInvoice{}
			// _ = m2.Decode(d)
			// m.Invoice = m2
			m.Invoice, _ = DecodeInputInvoiceClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m3 := &DataJSON{}
				// _ = m3.Decode(d)
				// m.ThemeParams = m3
				m.ThemeParams, _ = DecodeDataJSONClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetPaymentReceipt <--
type TLPaymentsGetPaymentReceipt struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   int32          `json:"msg_id"`
}

func (m *TLPaymentsGetPaymentReceipt) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetPaymentReceipt) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2478d1cc: func() error {
			x.PutClazzID(0x2478d1cc)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getPaymentReceipt, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getPaymentReceipt, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetPaymentReceipt) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2478d1cc: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsValidateRequestedInfo <--
type TLPaymentsValidateRequestedInfo struct {
	ClazzID uint32                    `json:"_id"`
	Save    bool                      `json:"save"`
	Invoice InputInvoiceClazz         `json:"invoice"`
	Info    PaymentRequestedInfoClazz `json:"info"`
}

func (m *TLPaymentsValidateRequestedInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsValidateRequestedInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb6c8f12b: func() error {
			x.PutClazzID(0xb6c8f12b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Save == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Invoice.Encode(x, layer)
			_ = m.Info.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_validateRequestedInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_validateRequestedInfo, layer)
	}
}

// Decode <--
func (m *TLPaymentsValidateRequestedInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb6c8f12b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Save = true
			}

			// m3 := &InputInvoice{}
			// _ = m3.Decode(d)
			// m.Invoice = m3
			m.Invoice, _ = DecodeInputInvoiceClazz(d)

			// m4 := &PaymentRequestedInfo{}
			// _ = m4.Decode(d)
			// m.Info = m4
			m.Info, _ = DecodePaymentRequestedInfoClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsSendPaymentForm <--
type TLPaymentsSendPaymentForm struct {
	ClazzID          uint32                       `json:"_id"`
	FormId           int64                        `json:"form_id"`
	Invoice          InputInvoiceClazz            `json:"invoice"`
	RequestedInfoId  *string                      `json:"requested_info_id"`
	ShippingOptionId *string                      `json:"shipping_option_id"`
	Credentials      InputPaymentCredentialsClazz `json:"credentials"`
	TipAmount        *int64                       `json:"tip_amount"`
}

func (m *TLPaymentsSendPaymentForm) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsSendPaymentForm) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2d03522f: func() error {
			x.PutClazzID(0x2d03522f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.RequestedInfoId != nil {
					flags |= 1 << 0
				}
				if m.ShippingOptionId != nil {
					flags |= 1 << 1
				}

				if m.TipAmount != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.FormId)
			_ = m.Invoice.Encode(x, layer)
			if m.RequestedInfoId != nil {
				x.PutString(*m.RequestedInfoId)
			}

			if m.ShippingOptionId != nil {
				x.PutString(*m.ShippingOptionId)
			}

			_ = m.Credentials.Encode(x, layer)
			if m.TipAmount != nil {
				x.PutInt64(*m.TipAmount)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_sendPaymentForm, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_sendPaymentForm, layer)
	}
}

// Decode <--
func (m *TLPaymentsSendPaymentForm) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2d03522f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.FormId, err = d.Int64()

			// m3 := &InputInvoice{}
			// _ = m3.Decode(d)
			// m.Invoice = m3
			m.Invoice, _ = DecodeInputInvoiceClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.RequestedInfoId = new(string)
				*m.RequestedInfoId, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.ShippingOptionId = new(string)
				*m.ShippingOptionId, err = d.String()
			}

			// m6 := &InputPaymentCredentials{}
			// _ = m6.Decode(d)
			// m.Credentials = m6
			m.Credentials, _ = DecodeInputPaymentCredentialsClazz(d)

			if (flags & (1 << 2)) != 0 {
				m.TipAmount = new(int64)
				*m.TipAmount, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetSavedInfo <--
type TLPaymentsGetSavedInfo struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPaymentsGetSavedInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetSavedInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x227d824b: func() error {
			x.PutClazzID(0x227d824b)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getSavedInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getSavedInfo, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetSavedInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x227d824b: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsClearSavedInfo <--
type TLPaymentsClearSavedInfo struct {
	ClazzID     uint32 `json:"_id"`
	Credentials bool   `json:"credentials"`
	Info        bool   `json:"info"`
}

func (m *TLPaymentsClearSavedInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsClearSavedInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd83d70c1: func() error {
			x.PutClazzID(0xd83d70c1)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Credentials == true {
					flags |= 1 << 0
				}
				if m.Info == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_clearSavedInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_clearSavedInfo, layer)
	}
}

// Decode <--
func (m *TLPaymentsClearSavedInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd83d70c1: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Credentials = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Info = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetBankCardData <--
type TLPaymentsGetBankCardData struct {
	ClazzID uint32 `json:"_id"`
	Number  string `json:"number"`
}

func (m *TLPaymentsGetBankCardData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetBankCardData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2e79d779: func() error {
			x.PutClazzID(0x2e79d779)

			x.PutString(m.Number)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getBankCardData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getBankCardData, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetBankCardData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2e79d779: func() (err error) {
			m.Number, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsExportInvoice <--
type TLPaymentsExportInvoice struct {
	ClazzID      uint32          `json:"_id"`
	InvoiceMedia InputMediaClazz `json:"invoice_media"`
}

func (m *TLPaymentsExportInvoice) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsExportInvoice) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf91b065: func() error {
			x.PutClazzID(0xf91b065)

			_ = m.InvoiceMedia.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_exportInvoice, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_exportInvoice, layer)
	}
}

// Decode <--
func (m *TLPaymentsExportInvoice) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf91b065: func() (err error) {

			// m1 := &InputMedia{}
			// _ = m1.Decode(d)
			// m.InvoiceMedia = m1
			m.InvoiceMedia, _ = DecodeInputMediaClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsAssignAppStoreTransaction <--
type TLPaymentsAssignAppStoreTransaction struct {
	ClazzID uint32                        `json:"_id"`
	Receipt []byte                        `json:"receipt"`
	Purpose InputStorePaymentPurposeClazz `json:"purpose"`
}

func (m *TLPaymentsAssignAppStoreTransaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsAssignAppStoreTransaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x80ed747d: func() error {
			x.PutClazzID(0x80ed747d)

			x.PutBytes(m.Receipt)
			_ = m.Purpose.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_assignAppStoreTransaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_assignAppStoreTransaction, layer)
	}
}

// Decode <--
func (m *TLPaymentsAssignAppStoreTransaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x80ed747d: func() (err error) {
			m.Receipt, err = d.Bytes()

			// m2 := &InputStorePaymentPurpose{}
			// _ = m2.Decode(d)
			// m.Purpose = m2
			m.Purpose, _ = DecodeInputStorePaymentPurposeClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsAssignPlayMarketTransaction <--
type TLPaymentsAssignPlayMarketTransaction struct {
	ClazzID uint32                        `json:"_id"`
	Receipt DataJSONClazz                 `json:"receipt"`
	Purpose InputStorePaymentPurposeClazz `json:"purpose"`
}

func (m *TLPaymentsAssignPlayMarketTransaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsAssignPlayMarketTransaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdffd50d3: func() error {
			x.PutClazzID(0xdffd50d3)

			_ = m.Receipt.Encode(x, layer)
			_ = m.Purpose.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_assignPlayMarketTransaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_assignPlayMarketTransaction, layer)
	}
}

// Decode <--
func (m *TLPaymentsAssignPlayMarketTransaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdffd50d3: func() (err error) {

			// m1 := &DataJSON{}
			// _ = m1.Decode(d)
			// m.Receipt = m1
			m.Receipt, _ = DecodeDataJSONClazz(d)

			// m2 := &InputStorePaymentPurpose{}
			// _ = m2.Decode(d)
			// m.Purpose = m2
			m.Purpose, _ = DecodeInputStorePaymentPurposeClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetPremiumGiftCodeOptions <--
type TLPaymentsGetPremiumGiftCodeOptions struct {
	ClazzID   uint32         `json:"_id"`
	BoostPeer InputPeerClazz `json:"boost_peer"`
}

func (m *TLPaymentsGetPremiumGiftCodeOptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetPremiumGiftCodeOptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2757ba54: func() error {
			x.PutClazzID(0x2757ba54)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.BoostPeer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.BoostPeer != nil {
				_ = m.BoostPeer.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getPremiumGiftCodeOptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getPremiumGiftCodeOptions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetPremiumGiftCodeOptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2757ba54: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputPeer{}
				// _ = m2.Decode(d)
				// m.BoostPeer = m2
				m.BoostPeer, _ = DecodeInputPeerClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsCheckGiftCode <--
type TLPaymentsCheckGiftCode struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLPaymentsCheckGiftCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsCheckGiftCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8e51b4c1: func() error {
			x.PutClazzID(0x8e51b4c1)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_checkGiftCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_checkGiftCode, layer)
	}
}

// Decode <--
func (m *TLPaymentsCheckGiftCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8e51b4c1: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsApplyGiftCode <--
type TLPaymentsApplyGiftCode struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLPaymentsApplyGiftCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsApplyGiftCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf6e26854: func() error {
			x.PutClazzID(0xf6e26854)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_applyGiftCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_applyGiftCode, layer)
	}
}

// Decode <--
func (m *TLPaymentsApplyGiftCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf6e26854: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetGiveawayInfo <--
type TLPaymentsGetGiveawayInfo struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MsgId   int32          `json:"msg_id"`
}

func (m *TLPaymentsGetGiveawayInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetGiveawayInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf4239425: func() error {
			x.PutClazzID(0xf4239425)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getGiveawayInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getGiveawayInfo, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetGiveawayInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf4239425: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsLaunchPrepaidGiveaway <--
type TLPaymentsLaunchPrepaidGiveaway struct {
	ClazzID    uint32                        `json:"_id"`
	Peer       InputPeerClazz                `json:"peer"`
	GiveawayId int64                         `json:"giveaway_id"`
	Purpose    InputStorePaymentPurposeClazz `json:"purpose"`
}

func (m *TLPaymentsLaunchPrepaidGiveaway) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsLaunchPrepaidGiveaway) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5ff58f20: func() error {
			x.PutClazzID(0x5ff58f20)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.GiveawayId)
			_ = m.Purpose.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_launchPrepaidGiveaway, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_launchPrepaidGiveaway, layer)
	}
}

// Decode <--
func (m *TLPaymentsLaunchPrepaidGiveaway) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5ff58f20: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.GiveawayId, err = d.Int64()

			// m3 := &InputStorePaymentPurpose{}
			// _ = m3.Decode(d)
			// m.Purpose = m3
			m.Purpose, _ = DecodeInputStorePaymentPurposeClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsTopupOptions <--
type TLPaymentsGetStarsTopupOptions struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPaymentsGetStarsTopupOptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsTopupOptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc00ec7d3: func() error {
			x.PutClazzID(0xc00ec7d3)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsTopupOptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsTopupOptions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsTopupOptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc00ec7d3: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsStatus <--
type TLPaymentsGetStarsStatus struct {
	ClazzID uint32         `json:"_id"`
	Ton     bool           `json:"ton"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLPaymentsGetStarsStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4ea9b3bf: func() error {
			x.PutClazzID(0x4ea9b3bf)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Ton == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsStatus, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4ea9b3bf: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Ton = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsTransactions <--
type TLPaymentsGetStarsTransactions struct {
	ClazzID        uint32         `json:"_id"`
	Inbound        bool           `json:"inbound"`
	Outbound       bool           `json:"outbound"`
	Ascending      bool           `json:"ascending"`
	Ton            bool           `json:"ton"`
	SubscriptionId *string        `json:"subscription_id"`
	Peer           InputPeerClazz `json:"peer"`
	Offset         string         `json:"offset"`
	Limit          int32          `json:"limit"`
}

func (m *TLPaymentsGetStarsTransactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsTransactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x69da4557: func() error {
			x.PutClazzID(0x69da4557)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Inbound == true {
					flags |= 1 << 0
				}
				if m.Outbound == true {
					flags |= 1 << 1
				}
				if m.Ascending == true {
					flags |= 1 << 2
				}
				if m.Ton == true {
					flags |= 1 << 4
				}
				if m.SubscriptionId != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.SubscriptionId != nil {
				x.PutString(*m.SubscriptionId)
			}

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsTransactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsTransactions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsTransactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x69da4557: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Inbound = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Outbound = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Ascending = true
			}
			if (flags & (1 << 4)) != 0 {
				m.Ton = true
			}
			if (flags & (1 << 3)) != 0 {
				m.SubscriptionId = new(string)
				*m.SubscriptionId, err = d.String()
			}

			// m7 := &InputPeer{}
			// _ = m7.Decode(d)
			// m.Peer = m7
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsSendStarsForm <--
type TLPaymentsSendStarsForm struct {
	ClazzID uint32            `json:"_id"`
	FormId  int64             `json:"form_id"`
	Invoice InputInvoiceClazz `json:"invoice"`
}

func (m *TLPaymentsSendStarsForm) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsSendStarsForm) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7998c914: func() error {
			x.PutClazzID(0x7998c914)

			x.PutInt64(m.FormId)
			_ = m.Invoice.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_sendStarsForm, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_sendStarsForm, layer)
	}
}

// Decode <--
func (m *TLPaymentsSendStarsForm) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7998c914: func() (err error) {
			m.FormId, err = d.Int64()

			// m2 := &InputInvoice{}
			// _ = m2.Decode(d)
			// m.Invoice = m2
			m.Invoice, _ = DecodeInputInvoiceClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsRefundStarsCharge <--
type TLPaymentsRefundStarsCharge struct {
	ClazzID  uint32         `json:"_id"`
	UserId   InputUserClazz `json:"user_id"`
	ChargeId string         `json:"charge_id"`
}

func (m *TLPaymentsRefundStarsCharge) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsRefundStarsCharge) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x25ae8f4a: func() error {
			x.PutClazzID(0x25ae8f4a)

			_ = m.UserId.Encode(x, layer)
			x.PutString(m.ChargeId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_refundStarsCharge, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_refundStarsCharge, layer)
	}
}

// Decode <--
func (m *TLPaymentsRefundStarsCharge) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x25ae8f4a: func() (err error) {

			// m1 := &InputUser{}
			// _ = m1.Decode(d)
			// m.UserId = m1
			m.UserId, _ = DecodeInputUserClazz(d)

			m.ChargeId, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsRevenueStats <--
type TLPaymentsGetStarsRevenueStats struct {
	ClazzID uint32         `json:"_id"`
	Dark    bool           `json:"dark"`
	Ton     bool           `json:"ton"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLPaymentsGetStarsRevenueStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsRevenueStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd91ffad6: func() error {
			x.PutClazzID(0xd91ffad6)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}
				if m.Ton == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsRevenueStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsRevenueStats, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsRevenueStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd91ffad6: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Ton = true
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsRevenueWithdrawalUrl <--
type TLPaymentsGetStarsRevenueWithdrawalUrl struct {
	ClazzID  uint32                     `json:"_id"`
	Ton      bool                       `json:"ton"`
	Peer     InputPeerClazz             `json:"peer"`
	Amount   *int64                     `json:"amount"`
	Password InputCheckPasswordSRPClazz `json:"password"`
}

func (m *TLPaymentsGetStarsRevenueWithdrawalUrl) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsRevenueWithdrawalUrl) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2433dc92: func() error {
			x.PutClazzID(0x2433dc92)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Ton == true {
					flags |= 1 << 0
				}

				if m.Amount != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.Amount != nil {
				x.PutInt64(*m.Amount)
			}

			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsRevenueWithdrawalUrl, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsRevenueWithdrawalUrl, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsRevenueWithdrawalUrl) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2433dc92: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Ton = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 1)) != 0 {
				m.Amount = new(int64)
				*m.Amount, err = d.Int64()
			}

			// m5 := &InputCheckPasswordSRP{}
			// _ = m5.Decode(d)
			// m.Password = m5
			m.Password, _ = DecodeInputCheckPasswordSRPClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsRevenueAdsAccountUrl <--
type TLPaymentsGetStarsRevenueAdsAccountUrl struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLPaymentsGetStarsRevenueAdsAccountUrl) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsRevenueAdsAccountUrl) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd1d7efc5: func() error {
			x.PutClazzID(0xd1d7efc5)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsRevenueAdsAccountUrl, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsRevenueAdsAccountUrl, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsRevenueAdsAccountUrl) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd1d7efc5: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsTransactionsByID <--
type TLPaymentsGetStarsTransactionsByID struct {
	ClazzID uint32                       `json:"_id"`
	Ton     bool                         `json:"ton"`
	Peer    InputPeerClazz               `json:"peer"`
	Id      []InputStarsTransactionClazz `json:"id"`
}

func (m *TLPaymentsGetStarsTransactionsByID) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsTransactionsByID) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2dca16b8: func() error {
			x.PutClazzID(0x2dca16b8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Ton == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsTransactionsByID, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsTransactionsByID, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsTransactionsByID) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2dca16b8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Ton = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			c4, err2 := d.ClazzID()
			if c4 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
				return err2
			}
			l4, err3 := d.Int()
			// v4 := make([]*InputStarsTransaction, l4)
			v4 := make([]InputStarsTransactionClazz, l4)
			for i := 0; i < l4; i++ {
				// vv := new(InputStarsTransaction)
				// err3 = vv.Decode(d)
				// _ = err3
				// v4[i] = vv
				v4[i], _ = DecodeInputStarsTransactionClazz(d)
				_ = err3
			}
			m.Id = v4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsGiftOptions <--
type TLPaymentsGetStarsGiftOptions struct {
	ClazzID uint32         `json:"_id"`
	UserId  InputUserClazz `json:"user_id"`
}

func (m *TLPaymentsGetStarsGiftOptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsGiftOptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd3c96bc8: func() error {
			x.PutClazzID(0xd3c96bc8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.UserId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.UserId != nil {
				_ = m.UserId.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsGiftOptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsGiftOptions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsGiftOptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd3c96bc8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				// m2 := &InputUser{}
				// _ = m2.Decode(d)
				// m.UserId = m2
				m.UserId, _ = DecodeInputUserClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsSubscriptions <--
type TLPaymentsGetStarsSubscriptions struct {
	ClazzID        uint32         `json:"_id"`
	MissingBalance bool           `json:"missing_balance"`
	Peer           InputPeerClazz `json:"peer"`
	Offset         string         `json:"offset"`
}

func (m *TLPaymentsGetStarsSubscriptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsSubscriptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x32512c5: func() error {
			x.PutClazzID(0x32512c5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MissingBalance == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Offset)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsSubscriptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsSubscriptions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsSubscriptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x32512c5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.MissingBalance = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Offset, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsChangeStarsSubscription <--
type TLPaymentsChangeStarsSubscription struct {
	ClazzID        uint32         `json:"_id"`
	Peer           InputPeerClazz `json:"peer"`
	SubscriptionId string         `json:"subscription_id"`
	Canceled       BoolClazz      `json:"canceled"`
}

func (m *TLPaymentsChangeStarsSubscription) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsChangeStarsSubscription) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc7770878: func() error {
			x.PutClazzID(0xc7770878)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Canceled != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.SubscriptionId)
			if m.Canceled != nil {
				_ = m.Canceled.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_changeStarsSubscription, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_changeStarsSubscription, layer)
	}
}

// Decode <--
func (m *TLPaymentsChangeStarsSubscription) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc7770878: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.SubscriptionId, err = d.String()
			if (flags & (1 << 0)) != 0 {
				// m4 := &Bool{}
				// _ = m4.Decode(d)
				// m.Canceled = m4
				m.Canceled, _ = DecodeBoolClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsFulfillStarsSubscription <--
type TLPaymentsFulfillStarsSubscription struct {
	ClazzID        uint32         `json:"_id"`
	Peer           InputPeerClazz `json:"peer"`
	SubscriptionId string         `json:"subscription_id"`
}

func (m *TLPaymentsFulfillStarsSubscription) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsFulfillStarsSubscription) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcc5bebb3: func() error {
			x.PutClazzID(0xcc5bebb3)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.SubscriptionId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_fulfillStarsSubscription, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_fulfillStarsSubscription, layer)
	}
}

// Decode <--
func (m *TLPaymentsFulfillStarsSubscription) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcc5bebb3: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.SubscriptionId, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsGiveawayOptions <--
type TLPaymentsGetStarsGiveawayOptions struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPaymentsGetStarsGiveawayOptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsGiveawayOptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbd1efd3e: func() error {
			x.PutClazzID(0xbd1efd3e)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsGiveawayOptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsGiveawayOptions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsGiveawayOptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbd1efd3e: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarGifts <--
type TLPaymentsGetStarGifts struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLPaymentsGetStarGifts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarGifts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc4563590: func() error {
			x.PutClazzID(0xc4563590)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarGifts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarGifts, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarGifts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc4563590: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsSaveStarGift <--
type TLPaymentsSaveStarGift struct {
	ClazzID  uint32                  `json:"_id"`
	Unsave   bool                    `json:"unsave"`
	Stargift InputSavedStarGiftClazz `json:"stargift"`
}

func (m *TLPaymentsSaveStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsSaveStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2a2a697c: func() error {
			x.PutClazzID(0x2a2a697c)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Unsave == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Stargift.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_saveStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_saveStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsSaveStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2a2a697c: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Unsave = true
			}

			// m3 := &InputSavedStarGift{}
			// _ = m3.Decode(d)
			// m.Stargift = m3
			m.Stargift, _ = DecodeInputSavedStarGiftClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsConvertStarGift <--
type TLPaymentsConvertStarGift struct {
	ClazzID  uint32                  `json:"_id"`
	Stargift InputSavedStarGiftClazz `json:"stargift"`
}

func (m *TLPaymentsConvertStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsConvertStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x74bf076b: func() error {
			x.PutClazzID(0x74bf076b)

			_ = m.Stargift.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_convertStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_convertStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsConvertStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x74bf076b: func() (err error) {

			// m1 := &InputSavedStarGift{}
			// _ = m1.Decode(d)
			// m.Stargift = m1
			m.Stargift, _ = DecodeInputSavedStarGiftClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsBotCancelStarsSubscription <--
type TLPaymentsBotCancelStarsSubscription struct {
	ClazzID  uint32         `json:"_id"`
	Restore  bool           `json:"restore"`
	UserId   InputUserClazz `json:"user_id"`
	ChargeId string         `json:"charge_id"`
}

func (m *TLPaymentsBotCancelStarsSubscription) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsBotCancelStarsSubscription) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6dfa0622: func() error {
			x.PutClazzID(0x6dfa0622)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Restore == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.UserId.Encode(x, layer)
			x.PutString(m.ChargeId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_botCancelStarsSubscription, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_botCancelStarsSubscription, layer)
	}
}

// Decode <--
func (m *TLPaymentsBotCancelStarsSubscription) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6dfa0622: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Restore = true
			}

			// m3 := &InputUser{}
			// _ = m3.Decode(d)
			// m.UserId = m3
			m.UserId, _ = DecodeInputUserClazz(d)

			m.ChargeId, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetConnectedStarRefBots <--
type TLPaymentsGetConnectedStarRefBots struct {
	ClazzID    uint32         `json:"_id"`
	Peer       InputPeerClazz `json:"peer"`
	OffsetDate *int32         `json:"offset_date"`
	OffsetLink *string        `json:"offset_link"`
	Limit      int32          `json:"limit"`
}

func (m *TLPaymentsGetConnectedStarRefBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetConnectedStarRefBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5869a553: func() error {
			x.PutClazzID(0x5869a553)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.OffsetDate != nil {
					flags |= 1 << 2
				}
				if m.OffsetLink != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.OffsetDate != nil {
				x.PutInt32(*m.OffsetDate)
			}

			if m.OffsetLink != nil {
				x.PutString(*m.OffsetLink)
			}

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getConnectedStarRefBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getConnectedStarRefBots, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetConnectedStarRefBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5869a553: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 2)) != 0 {
				m.OffsetDate = new(int32)
				*m.OffsetDate, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				m.OffsetLink = new(string)
				*m.OffsetLink, err = d.String()
			}

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetConnectedStarRefBot <--
type TLPaymentsGetConnectedStarRefBot struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Bot     InputUserClazz `json:"bot"`
}

func (m *TLPaymentsGetConnectedStarRefBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetConnectedStarRefBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb7d998f0: func() error {
			x.PutClazzID(0xb7d998f0)

			_ = m.Peer.Encode(x, layer)
			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getConnectedStarRefBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getConnectedStarRefBot, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetConnectedStarRefBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb7d998f0: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.Bot = m2
			m.Bot, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetSuggestedStarRefBots <--
type TLPaymentsGetSuggestedStarRefBots struct {
	ClazzID        uint32         `json:"_id"`
	OrderByRevenue bool           `json:"order_by_revenue"`
	OrderByDate    bool           `json:"order_by_date"`
	Peer           InputPeerClazz `json:"peer"`
	Offset         string         `json:"offset"`
	Limit          int32          `json:"limit"`
}

func (m *TLPaymentsGetSuggestedStarRefBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetSuggestedStarRefBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd6b48f7: func() error {
			x.PutClazzID(0xd6b48f7)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.OrderByRevenue == true {
					flags |= 1 << 0
				}
				if m.OrderByDate == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getSuggestedStarRefBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getSuggestedStarRefBots, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetSuggestedStarRefBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd6b48f7: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.OrderByRevenue = true
			}
			if (flags & (1 << 1)) != 0 {
				m.OrderByDate = true
			}

			// m4 := &InputPeer{}
			// _ = m4.Decode(d)
			// m.Peer = m4
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsConnectStarRefBot <--
type TLPaymentsConnectStarRefBot struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Bot     InputUserClazz `json:"bot"`
}

func (m *TLPaymentsConnectStarRefBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsConnectStarRefBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7ed5348a: func() error {
			x.PutClazzID(0x7ed5348a)

			_ = m.Peer.Encode(x, layer)
			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_connectStarRefBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_connectStarRefBot, layer)
	}
}

// Decode <--
func (m *TLPaymentsConnectStarRefBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7ed5348a: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.Bot = m2
			m.Bot, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsEditConnectedStarRefBot <--
type TLPaymentsEditConnectedStarRefBot struct {
	ClazzID uint32         `json:"_id"`
	Revoked bool           `json:"revoked"`
	Peer    InputPeerClazz `json:"peer"`
	Link    string         `json:"link"`
}

func (m *TLPaymentsEditConnectedStarRefBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsEditConnectedStarRefBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe4fca4a3: func() error {
			x.PutClazzID(0xe4fca4a3)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Revoked == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Link)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_editConnectedStarRefBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_editConnectedStarRefBot, layer)
	}
}

// Decode <--
func (m *TLPaymentsEditConnectedStarRefBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe4fca4a3: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Revoked = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Link, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarGiftUpgradePreview <--
type TLPaymentsGetStarGiftUpgradePreview struct {
	ClazzID uint32 `json:"_id"`
	GiftId  int64  `json:"gift_id"`
}

func (m *TLPaymentsGetStarGiftUpgradePreview) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarGiftUpgradePreview) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9c9abcb1: func() error {
			x.PutClazzID(0x9c9abcb1)

			x.PutInt64(m.GiftId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarGiftUpgradePreview, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarGiftUpgradePreview, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarGiftUpgradePreview) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9c9abcb1: func() (err error) {
			m.GiftId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsUpgradeStarGift <--
type TLPaymentsUpgradeStarGift struct {
	ClazzID             uint32                  `json:"_id"`
	KeepOriginalDetails bool                    `json:"keep_original_details"`
	Stargift            InputSavedStarGiftClazz `json:"stargift"`
}

func (m *TLPaymentsUpgradeStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsUpgradeStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaed6e4f5: func() error {
			x.PutClazzID(0xaed6e4f5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.KeepOriginalDetails == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Stargift.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_upgradeStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_upgradeStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsUpgradeStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaed6e4f5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.KeepOriginalDetails = true
			}

			// m3 := &InputSavedStarGift{}
			// _ = m3.Decode(d)
			// m.Stargift = m3
			m.Stargift, _ = DecodeInputSavedStarGiftClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsTransferStarGift <--
type TLPaymentsTransferStarGift struct {
	ClazzID  uint32                  `json:"_id"`
	Stargift InputSavedStarGiftClazz `json:"stargift"`
	ToId     InputPeerClazz          `json:"to_id"`
}

func (m *TLPaymentsTransferStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsTransferStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7f18176a: func() error {
			x.PutClazzID(0x7f18176a)

			_ = m.Stargift.Encode(x, layer)
			_ = m.ToId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_transferStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_transferStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsTransferStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7f18176a: func() (err error) {

			// m1 := &InputSavedStarGift{}
			// _ = m1.Decode(d)
			// m.Stargift = m1
			m.Stargift, _ = DecodeInputSavedStarGiftClazz(d)

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.ToId = m2
			m.ToId, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetUniqueStarGift <--
type TLPaymentsGetUniqueStarGift struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLPaymentsGetUniqueStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetUniqueStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa1974d72: func() error {
			x.PutClazzID(0xa1974d72)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getUniqueStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getUniqueStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetUniqueStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa1974d72: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetSavedStarGifts <--
type TLPaymentsGetSavedStarGifts struct {
	ClazzID             uint32         `json:"_id"`
	ExcludeUnsaved      bool           `json:"exclude_unsaved"`
	ExcludeSaved        bool           `json:"exclude_saved"`
	ExcludeUnlimited    bool           `json:"exclude_unlimited"`
	ExcludeUnique       bool           `json:"exclude_unique"`
	SortByValue         bool           `json:"sort_by_value"`
	ExcludeUpgradable   bool           `json:"exclude_upgradable"`
	ExcludeUnupgradable bool           `json:"exclude_unupgradable"`
	PeerColorAvailable  bool           `json:"peer_color_available"`
	ExcludeHosted       bool           `json:"exclude_hosted"`
	Peer                InputPeerClazz `json:"peer"`
	CollectionId        *int32         `json:"collection_id"`
	Offset              string         `json:"offset"`
	Limit               int32          `json:"limit"`
}

func (m *TLPaymentsGetSavedStarGifts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetSavedStarGifts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa319e569: func() error {
			x.PutClazzID(0xa319e569)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ExcludeUnsaved == true {
					flags |= 1 << 0
				}
				if m.ExcludeSaved == true {
					flags |= 1 << 1
				}
				if m.ExcludeUnlimited == true {
					flags |= 1 << 2
				}
				if m.ExcludeUnique == true {
					flags |= 1 << 4
				}
				if m.SortByValue == true {
					flags |= 1 << 5
				}
				if m.ExcludeUpgradable == true {
					flags |= 1 << 7
				}
				if m.ExcludeUnupgradable == true {
					flags |= 1 << 8
				}
				if m.PeerColorAvailable == true {
					flags |= 1 << 9
				}
				if m.ExcludeHosted == true {
					flags |= 1 << 10
				}

				if m.CollectionId != nil {
					flags |= 1 << 6
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.CollectionId != nil {
				x.PutInt32(*m.CollectionId)
			}

			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getSavedStarGifts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getSavedStarGifts, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetSavedStarGifts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa319e569: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ExcludeUnsaved = true
			}
			if (flags & (1 << 1)) != 0 {
				m.ExcludeSaved = true
			}
			if (flags & (1 << 2)) != 0 {
				m.ExcludeUnlimited = true
			}
			if (flags & (1 << 4)) != 0 {
				m.ExcludeUnique = true
			}
			if (flags & (1 << 5)) != 0 {
				m.SortByValue = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ExcludeUpgradable = true
			}
			if (flags & (1 << 8)) != 0 {
				m.ExcludeUnupgradable = true
			}
			if (flags & (1 << 9)) != 0 {
				m.PeerColorAvailable = true
			}
			if (flags & (1 << 10)) != 0 {
				m.ExcludeHosted = true
			}

			// m11 := &InputPeer{}
			// _ = m11.Decode(d)
			// m.Peer = m11
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 6)) != 0 {
				m.CollectionId = new(int32)
				*m.CollectionId, err = d.Int32()
			}
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetSavedStarGift <--
type TLPaymentsGetSavedStarGift struct {
	ClazzID  uint32                    `json:"_id"`
	Stargift []InputSavedStarGiftClazz `json:"stargift"`
}

func (m *TLPaymentsGetSavedStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetSavedStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb455a106: func() error {
			x.PutClazzID(0xb455a106)

			_ = iface.EncodeObjectList(x, m.Stargift, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getSavedStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getSavedStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetSavedStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb455a106: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputSavedStarGift, l1)
			v1 := make([]InputSavedStarGiftClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputSavedStarGift)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputSavedStarGiftClazz(d)
				_ = err3
			}
			m.Stargift = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarGiftWithdrawalUrl <--
type TLPaymentsGetStarGiftWithdrawalUrl struct {
	ClazzID  uint32                     `json:"_id"`
	Stargift InputSavedStarGiftClazz    `json:"stargift"`
	Password InputCheckPasswordSRPClazz `json:"password"`
}

func (m *TLPaymentsGetStarGiftWithdrawalUrl) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarGiftWithdrawalUrl) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd06e93a8: func() error {
			x.PutClazzID(0xd06e93a8)

			_ = m.Stargift.Encode(x, layer)
			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarGiftWithdrawalUrl, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarGiftWithdrawalUrl, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarGiftWithdrawalUrl) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd06e93a8: func() (err error) {

			// m1 := &InputSavedStarGift{}
			// _ = m1.Decode(d)
			// m.Stargift = m1
			m.Stargift, _ = DecodeInputSavedStarGiftClazz(d)

			// m2 := &InputCheckPasswordSRP{}
			// _ = m2.Decode(d)
			// m.Password = m2
			m.Password, _ = DecodeInputCheckPasswordSRPClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsToggleChatStarGiftNotifications <--
type TLPaymentsToggleChatStarGiftNotifications struct {
	ClazzID uint32         `json:"_id"`
	Enabled bool           `json:"enabled"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLPaymentsToggleChatStarGiftNotifications) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsToggleChatStarGiftNotifications) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x60eaefa1: func() error {
			x.PutClazzID(0x60eaefa1)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Enabled == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_toggleChatStarGiftNotifications, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_toggleChatStarGiftNotifications, layer)
	}
}

// Decode <--
func (m *TLPaymentsToggleChatStarGiftNotifications) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x60eaefa1: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Enabled = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsToggleStarGiftsPinnedToTop <--
type TLPaymentsToggleStarGiftsPinnedToTop struct {
	ClazzID  uint32                    `json:"_id"`
	Peer     InputPeerClazz            `json:"peer"`
	Stargift []InputSavedStarGiftClazz `json:"stargift"`
}

func (m *TLPaymentsToggleStarGiftsPinnedToTop) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsToggleStarGiftsPinnedToTop) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1513e7b0: func() error {
			x.PutClazzID(0x1513e7b0)

			_ = m.Peer.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Stargift, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_toggleStarGiftsPinnedToTop, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_toggleStarGiftsPinnedToTop, layer)
	}
}

// Decode <--
func (m *TLPaymentsToggleStarGiftsPinnedToTop) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1513e7b0: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputSavedStarGift, l2)
			v2 := make([]InputSavedStarGiftClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputSavedStarGift)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputSavedStarGiftClazz(d)
				_ = err3
			}
			m.Stargift = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsCanPurchaseStore <--
type TLPaymentsCanPurchaseStore struct {
	ClazzID uint32                        `json:"_id"`
	Purpose InputStorePaymentPurposeClazz `json:"purpose"`
}

func (m *TLPaymentsCanPurchaseStore) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsCanPurchaseStore) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4fdc5ea7: func() error {
			x.PutClazzID(0x4fdc5ea7)

			_ = m.Purpose.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_canPurchaseStore, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_canPurchaseStore, layer)
	}
}

// Decode <--
func (m *TLPaymentsCanPurchaseStore) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4fdc5ea7: func() (err error) {

			// m1 := &InputStorePaymentPurpose{}
			// _ = m1.Decode(d)
			// m.Purpose = m1
			m.Purpose, _ = DecodeInputStorePaymentPurposeClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetResaleStarGifts <--
type TLPaymentsGetResaleStarGifts struct {
	ClazzID        uint32                     `json:"_id"`
	SortByPrice    bool                       `json:"sort_by_price"`
	SortByNum      bool                       `json:"sort_by_num"`
	AttributesHash *int64                     `json:"attributes_hash"`
	GiftId         int64                      `json:"gift_id"`
	Attributes     []StarGiftAttributeIdClazz `json:"attributes"`
	Offset         string                     `json:"offset"`
	Limit          int32                      `json:"limit"`
}

func (m *TLPaymentsGetResaleStarGifts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetResaleStarGifts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7a5fa236: func() error {
			x.PutClazzID(0x7a5fa236)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SortByPrice == true {
					flags |= 1 << 1
				}
				if m.SortByNum == true {
					flags |= 1 << 2
				}
				if m.AttributesHash != nil {
					flags |= 1 << 0
				}

				if m.Attributes != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.AttributesHash != nil {
				x.PutInt64(*m.AttributesHash)
			}

			x.PutInt64(m.GiftId)
			if m.Attributes != nil {
				_ = iface.EncodeObjectList(x, m.Attributes, layer)
			}
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getResaleStarGifts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getResaleStarGifts, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetResaleStarGifts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7a5fa236: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.SortByPrice = true
			}
			if (flags & (1 << 2)) != 0 {
				m.SortByNum = true
			}
			if (flags & (1 << 0)) != 0 {
				m.AttributesHash = new(int64)
				*m.AttributesHash, err = d.Int64()
			}

			m.GiftId, err = d.Int64()
			if (flags & (1 << 3)) != 0 {
				c6, err2 := d.ClazzID()
				if c6 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 6, c6)
					return err2
				}
				l6, err3 := d.Int()
				// v6 := make([]*StarGiftAttributeId, l6)
				v6 := make([]StarGiftAttributeIdClazz, l6)
				for i := 0; i < l6; i++ {
					// vv := new(StarGiftAttributeId)
					// err3 = vv.Decode(d)
					// _ = err3
					// v6[i] = vv
					v6[i], _ = DecodeStarGiftAttributeIdClazz(d)
					_ = err3
				}
				m.Attributes = v6
			}
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsUpdateStarGiftPrice <--
type TLPaymentsUpdateStarGiftPrice struct {
	ClazzID      uint32                  `json:"_id"`
	Stargift     InputSavedStarGiftClazz `json:"stargift"`
	ResellAmount StarsAmountClazz        `json:"resell_amount"`
}

func (m *TLPaymentsUpdateStarGiftPrice) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsUpdateStarGiftPrice) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xedbe6ccb: func() error {
			x.PutClazzID(0xedbe6ccb)

			_ = m.Stargift.Encode(x, layer)
			_ = m.ResellAmount.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_updateStarGiftPrice, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_updateStarGiftPrice, layer)
	}
}

// Decode <--
func (m *TLPaymentsUpdateStarGiftPrice) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xedbe6ccb: func() (err error) {

			// m1 := &InputSavedStarGift{}
			// _ = m1.Decode(d)
			// m.Stargift = m1
			m.Stargift, _ = DecodeInputSavedStarGiftClazz(d)

			// m2 := &StarsAmount{}
			// _ = m2.Decode(d)
			// m.ResellAmount = m2
			m.ResellAmount, _ = DecodeStarsAmountClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsCreateStarGiftCollection <--
type TLPaymentsCreateStarGiftCollection struct {
	ClazzID  uint32                    `json:"_id"`
	Peer     InputPeerClazz            `json:"peer"`
	Title    string                    `json:"title"`
	Stargift []InputSavedStarGiftClazz `json:"stargift"`
}

func (m *TLPaymentsCreateStarGiftCollection) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsCreateStarGiftCollection) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1f4a0e87: func() error {
			x.PutClazzID(0x1f4a0e87)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Title)

			_ = iface.EncodeObjectList(x, m.Stargift, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_createStarGiftCollection, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_createStarGiftCollection, layer)
	}
}

// Decode <--
func (m *TLPaymentsCreateStarGiftCollection) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1f4a0e87: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Title, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			// v3 := make([]*InputSavedStarGift, l3)
			v3 := make([]InputSavedStarGiftClazz, l3)
			for i := 0; i < l3; i++ {
				// vv := new(InputSavedStarGift)
				// err3 = vv.Decode(d)
				// _ = err3
				// v3[i] = vv
				v3[i], _ = DecodeInputSavedStarGiftClazz(d)
				_ = err3
			}
			m.Stargift = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsUpdateStarGiftCollection <--
type TLPaymentsUpdateStarGiftCollection struct {
	ClazzID        uint32                    `json:"_id"`
	Peer           InputPeerClazz            `json:"peer"`
	CollectionId   int32                     `json:"collection_id"`
	Title          *string                   `json:"title"`
	DeleteStargift []InputSavedStarGiftClazz `json:"delete_stargift"`
	AddStargift    []InputSavedStarGiftClazz `json:"add_stargift"`
	Order          []InputSavedStarGiftClazz `json:"order"`
}

func (m *TLPaymentsUpdateStarGiftCollection) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsUpdateStarGiftCollection) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4fddbee7: func() error {
			x.PutClazzID(0x4fddbee7)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Title != nil {
					flags |= 1 << 0
				}
				if m.DeleteStargift != nil {
					flags |= 1 << 1
				}
				if m.AddStargift != nil {
					flags |= 1 << 2
				}
				if m.Order != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.CollectionId)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.DeleteStargift != nil {
				_ = iface.EncodeObjectList(x, m.DeleteStargift, layer)
			}
			if m.AddStargift != nil {
				_ = iface.EncodeObjectList(x, m.AddStargift, layer)
			}
			if m.Order != nil {
				_ = iface.EncodeObjectList(x, m.Order, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_updateStarGiftCollection, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_updateStarGiftCollection, layer)
	}
}

// Decode <--
func (m *TLPaymentsUpdateStarGiftCollection) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4fddbee7: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.CollectionId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				c5, err2 := d.ClazzID()
				if c5 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
					return err2
				}
				l5, err3 := d.Int()
				// v5 := make([]*InputSavedStarGift, l5)
				v5 := make([]InputSavedStarGiftClazz, l5)
				for i := 0; i < l5; i++ {
					// vv := new(InputSavedStarGift)
					// err3 = vv.Decode(d)
					// _ = err3
					// v5[i] = vv
					v5[i], _ = DecodeInputSavedStarGiftClazz(d)
					_ = err3
				}
				m.DeleteStargift = v5
			}
			if (flags & (1 << 2)) != 0 {
				c6, err2 := d.ClazzID()
				if c6 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 6, c6)
					return err2
				}
				l6, err3 := d.Int()
				// v6 := make([]*InputSavedStarGift, l6)
				v6 := make([]InputSavedStarGiftClazz, l6)
				for i := 0; i < l6; i++ {
					// vv := new(InputSavedStarGift)
					// err3 = vv.Decode(d)
					// _ = err3
					// v6[i] = vv
					v6[i], _ = DecodeInputSavedStarGiftClazz(d)
					_ = err3
				}
				m.AddStargift = v6
			}
			if (flags & (1 << 3)) != 0 {
				c7, err2 := d.ClazzID()
				if c7 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 7, c7)
					return err2
				}
				l7, err3 := d.Int()
				// v7 := make([]*InputSavedStarGift, l7)
				v7 := make([]InputSavedStarGiftClazz, l7)
				for i := 0; i < l7; i++ {
					// vv := new(InputSavedStarGift)
					// err3 = vv.Decode(d)
					// _ = err3
					// v7[i] = vv
					v7[i], _ = DecodeInputSavedStarGiftClazz(d)
					_ = err3
				}
				m.Order = v7
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsReorderStarGiftCollections <--
type TLPaymentsReorderStarGiftCollections struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Order   []int32        `json:"order"`
}

func (m *TLPaymentsReorderStarGiftCollections) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsReorderStarGiftCollections) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc32af4cc: func() error {
			x.PutClazzID(0xc32af4cc)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_reorderStarGiftCollections, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_reorderStarGiftCollections, layer)
	}
}

// Decode <--
func (m *TLPaymentsReorderStarGiftCollections) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc32af4cc: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Order, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsDeleteStarGiftCollection <--
type TLPaymentsDeleteStarGiftCollection struct {
	ClazzID      uint32         `json:"_id"`
	Peer         InputPeerClazz `json:"peer"`
	CollectionId int32          `json:"collection_id"`
}

func (m *TLPaymentsDeleteStarGiftCollection) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsDeleteStarGiftCollection) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xad5648e8: func() error {
			x.PutClazzID(0xad5648e8)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.CollectionId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_deleteStarGiftCollection, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_deleteStarGiftCollection, layer)
	}
}

// Decode <--
func (m *TLPaymentsDeleteStarGiftCollection) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xad5648e8: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.CollectionId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarGiftCollections <--
type TLPaymentsGetStarGiftCollections struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Hash    int64          `json:"hash"`
}

func (m *TLPaymentsGetStarGiftCollections) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarGiftCollections) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x981b91dd: func() error {
			x.PutClazzID(0x981b91dd)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarGiftCollections, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarGiftCollections, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarGiftCollections) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x981b91dd: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetUniqueStarGiftValueInfo <--
type TLPaymentsGetUniqueStarGiftValueInfo struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLPaymentsGetUniqueStarGiftValueInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetUniqueStarGiftValueInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4365af6b: func() error {
			x.PutClazzID(0x4365af6b)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getUniqueStarGiftValueInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getUniqueStarGiftValueInfo, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetUniqueStarGiftValueInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4365af6b: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsCheckCanSendGift <--
type TLPaymentsCheckCanSendGift struct {
	ClazzID uint32 `json:"_id"`
	GiftId  int64  `json:"gift_id"`
}

func (m *TLPaymentsCheckCanSendGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsCheckCanSendGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc0c4edc9: func() error {
			x.PutClazzID(0xc0c4edc9)

			x.PutInt64(m.GiftId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_checkCanSendGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_checkCanSendGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsCheckCanSendGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc0c4edc9: func() (err error) {
			m.GiftId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersCreateStickerSet <--
type TLStickersCreateStickerSet struct {
	ClazzID   uint32                     `json:"_id"`
	Masks     bool                       `json:"masks"`
	Emojis    bool                       `json:"emojis"`
	TextColor bool                       `json:"text_color"`
	UserId    InputUserClazz             `json:"user_id"`
	Title     string                     `json:"title"`
	ShortName string                     `json:"short_name"`
	Thumb     InputDocumentClazz         `json:"thumb"`
	Stickers  []InputStickerSetItemClazz `json:"stickers"`
	Software  *string                    `json:"software"`
}

func (m *TLStickersCreateStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersCreateStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9021ab67: func() error {
			x.PutClazzID(0x9021ab67)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Masks == true {
					flags |= 1 << 0
				}
				if m.Emojis == true {
					flags |= 1 << 5
				}
				if m.TextColor == true {
					flags |= 1 << 6
				}

				if m.Thumb != nil {
					flags |= 1 << 2
				}

				if m.Software != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.UserId.Encode(x, layer)
			x.PutString(m.Title)
			x.PutString(m.ShortName)
			if m.Thumb != nil {
				_ = m.Thumb.Encode(x, layer)
			}

			_ = iface.EncodeObjectList(x, m.Stickers, layer)

			if m.Software != nil {
				x.PutString(*m.Software)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_createStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_createStickerSet, layer)
	}
}

// Decode <--
func (m *TLStickersCreateStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9021ab67: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Masks = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Emojis = true
			}
			if (flags & (1 << 6)) != 0 {
				m.TextColor = true
			}

			// m5 := &InputUser{}
			// _ = m5.Decode(d)
			// m.UserId = m5
			m.UserId, _ = DecodeInputUserClazz(d)

			m.Title, err = d.String()
			m.ShortName, err = d.String()
			if (flags & (1 << 2)) != 0 {
				// m8 := &InputDocument{}
				// _ = m8.Decode(d)
				// m.Thumb = m8
				m.Thumb, _ = DecodeInputDocumentClazz(d)
			}
			c9, err2 := d.ClazzID()
			if c9 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 9, c9)
				return err2
			}
			l9, err3 := d.Int()
			// v9 := make([]*InputStickerSetItem, l9)
			v9 := make([]InputStickerSetItemClazz, l9)
			for i := 0; i < l9; i++ {
				// vv := new(InputStickerSetItem)
				// err3 = vv.Decode(d)
				// _ = err3
				// v9[i] = vv
				v9[i], _ = DecodeInputStickerSetItemClazz(d)
				_ = err3
			}
			m.Stickers = v9

			if (flags & (1 << 3)) != 0 {
				m.Software = new(string)
				*m.Software, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersRemoveStickerFromSet <--
type TLStickersRemoveStickerFromSet struct {
	ClazzID uint32             `json:"_id"`
	Sticker InputDocumentClazz `json:"sticker"`
}

func (m *TLStickersRemoveStickerFromSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersRemoveStickerFromSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf7760f51: func() error {
			x.PutClazzID(0xf7760f51)

			_ = m.Sticker.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_removeStickerFromSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_removeStickerFromSet, layer)
	}
}

// Decode <--
func (m *TLStickersRemoveStickerFromSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf7760f51: func() (err error) {

			// m1 := &InputDocument{}
			// _ = m1.Decode(d)
			// m.Sticker = m1
			m.Sticker, _ = DecodeInputDocumentClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersChangeStickerPosition <--
type TLStickersChangeStickerPosition struct {
	ClazzID  uint32             `json:"_id"`
	Sticker  InputDocumentClazz `json:"sticker"`
	Position int32              `json:"position"`
}

func (m *TLStickersChangeStickerPosition) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersChangeStickerPosition) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xffb6d4ca: func() error {
			x.PutClazzID(0xffb6d4ca)

			_ = m.Sticker.Encode(x, layer)
			x.PutInt32(m.Position)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_changeStickerPosition, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_changeStickerPosition, layer)
	}
}

// Decode <--
func (m *TLStickersChangeStickerPosition) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xffb6d4ca: func() (err error) {

			// m1 := &InputDocument{}
			// _ = m1.Decode(d)
			// m.Sticker = m1
			m.Sticker, _ = DecodeInputDocumentClazz(d)

			m.Position, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersAddStickerToSet <--
type TLStickersAddStickerToSet struct {
	ClazzID    uint32                   `json:"_id"`
	Stickerset InputStickerSetClazz     `json:"stickerset"`
	Sticker    InputStickerSetItemClazz `json:"sticker"`
}

func (m *TLStickersAddStickerToSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersAddStickerToSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8653febe: func() error {
			x.PutClazzID(0x8653febe)

			_ = m.Stickerset.Encode(x, layer)
			_ = m.Sticker.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_addStickerToSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_addStickerToSet, layer)
	}
}

// Decode <--
func (m *TLStickersAddStickerToSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8653febe: func() (err error) {

			// m1 := &InputStickerSet{}
			// _ = m1.Decode(d)
			// m.Stickerset = m1
			m.Stickerset, _ = DecodeInputStickerSetClazz(d)

			// m2 := &InputStickerSetItem{}
			// _ = m2.Decode(d)
			// m.Sticker = m2
			m.Sticker, _ = DecodeInputStickerSetItemClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersSetStickerSetThumb <--
type TLStickersSetStickerSetThumb struct {
	ClazzID         uint32               `json:"_id"`
	Stickerset      InputStickerSetClazz `json:"stickerset"`
	Thumb           InputDocumentClazz   `json:"thumb"`
	ThumbDocumentId *int64               `json:"thumb_document_id"`
}

func (m *TLStickersSetStickerSetThumb) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersSetStickerSetThumb) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa76a5392: func() error {
			x.PutClazzID(0xa76a5392)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Thumb != nil {
					flags |= 1 << 0
				}
				if m.ThumbDocumentId != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Stickerset.Encode(x, layer)
			if m.Thumb != nil {
				_ = m.Thumb.Encode(x, layer)
			}

			if m.ThumbDocumentId != nil {
				x.PutInt64(*m.ThumbDocumentId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_setStickerSetThumb, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_setStickerSetThumb, layer)
	}
}

// Decode <--
func (m *TLStickersSetStickerSetThumb) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa76a5392: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputStickerSet{}
			// _ = m2.Decode(d)
			// m.Stickerset = m2
			m.Stickerset, _ = DecodeInputStickerSetClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m3 := &InputDocument{}
				// _ = m3.Decode(d)
				// m.Thumb = m3
				m.Thumb, _ = DecodeInputDocumentClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				m.ThumbDocumentId = new(int64)
				*m.ThumbDocumentId, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersCheckShortName <--
type TLStickersCheckShortName struct {
	ClazzID   uint32 `json:"_id"`
	ShortName string `json:"short_name"`
}

func (m *TLStickersCheckShortName) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersCheckShortName) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x284b3639: func() error {
			x.PutClazzID(0x284b3639)

			x.PutString(m.ShortName)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_checkShortName, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_checkShortName, layer)
	}
}

// Decode <--
func (m *TLStickersCheckShortName) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x284b3639: func() (err error) {
			m.ShortName, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersSuggestShortName <--
type TLStickersSuggestShortName struct {
	ClazzID uint32 `json:"_id"`
	Title   string `json:"title"`
}

func (m *TLStickersSuggestShortName) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersSuggestShortName) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4dafc503: func() error {
			x.PutClazzID(0x4dafc503)

			x.PutString(m.Title)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_suggestShortName, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_suggestShortName, layer)
	}
}

// Decode <--
func (m *TLStickersSuggestShortName) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4dafc503: func() (err error) {
			m.Title, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersChangeSticker <--
type TLStickersChangeSticker struct {
	ClazzID    uint32             `json:"_id"`
	Sticker    InputDocumentClazz `json:"sticker"`
	Emoji      *string            `json:"emoji"`
	MaskCoords MaskCoordsClazz    `json:"mask_coords"`
	Keywords   *string            `json:"keywords"`
}

func (m *TLStickersChangeSticker) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersChangeSticker) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf5537ebc: func() error {
			x.PutClazzID(0xf5537ebc)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Emoji != nil {
					flags |= 1 << 0
				}
				if m.MaskCoords != nil {
					flags |= 1 << 1
				}
				if m.Keywords != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Sticker.Encode(x, layer)
			if m.Emoji != nil {
				x.PutString(*m.Emoji)
			}

			if m.MaskCoords != nil {
				_ = m.MaskCoords.Encode(x, layer)
			}

			if m.Keywords != nil {
				x.PutString(*m.Keywords)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_changeSticker, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_changeSticker, layer)
	}
}

// Decode <--
func (m *TLStickersChangeSticker) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf5537ebc: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputDocument{}
			// _ = m2.Decode(d)
			// m.Sticker = m2
			m.Sticker, _ = DecodeInputDocumentClazz(d)

			if (flags & (1 << 0)) != 0 {
				m.Emoji = new(string)
				*m.Emoji, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				// m4 := &MaskCoords{}
				// _ = m4.Decode(d)
				// m.MaskCoords = m4
				m.MaskCoords, _ = DecodeMaskCoordsClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				m.Keywords = new(string)
				*m.Keywords, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersRenameStickerSet <--
type TLStickersRenameStickerSet struct {
	ClazzID    uint32               `json:"_id"`
	Stickerset InputStickerSetClazz `json:"stickerset"`
	Title      string               `json:"title"`
}

func (m *TLStickersRenameStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersRenameStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x124b1c00: func() error {
			x.PutClazzID(0x124b1c00)

			_ = m.Stickerset.Encode(x, layer)
			x.PutString(m.Title)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_renameStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_renameStickerSet, layer)
	}
}

// Decode <--
func (m *TLStickersRenameStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x124b1c00: func() (err error) {

			// m1 := &InputStickerSet{}
			// _ = m1.Decode(d)
			// m.Stickerset = m1
			m.Stickerset, _ = DecodeInputStickerSetClazz(d)

			m.Title, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersDeleteStickerSet <--
type TLStickersDeleteStickerSet struct {
	ClazzID    uint32               `json:"_id"`
	Stickerset InputStickerSetClazz `json:"stickerset"`
}

func (m *TLStickersDeleteStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersDeleteStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x87704394: func() error {
			x.PutClazzID(0x87704394)

			_ = m.Stickerset.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_deleteStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_deleteStickerSet, layer)
	}
}

// Decode <--
func (m *TLStickersDeleteStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x87704394: func() (err error) {

			// m1 := &InputStickerSet{}
			// _ = m1.Decode(d)
			// m.Stickerset = m1
			m.Stickerset, _ = DecodeInputStickerSetClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersReplaceSticker <--
type TLStickersReplaceSticker struct {
	ClazzID    uint32                   `json:"_id"`
	Sticker    InputDocumentClazz       `json:"sticker"`
	NewSticker InputStickerSetItemClazz `json:"new_sticker"`
}

func (m *TLStickersReplaceSticker) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersReplaceSticker) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4696459a: func() error {
			x.PutClazzID(0x4696459a)

			_ = m.Sticker.Encode(x, layer)
			_ = m.NewSticker.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_replaceSticker, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_replaceSticker, layer)
	}
}

// Decode <--
func (m *TLStickersReplaceSticker) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4696459a: func() (err error) {

			// m1 := &InputDocument{}
			// _ = m1.Decode(d)
			// m.Sticker = m1
			m.Sticker, _ = DecodeInputDocumentClazz(d)

			// m2 := &InputStickerSetItem{}
			// _ = m2.Decode(d)
			// m.NewSticker = m2
			m.NewSticker, _ = DecodeInputStickerSetItemClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetCallConfig <--
type TLPhoneGetCallConfig struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPhoneGetCallConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetCallConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x55451fa9: func() error {
			x.PutClazzID(0x55451fa9)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getCallConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getCallConfig, layer)
	}
}

// Decode <--
func (m *TLPhoneGetCallConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x55451fa9: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneRequestCall <--
type TLPhoneRequestCall struct {
	ClazzID  uint32                 `json:"_id"`
	Video    bool                   `json:"video"`
	UserId   InputUserClazz         `json:"user_id"`
	RandomId int32                  `json:"random_id"`
	GAHash   []byte                 `json:"g_a_hash"`
	Protocol PhoneCallProtocolClazz `json:"protocol"`
}

func (m *TLPhoneRequestCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneRequestCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x42ff96ed: func() error {
			x.PutClazzID(0x42ff96ed)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Video == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.RandomId)
			x.PutBytes(m.GAHash)
			_ = m.Protocol.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_requestCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_requestCall, layer)
	}
}

// Decode <--
func (m *TLPhoneRequestCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x42ff96ed: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Video = true
			}

			// m3 := &InputUser{}
			// _ = m3.Decode(d)
			// m.UserId = m3
			m.UserId, _ = DecodeInputUserClazz(d)

			m.RandomId, err = d.Int32()
			m.GAHash, err = d.Bytes()

			// m6 := &PhoneCallProtocol{}
			// _ = m6.Decode(d)
			// m.Protocol = m6
			m.Protocol, _ = DecodePhoneCallProtocolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneAcceptCall <--
type TLPhoneAcceptCall struct {
	ClazzID  uint32                 `json:"_id"`
	Peer     InputPhoneCallClazz    `json:"peer"`
	GB       []byte                 `json:"g_b"`
	Protocol PhoneCallProtocolClazz `json:"protocol"`
}

func (m *TLPhoneAcceptCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneAcceptCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3bd2b4a0: func() error {
			x.PutClazzID(0x3bd2b4a0)

			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.GB)
			_ = m.Protocol.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_acceptCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_acceptCall, layer)
	}
}

// Decode <--
func (m *TLPhoneAcceptCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3bd2b4a0: func() (err error) {

			// m1 := &InputPhoneCall{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPhoneCallClazz(d)

			m.GB, err = d.Bytes()

			// m3 := &PhoneCallProtocol{}
			// _ = m3.Decode(d)
			// m.Protocol = m3
			m.Protocol, _ = DecodePhoneCallProtocolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneConfirmCall <--
type TLPhoneConfirmCall struct {
	ClazzID        uint32                 `json:"_id"`
	Peer           InputPhoneCallClazz    `json:"peer"`
	GA             []byte                 `json:"g_a"`
	KeyFingerprint int64                  `json:"key_fingerprint"`
	Protocol       PhoneCallProtocolClazz `json:"protocol"`
}

func (m *TLPhoneConfirmCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneConfirmCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2efe1722: func() error {
			x.PutClazzID(0x2efe1722)

			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.GA)
			x.PutInt64(m.KeyFingerprint)
			_ = m.Protocol.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_confirmCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_confirmCall, layer)
	}
}

// Decode <--
func (m *TLPhoneConfirmCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2efe1722: func() (err error) {

			// m1 := &InputPhoneCall{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPhoneCallClazz(d)

			m.GA, err = d.Bytes()
			m.KeyFingerprint, err = d.Int64()

			// m4 := &PhoneCallProtocol{}
			// _ = m4.Decode(d)
			// m.Protocol = m4
			m.Protocol, _ = DecodePhoneCallProtocolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneReceivedCall <--
type TLPhoneReceivedCall struct {
	ClazzID uint32              `json:"_id"`
	Peer    InputPhoneCallClazz `json:"peer"`
}

func (m *TLPhoneReceivedCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneReceivedCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x17d54f61: func() error {
			x.PutClazzID(0x17d54f61)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_receivedCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_receivedCall, layer)
	}
}

// Decode <--
func (m *TLPhoneReceivedCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x17d54f61: func() (err error) {

			// m1 := &InputPhoneCall{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPhoneCallClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneDiscardCall <--
type TLPhoneDiscardCall struct {
	ClazzID      uint32                      `json:"_id"`
	Video        bool                        `json:"video"`
	Peer         InputPhoneCallClazz         `json:"peer"`
	Duration     int32                       `json:"duration"`
	Reason       PhoneCallDiscardReasonClazz `json:"reason"`
	ConnectionId int64                       `json:"connection_id"`
}

func (m *TLPhoneDiscardCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneDiscardCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb2cbc1c0: func() error {
			x.PutClazzID(0xb2cbc1c0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Video == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Duration)
			_ = m.Reason.Encode(x, layer)
			x.PutInt64(m.ConnectionId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_discardCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_discardCall, layer)
	}
}

// Decode <--
func (m *TLPhoneDiscardCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb2cbc1c0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Video = true
			}

			// m3 := &InputPhoneCall{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPhoneCallClazz(d)

			m.Duration, err = d.Int32()

			// m5 := &PhoneCallDiscardReason{}
			// _ = m5.Decode(d)
			// m.Reason = m5
			m.Reason, _ = DecodePhoneCallDiscardReasonClazz(d)

			m.ConnectionId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSetCallRating <--
type TLPhoneSetCallRating struct {
	ClazzID        uint32              `json:"_id"`
	UserInitiative bool                `json:"user_initiative"`
	Peer           InputPhoneCallClazz `json:"peer"`
	Rating         int32               `json:"rating"`
	Comment        string              `json:"comment"`
}

func (m *TLPhoneSetCallRating) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSetCallRating) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x59ead627: func() error {
			x.PutClazzID(0x59ead627)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.UserInitiative == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Rating)
			x.PutString(m.Comment)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_setCallRating, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_setCallRating, layer)
	}
}

// Decode <--
func (m *TLPhoneSetCallRating) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x59ead627: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.UserInitiative = true
			}

			// m3 := &InputPhoneCall{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPhoneCallClazz(d)

			m.Rating, err = d.Int32()
			m.Comment, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSaveCallDebug <--
type TLPhoneSaveCallDebug struct {
	ClazzID uint32              `json:"_id"`
	Peer    InputPhoneCallClazz `json:"peer"`
	Debug   DataJSONClazz       `json:"debug"`
}

func (m *TLPhoneSaveCallDebug) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSaveCallDebug) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x277add7e: func() error {
			x.PutClazzID(0x277add7e)

			_ = m.Peer.Encode(x, layer)
			_ = m.Debug.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_saveCallDebug, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_saveCallDebug, layer)
	}
}

// Decode <--
func (m *TLPhoneSaveCallDebug) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x277add7e: func() (err error) {

			// m1 := &InputPhoneCall{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPhoneCallClazz(d)

			// m2 := &DataJSON{}
			// _ = m2.Decode(d)
			// m.Debug = m2
			m.Debug, _ = DecodeDataJSONClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSendSignalingData <--
type TLPhoneSendSignalingData struct {
	ClazzID uint32              `json:"_id"`
	Peer    InputPhoneCallClazz `json:"peer"`
	Data    []byte              `json:"data"`
}

func (m *TLPhoneSendSignalingData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSendSignalingData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xff7a9383: func() error {
			x.PutClazzID(0xff7a9383)

			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.Data)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_sendSignalingData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_sendSignalingData, layer)
	}
}

// Decode <--
func (m *TLPhoneSendSignalingData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xff7a9383: func() (err error) {

			// m1 := &InputPhoneCall{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPhoneCallClazz(d)

			m.Data, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneCreateGroupCall <--
type TLPhoneCreateGroupCall struct {
	ClazzID      uint32         `json:"_id"`
	RtmpStream   bool           `json:"rtmp_stream"`
	Peer         InputPeerClazz `json:"peer"`
	RandomId     int32          `json:"random_id"`
	Title        *string        `json:"title"`
	ScheduleDate *int32         `json:"schedule_date"`
}

func (m *TLPhoneCreateGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneCreateGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x48cdc6d8: func() error {
			x.PutClazzID(0x48cdc6d8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.RtmpStream == true {
					flags |= 1 << 2
				}

				if m.Title != nil {
					flags |= 1 << 0
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.RandomId)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_createGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_createGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneCreateGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x48cdc6d8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m.RtmpStream = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.RandomId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneJoinGroupCall <--
type TLPhoneJoinGroupCall struct {
	ClazzID      uint32              `json:"_id"`
	Muted        bool                `json:"muted"`
	VideoStopped bool                `json:"video_stopped"`
	Call         InputGroupCallClazz `json:"call"`
	JoinAs       InputPeerClazz      `json:"join_as"`
	InviteHash   *string             `json:"invite_hash"`
	PublicKey    bin.Int256          `json:"public_key"`
	Block        []byte              `json:"block"`
	Params       DataJSONClazz       `json:"params"`
}

func (m *TLPhoneJoinGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneJoinGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8fb53057: func() error {
			x.PutClazzID(0x8fb53057)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Muted == true {
					flags |= 1 << 0
				}
				if m.VideoStopped == true {
					flags |= 1 << 2
				}

				if m.InviteHash != nil {
					flags |= 1 << 1
				}
				if m.PublicKey != nil {
					flags |= 1 << 3
				}
				if m.Block != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)
			_ = m.JoinAs.Encode(x, layer)
			if m.InviteHash != nil {
				x.PutString(*m.InviteHash)
			}

			x.PutInt256(m.PublicKey)
			if m.Block != nil {
				x.PutBytes(m.Block)
			}

			_ = m.Params.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_joinGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_joinGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneJoinGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8fb53057: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Muted = true
			}
			if (flags & (1 << 2)) != 0 {
				m.VideoStopped = true
			}

			// m4 := &InputGroupCall{}
			// _ = m4.Decode(d)
			// m.Call = m4
			m.Call, _ = DecodeInputGroupCallClazz(d)

			// m5 := &InputPeer{}
			// _ = m5.Decode(d)
			// m.JoinAs = m5
			m.JoinAs, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 1)) != 0 {
				m.InviteHash = new(string)
				*m.InviteHash, err = d.String()
			}

			err = m.PublicKey.Decode(d)
			if (flags & (1 << 3)) != 0 {
				m.Block, err = d.Bytes()
			}

			// m9 := &DataJSON{}
			// _ = m9.Decode(d)
			// m.Params = m9
			m.Params, _ = DecodeDataJSONClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneLeaveGroupCall <--
type TLPhoneLeaveGroupCall struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
	Source  int32               `json:"source"`
}

func (m *TLPhoneLeaveGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneLeaveGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x500377f9: func() error {
			x.PutClazzID(0x500377f9)

			_ = m.Call.Encode(x, layer)
			x.PutInt32(m.Source)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_leaveGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_leaveGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneLeaveGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x500377f9: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			m.Source, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneInviteToGroupCall <--
type TLPhoneInviteToGroupCall struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
	Users   []InputUserClazz    `json:"users"`
}

func (m *TLPhoneInviteToGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneInviteToGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7b393160: func() error {
			x.PutClazzID(0x7b393160)

			_ = m.Call.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Users, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_inviteToGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_inviteToGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneInviteToGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7b393160: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputUser, l2)
			v2 := make([]InputUserClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputUser)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputUserClazz(d)
				_ = err3
			}
			m.Users = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneDiscardGroupCall <--
type TLPhoneDiscardGroupCall struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
}

func (m *TLPhoneDiscardGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneDiscardGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7a777135: func() error {
			x.PutClazzID(0x7a777135)

			_ = m.Call.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_discardGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_discardGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneDiscardGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7a777135: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneToggleGroupCallSettings <--
type TLPhoneToggleGroupCallSettings struct {
	ClazzID         uint32              `json:"_id"`
	ResetInviteHash bool                `json:"reset_invite_hash"`
	Call            InputGroupCallClazz `json:"call"`
	JoinMuted       BoolClazz           `json:"join_muted"`
	MessagesEnabled BoolClazz           `json:"messages_enabled"`
}

func (m *TLPhoneToggleGroupCallSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneToggleGroupCallSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe9723804: func() error {
			x.PutClazzID(0xe9723804)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ResetInviteHash == true {
					flags |= 1 << 1
				}

				if m.JoinMuted != nil {
					flags |= 1 << 0
				}
				if m.MessagesEnabled != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)
			if m.JoinMuted != nil {
				_ = m.JoinMuted.Encode(x, layer)
			}

			if m.MessagesEnabled != nil {
				_ = m.MessagesEnabled.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_toggleGroupCallSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_toggleGroupCallSettings, layer)
	}
}

// Decode <--
func (m *TLPhoneToggleGroupCallSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe9723804: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.ResetInviteHash = true
			}

			// m3 := &InputGroupCall{}
			// _ = m3.Decode(d)
			// m.Call = m3
			m.Call, _ = DecodeInputGroupCallClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m4 := &Bool{}
				// _ = m4.Decode(d)
				// m.JoinMuted = m4
				m.JoinMuted, _ = DecodeBoolClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				// m5 := &Bool{}
				// _ = m5.Decode(d)
				// m.MessagesEnabled = m5
				m.MessagesEnabled, _ = DecodeBoolClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupCall <--
type TLPhoneGetGroupCall struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
	Limit   int32               `json:"limit"`
}

func (m *TLPhoneGetGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x41845db: func() error {
			x.PutClazzID(0x41845db)

			_ = m.Call.Encode(x, layer)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x41845db: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupParticipants <--
type TLPhoneGetGroupParticipants struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
	Ids     []InputPeerClazz    `json:"ids"`
	Sources []int32             `json:"sources"`
	Offset  string              `json:"offset"`
	Limit   int32               `json:"limit"`
}

func (m *TLPhoneGetGroupParticipants) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupParticipants) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc558d8ab: func() error {
			x.PutClazzID(0xc558d8ab)

			_ = m.Call.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Ids, layer)

			iface.EncodeInt32List(x, m.Sources)

			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupParticipants, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupParticipants, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupParticipants) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc558d8ab: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputPeer, l2)
			v2 := make([]InputPeerClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputPeerClazz(d)
				_ = err3
			}
			m.Ids = v2

			m.Sources, err = iface.DecodeInt32List(d)

			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneCheckGroupCall <--
type TLPhoneCheckGroupCall struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
	Sources []int32             `json:"sources"`
}

func (m *TLPhoneCheckGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneCheckGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb59cf977: func() error {
			x.PutClazzID(0xb59cf977)

			_ = m.Call.Encode(x, layer)

			iface.EncodeInt32List(x, m.Sources)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_checkGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_checkGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneCheckGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb59cf977: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			m.Sources, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneToggleGroupCallRecord <--
type TLPhoneToggleGroupCallRecord struct {
	ClazzID       uint32              `json:"_id"`
	Start         bool                `json:"start"`
	Video         bool                `json:"video"`
	Call          InputGroupCallClazz `json:"call"`
	Title         *string             `json:"title"`
	VideoPortrait BoolClazz           `json:"video_portrait"`
}

func (m *TLPhoneToggleGroupCallRecord) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneToggleGroupCallRecord) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf128c708: func() error {
			x.PutClazzID(0xf128c708)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Start == true {
					flags |= 1 << 0
				}
				if m.Video == true {
					flags |= 1 << 2
				}

				if m.Title != nil {
					flags |= 1 << 1
				}
				if m.VideoPortrait != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.VideoPortrait != nil {
				_ = m.VideoPortrait.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_toggleGroupCallRecord, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_toggleGroupCallRecord, layer)
	}
}

// Decode <--
func (m *TLPhoneToggleGroupCallRecord) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf128c708: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Start = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Video = true
			}

			// m4 := &InputGroupCall{}
			// _ = m4.Decode(d)
			// m.Call = m4
			m.Call, _ = DecodeInputGroupCallClazz(d)

			if (flags & (1 << 1)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				// m6 := &Bool{}
				// _ = m6.Decode(d)
				// m.VideoPortrait = m6
				m.VideoPortrait, _ = DecodeBoolClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneEditGroupCallParticipant <--
type TLPhoneEditGroupCallParticipant struct {
	ClazzID            uint32              `json:"_id"`
	Call               InputGroupCallClazz `json:"call"`
	Participant        InputPeerClazz      `json:"participant"`
	Muted              BoolClazz           `json:"muted"`
	Volume             *int32              `json:"volume"`
	RaiseHand          BoolClazz           `json:"raise_hand"`
	VideoStopped       BoolClazz           `json:"video_stopped"`
	VideoPaused        BoolClazz           `json:"video_paused"`
	PresentationPaused BoolClazz           `json:"presentation_paused"`
}

func (m *TLPhoneEditGroupCallParticipant) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneEditGroupCallParticipant) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa5273abf: func() error {
			x.PutClazzID(0xa5273abf)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Muted != nil {
					flags |= 1 << 0
				}
				if m.Volume != nil {
					flags |= 1 << 1
				}
				if m.RaiseHand != nil {
					flags |= 1 << 2
				}
				if m.VideoStopped != nil {
					flags |= 1 << 3
				}
				if m.VideoPaused != nil {
					flags |= 1 << 4
				}
				if m.PresentationPaused != nil {
					flags |= 1 << 5
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)
			_ = m.Participant.Encode(x, layer)
			if m.Muted != nil {
				_ = m.Muted.Encode(x, layer)
			}

			if m.Volume != nil {
				x.PutInt32(*m.Volume)
			}

			if m.RaiseHand != nil {
				_ = m.RaiseHand.Encode(x, layer)
			}

			if m.VideoStopped != nil {
				_ = m.VideoStopped.Encode(x, layer)
			}

			if m.VideoPaused != nil {
				_ = m.VideoPaused.Encode(x, layer)
			}

			if m.PresentationPaused != nil {
				_ = m.PresentationPaused.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_editGroupCallParticipant, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_editGroupCallParticipant, layer)
	}
}

// Decode <--
func (m *TLPhoneEditGroupCallParticipant) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa5273abf: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputGroupCall{}
			// _ = m2.Decode(d)
			// m.Call = m2
			m.Call, _ = DecodeInputGroupCallClazz(d)

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Participant = m3
			m.Participant, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 0)) != 0 {
				// m4 := &Bool{}
				// _ = m4.Decode(d)
				// m.Muted = m4
				m.Muted, _ = DecodeBoolClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				m.Volume = new(int32)
				*m.Volume, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				// m6 := &Bool{}
				// _ = m6.Decode(d)
				// m.RaiseHand = m6
				m.RaiseHand, _ = DecodeBoolClazz(d)
			}
			if (flags & (1 << 3)) != 0 {
				// m7 := &Bool{}
				// _ = m7.Decode(d)
				// m.VideoStopped = m7
				m.VideoStopped, _ = DecodeBoolClazz(d)
			}
			if (flags & (1 << 4)) != 0 {
				// m8 := &Bool{}
				// _ = m8.Decode(d)
				// m.VideoPaused = m8
				m.VideoPaused, _ = DecodeBoolClazz(d)
			}
			if (flags & (1 << 5)) != 0 {
				// m9 := &Bool{}
				// _ = m9.Decode(d)
				// m.PresentationPaused = m9
				m.PresentationPaused, _ = DecodeBoolClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneEditGroupCallTitle <--
type TLPhoneEditGroupCallTitle struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
	Title   string              `json:"title"`
}

func (m *TLPhoneEditGroupCallTitle) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneEditGroupCallTitle) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1ca6ac0a: func() error {
			x.PutClazzID(0x1ca6ac0a)

			_ = m.Call.Encode(x, layer)
			x.PutString(m.Title)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_editGroupCallTitle, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_editGroupCallTitle, layer)
	}
}

// Decode <--
func (m *TLPhoneEditGroupCallTitle) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1ca6ac0a: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			m.Title, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupCallJoinAs <--
type TLPhoneGetGroupCallJoinAs struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLPhoneGetGroupCallJoinAs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupCallJoinAs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xef7c213a: func() error {
			x.PutClazzID(0xef7c213a)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupCallJoinAs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupCallJoinAs, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupCallJoinAs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xef7c213a: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneExportGroupCallInvite <--
type TLPhoneExportGroupCallInvite struct {
	ClazzID       uint32              `json:"_id"`
	CanSelfUnmute bool                `json:"can_self_unmute"`
	Call          InputGroupCallClazz `json:"call"`
}

func (m *TLPhoneExportGroupCallInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneExportGroupCallInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe6aa647f: func() error {
			x.PutClazzID(0xe6aa647f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.CanSelfUnmute == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_exportGroupCallInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_exportGroupCallInvite, layer)
	}
}

// Decode <--
func (m *TLPhoneExportGroupCallInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe6aa647f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.CanSelfUnmute = true
			}

			// m3 := &InputGroupCall{}
			// _ = m3.Decode(d)
			// m.Call = m3
			m.Call, _ = DecodeInputGroupCallClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneToggleGroupCallStartSubscription <--
type TLPhoneToggleGroupCallStartSubscription struct {
	ClazzID    uint32              `json:"_id"`
	Call       InputGroupCallClazz `json:"call"`
	Subscribed BoolClazz           `json:"subscribed"`
}

func (m *TLPhoneToggleGroupCallStartSubscription) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneToggleGroupCallStartSubscription) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x219c34e6: func() error {
			x.PutClazzID(0x219c34e6)

			_ = m.Call.Encode(x, layer)
			_ = m.Subscribed.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_toggleGroupCallStartSubscription, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_toggleGroupCallStartSubscription, layer)
	}
}

// Decode <--
func (m *TLPhoneToggleGroupCallStartSubscription) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x219c34e6: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Subscribed = m2
			m.Subscribed, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneStartScheduledGroupCall <--
type TLPhoneStartScheduledGroupCall struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
}

func (m *TLPhoneStartScheduledGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneStartScheduledGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5680e342: func() error {
			x.PutClazzID(0x5680e342)

			_ = m.Call.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_startScheduledGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_startScheduledGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneStartScheduledGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5680e342: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSaveDefaultGroupCallJoinAs <--
type TLPhoneSaveDefaultGroupCallJoinAs struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	JoinAs  InputPeerClazz `json:"join_as"`
}

func (m *TLPhoneSaveDefaultGroupCallJoinAs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSaveDefaultGroupCallJoinAs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x575e1f8c: func() error {
			x.PutClazzID(0x575e1f8c)

			_ = m.Peer.Encode(x, layer)
			_ = m.JoinAs.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_saveDefaultGroupCallJoinAs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_saveDefaultGroupCallJoinAs, layer)
	}
}

// Decode <--
func (m *TLPhoneSaveDefaultGroupCallJoinAs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x575e1f8c: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.JoinAs = m2
			m.JoinAs, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneJoinGroupCallPresentation <--
type TLPhoneJoinGroupCallPresentation struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
	Params  DataJSONClazz       `json:"params"`
}

func (m *TLPhoneJoinGroupCallPresentation) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneJoinGroupCallPresentation) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcbea6bc4: func() error {
			x.PutClazzID(0xcbea6bc4)

			_ = m.Call.Encode(x, layer)
			_ = m.Params.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_joinGroupCallPresentation, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_joinGroupCallPresentation, layer)
	}
}

// Decode <--
func (m *TLPhoneJoinGroupCallPresentation) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcbea6bc4: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			// m2 := &DataJSON{}
			// _ = m2.Decode(d)
			// m.Params = m2
			m.Params, _ = DecodeDataJSONClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneLeaveGroupCallPresentation <--
type TLPhoneLeaveGroupCallPresentation struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
}

func (m *TLPhoneLeaveGroupCallPresentation) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneLeaveGroupCallPresentation) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1c50d144: func() error {
			x.PutClazzID(0x1c50d144)

			_ = m.Call.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_leaveGroupCallPresentation, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_leaveGroupCallPresentation, layer)
	}
}

// Decode <--
func (m *TLPhoneLeaveGroupCallPresentation) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1c50d144: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupCallStreamChannels <--
type TLPhoneGetGroupCallStreamChannels struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
}

func (m *TLPhoneGetGroupCallStreamChannels) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupCallStreamChannels) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1ab21940: func() error {
			x.PutClazzID(0x1ab21940)

			_ = m.Call.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupCallStreamChannels, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupCallStreamChannels, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupCallStreamChannels) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1ab21940: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupCallStreamRtmpUrl <--
type TLPhoneGetGroupCallStreamRtmpUrl struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Revoke  BoolClazz      `json:"revoke"`
}

func (m *TLPhoneGetGroupCallStreamRtmpUrl) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupCallStreamRtmpUrl) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdeb3abbf: func() error {
			x.PutClazzID(0xdeb3abbf)

			_ = m.Peer.Encode(x, layer)
			_ = m.Revoke.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupCallStreamRtmpUrl, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupCallStreamRtmpUrl, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupCallStreamRtmpUrl) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdeb3abbf: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Revoke = m2
			m.Revoke, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSaveCallLog <--
type TLPhoneSaveCallLog struct {
	ClazzID uint32              `json:"_id"`
	Peer    InputPhoneCallClazz `json:"peer"`
	File    InputFileClazz      `json:"file"`
}

func (m *TLPhoneSaveCallLog) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSaveCallLog) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x41248786: func() error {
			x.PutClazzID(0x41248786)

			_ = m.Peer.Encode(x, layer)
			_ = m.File.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_saveCallLog, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_saveCallLog, layer)
	}
}

// Decode <--
func (m *TLPhoneSaveCallLog) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x41248786: func() (err error) {

			// m1 := &InputPhoneCall{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPhoneCallClazz(d)

			// m2 := &InputFile{}
			// _ = m2.Decode(d)
			// m.File = m2
			m.File, _ = DecodeInputFileClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneCreateConferenceCall <--
type TLPhoneCreateConferenceCall struct {
	ClazzID      uint32        `json:"_id"`
	Muted        bool          `json:"muted"`
	VideoStopped bool          `json:"video_stopped"`
	Join         bool          `json:"join"`
	RandomId     int32         `json:"random_id"`
	PublicKey    bin.Int256    `json:"public_key"`
	Block        []byte        `json:"block"`
	Params       DataJSONClazz `json:"params"`
}

func (m *TLPhoneCreateConferenceCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneCreateConferenceCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7d0444bb: func() error {
			x.PutClazzID(0x7d0444bb)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Muted == true {
					flags |= 1 << 0
				}
				if m.VideoStopped == true {
					flags |= 1 << 2
				}
				if m.Join == true {
					flags |= 1 << 3
				}

				if m.PublicKey != nil {
					flags |= 1 << 3
				}
				if m.Block != nil {
					flags |= 1 << 3
				}
				if m.Params != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.RandomId)
			x.PutInt256(m.PublicKey)
			if m.Block != nil {
				x.PutBytes(m.Block)
			}

			if m.Params != nil {
				_ = m.Params.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_createConferenceCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_createConferenceCall, layer)
	}
}

// Decode <--
func (m *TLPhoneCreateConferenceCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7d0444bb: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Muted = true
			}
			if (flags & (1 << 2)) != 0 {
				m.VideoStopped = true
			}
			if (flags & (1 << 3)) != 0 {
				m.Join = true
			}
			m.RandomId, err = d.Int32()
			err = m.PublicKey.Decode(d)
			if (flags & (1 << 3)) != 0 {
				m.Block, err = d.Bytes()
			}

			if (flags & (1 << 3)) != 0 {
				// m8 := &DataJSON{}
				// _ = m8.Decode(d)
				// m.Params = m8
				m.Params, _ = DecodeDataJSONClazz(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneDeleteConferenceCallParticipants <--
type TLPhoneDeleteConferenceCallParticipants struct {
	ClazzID  uint32              `json:"_id"`
	OnlyLeft bool                `json:"only_left"`
	Kick     bool                `json:"kick"`
	Call     InputGroupCallClazz `json:"call"`
	Ids      []int64             `json:"ids"`
	Block    []byte              `json:"block"`
}

func (m *TLPhoneDeleteConferenceCallParticipants) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneDeleteConferenceCallParticipants) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8ca60525: func() error {
			x.PutClazzID(0x8ca60525)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.OnlyLeft == true {
					flags |= 1 << 0
				}
				if m.Kick == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)

			iface.EncodeInt64List(x, m.Ids)

			x.PutBytes(m.Block)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_deleteConferenceCallParticipants, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_deleteConferenceCallParticipants, layer)
	}
}

// Decode <--
func (m *TLPhoneDeleteConferenceCallParticipants) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8ca60525: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.OnlyLeft = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Kick = true
			}

			// m4 := &InputGroupCall{}
			// _ = m4.Decode(d)
			// m.Call = m4
			m.Call, _ = DecodeInputGroupCallClazz(d)

			m.Ids, err = iface.DecodeInt64List(d)

			m.Block, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSendConferenceCallBroadcast <--
type TLPhoneSendConferenceCallBroadcast struct {
	ClazzID uint32              `json:"_id"`
	Call    InputGroupCallClazz `json:"call"`
	Block   []byte              `json:"block"`
}

func (m *TLPhoneSendConferenceCallBroadcast) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSendConferenceCallBroadcast) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc6701900: func() error {
			x.PutClazzID(0xc6701900)

			_ = m.Call.Encode(x, layer)
			x.PutBytes(m.Block)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_sendConferenceCallBroadcast, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_sendConferenceCallBroadcast, layer)
	}
}

// Decode <--
func (m *TLPhoneSendConferenceCallBroadcast) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc6701900: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			m.Block, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneInviteConferenceCallParticipant <--
type TLPhoneInviteConferenceCallParticipant struct {
	ClazzID uint32              `json:"_id"`
	Video   bool                `json:"video"`
	Call    InputGroupCallClazz `json:"call"`
	UserId  InputUserClazz      `json:"user_id"`
}

func (m *TLPhoneInviteConferenceCallParticipant) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneInviteConferenceCallParticipant) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbcf22685: func() error {
			x.PutClazzID(0xbcf22685)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Video == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_inviteConferenceCallParticipant, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_inviteConferenceCallParticipant, layer)
	}
}

// Decode <--
func (m *TLPhoneInviteConferenceCallParticipant) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbcf22685: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Video = true
			}

			// m3 := &InputGroupCall{}
			// _ = m3.Decode(d)
			// m.Call = m3
			m.Call, _ = DecodeInputGroupCallClazz(d)

			// m4 := &InputUser{}
			// _ = m4.Decode(d)
			// m.UserId = m4
			m.UserId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneDeclineConferenceCallInvite <--
type TLPhoneDeclineConferenceCallInvite struct {
	ClazzID uint32 `json:"_id"`
	MsgId   int32  `json:"msg_id"`
}

func (m *TLPhoneDeclineConferenceCallInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneDeclineConferenceCallInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3c479971: func() error {
			x.PutClazzID(0x3c479971)

			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_declineConferenceCallInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_declineConferenceCallInvite, layer)
	}
}

// Decode <--
func (m *TLPhoneDeclineConferenceCallInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3c479971: func() (err error) {
			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupCallChainBlocks <--
type TLPhoneGetGroupCallChainBlocks struct {
	ClazzID    uint32              `json:"_id"`
	Call       InputGroupCallClazz `json:"call"`
	SubChainId int32               `json:"sub_chain_id"`
	Offset     int32               `json:"offset"`
	Limit      int32               `json:"limit"`
}

func (m *TLPhoneGetGroupCallChainBlocks) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupCallChainBlocks) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xee9f88a6: func() error {
			x.PutClazzID(0xee9f88a6)

			_ = m.Call.Encode(x, layer)
			x.PutInt32(m.SubChainId)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupCallChainBlocks, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupCallChainBlocks, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupCallChainBlocks) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xee9f88a6: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			m.SubChainId, err = d.Int32()
			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSendGroupCallMessage <--
type TLPhoneSendGroupCallMessage struct {
	ClazzID  uint32                `json:"_id"`
	Call     InputGroupCallClazz   `json:"call"`
	RandomId int64                 `json:"random_id"`
	Message  TextWithEntitiesClazz `json:"message"`
}

func (m *TLPhoneSendGroupCallMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSendGroupCallMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x87893014: func() error {
			x.PutClazzID(0x87893014)

			_ = m.Call.Encode(x, layer)
			x.PutInt64(m.RandomId)
			_ = m.Message.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_sendGroupCallMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_sendGroupCallMessage, layer)
	}
}

// Decode <--
func (m *TLPhoneSendGroupCallMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x87893014: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			m.RandomId, err = d.Int64()

			// m3 := &TextWithEntities{}
			// _ = m3.Decode(d)
			// m.Message = m3
			m.Message, _ = DecodeTextWithEntitiesClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSendGroupCallEncryptedMessage <--
type TLPhoneSendGroupCallEncryptedMessage struct {
	ClazzID          uint32              `json:"_id"`
	Call             InputGroupCallClazz `json:"call"`
	EncryptedMessage []byte              `json:"encrypted_message"`
}

func (m *TLPhoneSendGroupCallEncryptedMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSendGroupCallEncryptedMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe5afa56d: func() error {
			x.PutClazzID(0xe5afa56d)

			_ = m.Call.Encode(x, layer)
			x.PutBytes(m.EncryptedMessage)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_sendGroupCallEncryptedMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_sendGroupCallEncryptedMessage, layer)
	}
}

// Decode <--
func (m *TLPhoneSendGroupCallEncryptedMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe5afa56d: func() (err error) {

			// m1 := &InputGroupCall{}
			// _ = m1.Decode(d)
			// m.Call = m1
			m.Call, _ = DecodeInputGroupCallClazz(d)

			m.EncryptedMessage, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLLangpackGetLangPack <--
type TLLangpackGetLangPack struct {
	ClazzID  uint32 `json:"_id"`
	LangPack string `json:"lang_pack"`
	LangCode string `json:"lang_code"`
}

func (m *TLLangpackGetLangPack) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLLangpackGetLangPack) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf2f2330a: func() error {
			x.PutClazzID(0xf2f2330a)

			x.PutString(m.LangPack)
			x.PutString(m.LangCode)

			return nil
		},
		0x9ab5c58e: func() error {
			x.PutClazzID(0x9ab5c58e)

			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_langpack_getLangPack, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_langpack_getLangPack, layer)
	}
}

// Decode <--
func (m *TLLangpackGetLangPack) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf2f2330a: func() (err error) {
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()

			return nil
		},
		0x9ab5c58e: func() (err error) {
			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLLangpackGetStrings <--
type TLLangpackGetStrings struct {
	ClazzID  uint32   `json:"_id"`
	LangPack string   `json:"lang_pack"`
	LangCode string   `json:"lang_code"`
	Keys     []string `json:"keys"`
}

func (m *TLLangpackGetStrings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLLangpackGetStrings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xefea3803: func() error {
			x.PutClazzID(0xefea3803)

			x.PutString(m.LangPack)
			x.PutString(m.LangCode)

			iface.EncodeStringList(x, m.Keys)

			return nil
		},
		0x2e1ee318: func() error {
			x.PutClazzID(0x2e1ee318)

			x.PutString(m.LangCode)

			iface.EncodeStringList(x, m.Keys)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_langpack_getStrings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_langpack_getStrings, layer)
	}
}

// Decode <--
func (m *TLLangpackGetStrings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xefea3803: func() (err error) {
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()

			m.Keys, err = iface.DecodeStringList(d)

			return nil
		},
		0x2e1ee318: func() (err error) {
			m.LangCode, err = d.String()

			m.Keys, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLLangpackGetDifference <--
type TLLangpackGetDifference struct {
	ClazzID     uint32 `json:"_id"`
	LangPack    string `json:"lang_pack"`
	LangCode    string `json:"lang_code"`
	FromVersion int32  `json:"from_version"`
}

func (m *TLLangpackGetDifference) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLLangpackGetDifference) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcd984aa5: func() error {
			x.PutClazzID(0xcd984aa5)

			x.PutString(m.LangPack)
			x.PutString(m.LangCode)
			x.PutInt32(m.FromVersion)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_langpack_getDifference, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_langpack_getDifference, layer)
	}
}

// Decode <--
func (m *TLLangpackGetDifference) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcd984aa5: func() (err error) {
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()
			m.FromVersion, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLLangpackGetLanguages <--
type TLLangpackGetLanguages struct {
	ClazzID  uint32 `json:"_id"`
	LangPack string `json:"lang_pack"`
}

func (m *TLLangpackGetLanguages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLLangpackGetLanguages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x42c6978f: func() error {
			x.PutClazzID(0x42c6978f)

			x.PutString(m.LangPack)

			return nil
		},
		0x800fd57d: func() error {
			x.PutClazzID(0x800fd57d)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_langpack_getLanguages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_langpack_getLanguages, layer)
	}
}

// Decode <--
func (m *TLLangpackGetLanguages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x42c6978f: func() (err error) {
			m.LangPack, err = d.String()

			return nil
		},
		0x800fd57d: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLLangpackGetLanguage <--
type TLLangpackGetLanguage struct {
	ClazzID  uint32 `json:"_id"`
	LangPack string `json:"lang_pack"`
	LangCode string `json:"lang_code"`
}

func (m *TLLangpackGetLanguage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLLangpackGetLanguage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6a596502: func() error {
			x.PutClazzID(0x6a596502)

			x.PutString(m.LangPack)
			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_langpack_getLanguage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_langpack_getLanguage, layer)
	}
}

// Decode <--
func (m *TLLangpackGetLanguage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6a596502: func() (err error) {
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLFoldersEditPeerFolders <--
type TLFoldersEditPeerFolders struct {
	ClazzID     uint32                 `json:"_id"`
	FolderPeers []InputFolderPeerClazz `json:"folder_peers"`
}

func (m *TLFoldersEditPeerFolders) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLFoldersEditPeerFolders) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6847d0ab: func() error {
			x.PutClazzID(0x6847d0ab)

			_ = iface.EncodeObjectList(x, m.FolderPeers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_folders_editPeerFolders, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_folders_editPeerFolders, layer)
	}
}

// Decode <--
func (m *TLFoldersEditPeerFolders) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6847d0ab: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputFolderPeer, l1)
			v1 := make([]InputFolderPeerClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputFolderPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputFolderPeerClazz(d)
				_ = err3
			}
			m.FolderPeers = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetBroadcastStats <--
type TLStatsGetBroadcastStats struct {
	ClazzID uint32            `json:"_id"`
	Dark    bool              `json:"dark"`
	Channel InputChannelClazz `json:"channel"`
}

func (m *TLStatsGetBroadcastStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetBroadcastStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xab42441a: func() error {
			x.PutClazzID(0xab42441a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getBroadcastStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getBroadcastStats, layer)
	}
}

// Decode <--
func (m *TLStatsGetBroadcastStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xab42441a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}

			// m3 := &InputChannel{}
			// _ = m3.Decode(d)
			// m.Channel = m3
			m.Channel, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsLoadAsyncGraph <--
type TLStatsLoadAsyncGraph struct {
	ClazzID uint32 `json:"_id"`
	Token   string `json:"token"`
	X       *int64 `json:"x"`
}

func (m *TLStatsLoadAsyncGraph) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsLoadAsyncGraph) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x621d5fa0: func() error {
			x.PutClazzID(0x621d5fa0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.X != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Token)
			if m.X != nil {
				x.PutInt64(*m.X)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_loadAsyncGraph, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_loadAsyncGraph, layer)
	}
}

// Decode <--
func (m *TLStatsLoadAsyncGraph) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x621d5fa0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Token, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.X = new(int64)
				*m.X, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetMegagroupStats <--
type TLStatsGetMegagroupStats struct {
	ClazzID uint32            `json:"_id"`
	Dark    bool              `json:"dark"`
	Channel InputChannelClazz `json:"channel"`
}

func (m *TLStatsGetMegagroupStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetMegagroupStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdcdf8607: func() error {
			x.PutClazzID(0xdcdf8607)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getMegagroupStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getMegagroupStats, layer)
	}
}

// Decode <--
func (m *TLStatsGetMegagroupStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdcdf8607: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}

			// m3 := &InputChannel{}
			// _ = m3.Decode(d)
			// m.Channel = m3
			m.Channel, _ = DecodeInputChannelClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetMessagePublicForwards <--
type TLStatsGetMessagePublicForwards struct {
	ClazzID uint32            `json:"_id"`
	Channel InputChannelClazz `json:"channel"`
	MsgId   int32             `json:"msg_id"`
	Offset  string            `json:"offset"`
	Limit   int32             `json:"limit"`
}

func (m *TLStatsGetMessagePublicForwards) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetMessagePublicForwards) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5f150144: func() error {
			x.PutClazzID(0x5f150144)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getMessagePublicForwards, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getMessagePublicForwards, layer)
	}
}

// Decode <--
func (m *TLStatsGetMessagePublicForwards) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5f150144: func() (err error) {

			// m1 := &InputChannel{}
			// _ = m1.Decode(d)
			// m.Channel = m1
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.MsgId, err = d.Int32()
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetMessageStats <--
type TLStatsGetMessageStats struct {
	ClazzID uint32            `json:"_id"`
	Dark    bool              `json:"dark"`
	Channel InputChannelClazz `json:"channel"`
	MsgId   int32             `json:"msg_id"`
}

func (m *TLStatsGetMessageStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetMessageStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb6e0a3f5: func() error {
			x.PutClazzID(0xb6e0a3f5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getMessageStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getMessageStats, layer)
	}
}

// Decode <--
func (m *TLStatsGetMessageStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb6e0a3f5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}

			// m3 := &InputChannel{}
			// _ = m3.Decode(d)
			// m.Channel = m3
			m.Channel, _ = DecodeInputChannelClazz(d)

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetStoryStats <--
type TLStatsGetStoryStats struct {
	ClazzID uint32         `json:"_id"`
	Dark    bool           `json:"dark"`
	Peer    InputPeerClazz `json:"peer"`
	Id      int32          `json:"id"`
}

func (m *TLStatsGetStoryStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetStoryStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x374fef40: func() error {
			x.PutClazzID(0x374fef40)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getStoryStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getStoryStats, layer)
	}
}

// Decode <--
func (m *TLStatsGetStoryStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x374fef40: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetStoryPublicForwards <--
type TLStatsGetStoryPublicForwards struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      int32          `json:"id"`
	Offset  string         `json:"offset"`
	Limit   int32          `json:"limit"`
}

func (m *TLStatsGetStoryPublicForwards) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetStoryPublicForwards) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa6437ef6: func() error {
			x.PutClazzID(0xa6437ef6)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getStoryPublicForwards, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getStoryPublicForwards, layer)
	}
}

// Decode <--
func (m *TLStatsGetStoryPublicForwards) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa6437ef6: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsExportChatlistInvite <--
type TLChatlistsExportChatlistInvite struct {
	ClazzID  uint32             `json:"_id"`
	Chatlist InputChatlistClazz `json:"chatlist"`
	Title    string             `json:"title"`
	Peers    []InputPeerClazz   `json:"peers"`
}

func (m *TLChatlistsExportChatlistInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsExportChatlistInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8472478e: func() error {
			x.PutClazzID(0x8472478e)

			_ = m.Chatlist.Encode(x, layer)
			x.PutString(m.Title)

			_ = iface.EncodeObjectList(x, m.Peers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_exportChatlistInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_exportChatlistInvite, layer)
	}
}

// Decode <--
func (m *TLChatlistsExportChatlistInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8472478e: func() (err error) {

			// m1 := &InputChatlist{}
			// _ = m1.Decode(d)
			// m.Chatlist = m1
			m.Chatlist, _ = DecodeInputChatlistClazz(d)

			m.Title, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			// v3 := make([]*InputPeer, l3)
			v3 := make([]InputPeerClazz, l3)
			for i := 0; i < l3; i++ {
				// vv := new(InputPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v3[i] = vv
				v3[i], _ = DecodeInputPeerClazz(d)
				_ = err3
			}
			m.Peers = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsDeleteExportedInvite <--
type TLChatlistsDeleteExportedInvite struct {
	ClazzID  uint32             `json:"_id"`
	Chatlist InputChatlistClazz `json:"chatlist"`
	Slug     string             `json:"slug"`
}

func (m *TLChatlistsDeleteExportedInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsDeleteExportedInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x719c5c5e: func() error {
			x.PutClazzID(0x719c5c5e)

			_ = m.Chatlist.Encode(x, layer)
			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_deleteExportedInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_deleteExportedInvite, layer)
	}
}

// Decode <--
func (m *TLChatlistsDeleteExportedInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x719c5c5e: func() (err error) {

			// m1 := &InputChatlist{}
			// _ = m1.Decode(d)
			// m.Chatlist = m1
			m.Chatlist, _ = DecodeInputChatlistClazz(d)

			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsEditExportedInvite <--
type TLChatlistsEditExportedInvite struct {
	ClazzID  uint32             `json:"_id"`
	Chatlist InputChatlistClazz `json:"chatlist"`
	Slug     string             `json:"slug"`
	Title    *string            `json:"title"`
	Peers    []InputPeerClazz   `json:"peers"`
}

func (m *TLChatlistsEditExportedInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsEditExportedInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x653db63d: func() error {
			x.PutClazzID(0x653db63d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Title != nil {
					flags |= 1 << 1
				}
				if m.Peers != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Chatlist.Encode(x, layer)
			x.PutString(m.Slug)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.Peers != nil {
				_ = iface.EncodeObjectList(x, m.Peers, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_editExportedInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_editExportedInvite, layer)
	}
}

// Decode <--
func (m *TLChatlistsEditExportedInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x653db63d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputChatlist{}
			// _ = m2.Decode(d)
			// m.Chatlist = m2
			m.Chatlist, _ = DecodeInputChatlistClazz(d)

			m.Slug, err = d.String()
			if (flags & (1 << 1)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				c5, err2 := d.ClazzID()
				if c5 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
					return err2
				}
				l5, err3 := d.Int()
				// v5 := make([]*InputPeer, l5)
				v5 := make([]InputPeerClazz, l5)
				for i := 0; i < l5; i++ {
					// vv := new(InputPeer)
					// err3 = vv.Decode(d)
					// _ = err3
					// v5[i] = vv
					v5[i], _ = DecodeInputPeerClazz(d)
					_ = err3
				}
				m.Peers = v5
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsGetExportedInvites <--
type TLChatlistsGetExportedInvites struct {
	ClazzID  uint32             `json:"_id"`
	Chatlist InputChatlistClazz `json:"chatlist"`
}

func (m *TLChatlistsGetExportedInvites) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsGetExportedInvites) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xce03da83: func() error {
			x.PutClazzID(0xce03da83)

			_ = m.Chatlist.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_getExportedInvites, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_getExportedInvites, layer)
	}
}

// Decode <--
func (m *TLChatlistsGetExportedInvites) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xce03da83: func() (err error) {

			// m1 := &InputChatlist{}
			// _ = m1.Decode(d)
			// m.Chatlist = m1
			m.Chatlist, _ = DecodeInputChatlistClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsCheckChatlistInvite <--
type TLChatlistsCheckChatlistInvite struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLChatlistsCheckChatlistInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsCheckChatlistInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x41c10fff: func() error {
			x.PutClazzID(0x41c10fff)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_checkChatlistInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_checkChatlistInvite, layer)
	}
}

// Decode <--
func (m *TLChatlistsCheckChatlistInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x41c10fff: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsJoinChatlistInvite <--
type TLChatlistsJoinChatlistInvite struct {
	ClazzID uint32           `json:"_id"`
	Slug    string           `json:"slug"`
	Peers   []InputPeerClazz `json:"peers"`
}

func (m *TLChatlistsJoinChatlistInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsJoinChatlistInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa6b1e39a: func() error {
			x.PutClazzID(0xa6b1e39a)

			x.PutString(m.Slug)

			_ = iface.EncodeObjectList(x, m.Peers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_joinChatlistInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_joinChatlistInvite, layer)
	}
}

// Decode <--
func (m *TLChatlistsJoinChatlistInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa6b1e39a: func() (err error) {
			m.Slug, err = d.String()
			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputPeer, l2)
			v2 := make([]InputPeerClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputPeerClazz(d)
				_ = err3
			}
			m.Peers = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsGetChatlistUpdates <--
type TLChatlistsGetChatlistUpdates struct {
	ClazzID  uint32             `json:"_id"`
	Chatlist InputChatlistClazz `json:"chatlist"`
}

func (m *TLChatlistsGetChatlistUpdates) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsGetChatlistUpdates) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x89419521: func() error {
			x.PutClazzID(0x89419521)

			_ = m.Chatlist.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_getChatlistUpdates, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_getChatlistUpdates, layer)
	}
}

// Decode <--
func (m *TLChatlistsGetChatlistUpdates) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x89419521: func() (err error) {

			// m1 := &InputChatlist{}
			// _ = m1.Decode(d)
			// m.Chatlist = m1
			m.Chatlist, _ = DecodeInputChatlistClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsJoinChatlistUpdates <--
type TLChatlistsJoinChatlistUpdates struct {
	ClazzID  uint32             `json:"_id"`
	Chatlist InputChatlistClazz `json:"chatlist"`
	Peers    []InputPeerClazz   `json:"peers"`
}

func (m *TLChatlistsJoinChatlistUpdates) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsJoinChatlistUpdates) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe089f8f5: func() error {
			x.PutClazzID(0xe089f8f5)

			_ = m.Chatlist.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Peers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_joinChatlistUpdates, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_joinChatlistUpdates, layer)
	}
}

// Decode <--
func (m *TLChatlistsJoinChatlistUpdates) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe089f8f5: func() (err error) {

			// m1 := &InputChatlist{}
			// _ = m1.Decode(d)
			// m.Chatlist = m1
			m.Chatlist, _ = DecodeInputChatlistClazz(d)

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputPeer, l2)
			v2 := make([]InputPeerClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputPeerClazz(d)
				_ = err3
			}
			m.Peers = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsHideChatlistUpdates <--
type TLChatlistsHideChatlistUpdates struct {
	ClazzID  uint32             `json:"_id"`
	Chatlist InputChatlistClazz `json:"chatlist"`
}

func (m *TLChatlistsHideChatlistUpdates) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsHideChatlistUpdates) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x66e486fb: func() error {
			x.PutClazzID(0x66e486fb)

			_ = m.Chatlist.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_hideChatlistUpdates, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_hideChatlistUpdates, layer)
	}
}

// Decode <--
func (m *TLChatlistsHideChatlistUpdates) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x66e486fb: func() (err error) {

			// m1 := &InputChatlist{}
			// _ = m1.Decode(d)
			// m.Chatlist = m1
			m.Chatlist, _ = DecodeInputChatlistClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsGetLeaveChatlistSuggestions <--
type TLChatlistsGetLeaveChatlistSuggestions struct {
	ClazzID  uint32             `json:"_id"`
	Chatlist InputChatlistClazz `json:"chatlist"`
}

func (m *TLChatlistsGetLeaveChatlistSuggestions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsGetLeaveChatlistSuggestions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfdbcd714: func() error {
			x.PutClazzID(0xfdbcd714)

			_ = m.Chatlist.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_getLeaveChatlistSuggestions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_getLeaveChatlistSuggestions, layer)
	}
}

// Decode <--
func (m *TLChatlistsGetLeaveChatlistSuggestions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfdbcd714: func() (err error) {

			// m1 := &InputChatlist{}
			// _ = m1.Decode(d)
			// m.Chatlist = m1
			m.Chatlist, _ = DecodeInputChatlistClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsLeaveChatlist <--
type TLChatlistsLeaveChatlist struct {
	ClazzID  uint32             `json:"_id"`
	Chatlist InputChatlistClazz `json:"chatlist"`
	Peers    []InputPeerClazz   `json:"peers"`
}

func (m *TLChatlistsLeaveChatlist) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsLeaveChatlist) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x74fae13a: func() error {
			x.PutClazzID(0x74fae13a)

			_ = m.Chatlist.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Peers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_leaveChatlist, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_leaveChatlist, layer)
	}
}

// Decode <--
func (m *TLChatlistsLeaveChatlist) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x74fae13a: func() (err error) {

			// m1 := &InputChatlist{}
			// _ = m1.Decode(d)
			// m.Chatlist = m1
			m.Chatlist, _ = DecodeInputChatlistClazz(d)

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			// v2 := make([]*InputPeer, l2)
			v2 := make([]InputPeerClazz, l2)
			for i := 0; i < l2; i++ {
				// vv := new(InputPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v2[i] = vv
				v2[i], _ = DecodeInputPeerClazz(d)
				_ = err3
			}
			m.Peers = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesCanSendStory <--
type TLStoriesCanSendStory struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLStoriesCanSendStory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesCanSendStory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x30eb63f0: func() error {
			x.PutClazzID(0x30eb63f0)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_canSendStory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_canSendStory, layer)
	}
}

// Decode <--
func (m *TLStoriesCanSendStory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x30eb63f0: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesSendStory <--
type TLStoriesSendStory struct {
	ClazzID      uint32                  `json:"_id"`
	Pinned       bool                    `json:"pinned"`
	Noforwards   bool                    `json:"noforwards"`
	FwdModified  bool                    `json:"fwd_modified"`
	Peer         InputPeerClazz          `json:"peer"`
	Media        InputMediaClazz         `json:"media"`
	MediaAreas   []MediaAreaClazz        `json:"media_areas"`
	Caption      *string                 `json:"caption"`
	Entities     []MessageEntityClazz    `json:"entities"`
	PrivacyRules []InputPrivacyRuleClazz `json:"privacy_rules"`
	RandomId     int64                   `json:"random_id"`
	Period       *int32                  `json:"period"`
	FwdFromId    InputPeerClazz          `json:"fwd_from_id"`
	FwdFromStory *int32                  `json:"fwd_from_story"`
	Albums       []int32                 `json:"albums"`
}

func (m *TLStoriesSendStory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesSendStory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x737fc2ec: func() error {
			x.PutClazzID(0x737fc2ec)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Pinned == true {
					flags |= 1 << 2
				}
				if m.Noforwards == true {
					flags |= 1 << 4
				}
				if m.FwdModified == true {
					flags |= 1 << 7
				}

				if m.MediaAreas != nil {
					flags |= 1 << 5
				}
				if m.Caption != nil {
					flags |= 1 << 0
				}
				if m.Entities != nil {
					flags |= 1 << 1
				}

				if m.Period != nil {
					flags |= 1 << 3
				}
				if m.FwdFromId != nil {
					flags |= 1 << 6
				}
				if m.FwdFromStory != nil {
					flags |= 1 << 6
				}
				if m.Albums != nil {
					flags |= 1 << 8
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.Media.Encode(x, layer)
			if m.MediaAreas != nil {
				_ = iface.EncodeObjectList(x, m.MediaAreas, layer)
			}
			if m.Caption != nil {
				x.PutString(*m.Caption)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}

			_ = iface.EncodeObjectList(x, m.PrivacyRules, layer)

			x.PutInt64(m.RandomId)
			if m.Period != nil {
				x.PutInt32(*m.Period)
			}

			if m.FwdFromId != nil {
				_ = m.FwdFromId.Encode(x, layer)
			}

			if m.FwdFromStory != nil {
				x.PutInt32(*m.FwdFromStory)
			}

			if m.Albums != nil {
				iface.EncodeInt32List(x, m.Albums)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_sendStory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_sendStory, layer)
	}
}

// Decode <--
func (m *TLStoriesSendStory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x737fc2ec: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m.Pinned = true
			}
			if (flags & (1 << 4)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 7)) != 0 {
				m.FwdModified = true
			}

			// m5 := &InputPeer{}
			// _ = m5.Decode(d)
			// m.Peer = m5
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m6 := &InputMedia{}
			// _ = m6.Decode(d)
			// m.Media = m6
			m.Media, _ = DecodeInputMediaClazz(d)

			if (flags & (1 << 5)) != 0 {
				c7, err2 := d.ClazzID()
				if c7 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 7, c7)
					return err2
				}
				l7, err3 := d.Int()
				// v7 := make([]*MediaArea, l7)
				v7 := make([]MediaAreaClazz, l7)
				for i := 0; i < l7; i++ {
					// vv := new(MediaArea)
					// err3 = vv.Decode(d)
					// _ = err3
					// v7[i] = vv
					v7[i], _ = DecodeMediaAreaClazz(d)
					_ = err3
				}
				m.MediaAreas = v7
			}
			if (flags & (1 << 0)) != 0 {
				m.Caption = new(string)
				*m.Caption, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				c9, err2 := d.ClazzID()
				if c9 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 9, c9)
					return err2
				}
				l9, err3 := d.Int()
				// v9 := make([]*MessageEntity, l9)
				v9 := make([]MessageEntityClazz, l9)
				for i := 0; i < l9; i++ {
					// vv := new(MessageEntity)
					// err3 = vv.Decode(d)
					// _ = err3
					// v9[i] = vv
					v9[i], _ = DecodeMessageEntityClazz(d)
					_ = err3
				}
				m.Entities = v9
			}
			c10, err2 := d.ClazzID()
			if c10 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 10, c10)
				return err2
			}
			l10, err3 := d.Int()
			// v10 := make([]*InputPrivacyRule, l10)
			v10 := make([]InputPrivacyRuleClazz, l10)
			for i := 0; i < l10; i++ {
				// vv := new(InputPrivacyRule)
				// err3 = vv.Decode(d)
				// _ = err3
				// v10[i] = vv
				v10[i], _ = DecodeInputPrivacyRuleClazz(d)
				_ = err3
			}
			m.PrivacyRules = v10

			m.RandomId, err = d.Int64()
			if (flags & (1 << 3)) != 0 {
				m.Period = new(int32)
				*m.Period, err = d.Int32()
			}
			if (flags & (1 << 6)) != 0 {
				// m13 := &InputPeer{}
				// _ = m13.Decode(d)
				// m.FwdFromId = m13
				m.FwdFromId, _ = DecodeInputPeerClazz(d)
			}
			if (flags & (1 << 6)) != 0 {
				m.FwdFromStory = new(int32)
				*m.FwdFromStory, err = d.Int32()
			}
			if (flags & (1 << 8)) != 0 {
				m.Albums, err = iface.DecodeInt32List(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesEditStory <--
type TLStoriesEditStory struct {
	ClazzID      uint32                  `json:"_id"`
	Peer         InputPeerClazz          `json:"peer"`
	Id           int32                   `json:"id"`
	Media        InputMediaClazz         `json:"media"`
	MediaAreas   []MediaAreaClazz        `json:"media_areas"`
	Caption      *string                 `json:"caption"`
	Entities     []MessageEntityClazz    `json:"entities"`
	PrivacyRules []InputPrivacyRuleClazz `json:"privacy_rules"`
}

func (m *TLStoriesEditStory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesEditStory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb583ba46: func() error {
			x.PutClazzID(0xb583ba46)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Media != nil {
					flags |= 1 << 0
				}
				if m.MediaAreas != nil {
					flags |= 1 << 3
				}
				if m.Caption != nil {
					flags |= 1 << 1
				}
				if m.Entities != nil {
					flags |= 1 << 1
				}
				if m.PrivacyRules != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			if m.Media != nil {
				_ = m.Media.Encode(x, layer)
			}

			if m.MediaAreas != nil {
				_ = iface.EncodeObjectList(x, m.MediaAreas, layer)
			}
			if m.Caption != nil {
				x.PutString(*m.Caption)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.PrivacyRules != nil {
				_ = iface.EncodeObjectList(x, m.PrivacyRules, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_editStory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_editStory, layer)
	}
}

// Decode <--
func (m *TLStoriesEditStory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb583ba46: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				// m4 := &InputMedia{}
				// _ = m4.Decode(d)
				// m.Media = m4
				m.Media, _ = DecodeInputMediaClazz(d)
			}
			if (flags & (1 << 3)) != 0 {
				c5, err2 := d.ClazzID()
				if c5 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
					return err2
				}
				l5, err3 := d.Int()
				// v5 := make([]*MediaArea, l5)
				v5 := make([]MediaAreaClazz, l5)
				for i := 0; i < l5; i++ {
					// vv := new(MediaArea)
					// err3 = vv.Decode(d)
					// _ = err3
					// v5[i] = vv
					v5[i], _ = DecodeMediaAreaClazz(d)
					_ = err3
				}
				m.MediaAreas = v5
			}
			if (flags & (1 << 1)) != 0 {
				m.Caption = new(string)
				*m.Caption, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				c7, err2 := d.ClazzID()
				if c7 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 7, c7)
					return err2
				}
				l7, err3 := d.Int()
				// v7 := make([]*MessageEntity, l7)
				v7 := make([]MessageEntityClazz, l7)
				for i := 0; i < l7; i++ {
					// vv := new(MessageEntity)
					// err3 = vv.Decode(d)
					// _ = err3
					// v7[i] = vv
					v7[i], _ = DecodeMessageEntityClazz(d)
					_ = err3
				}
				m.Entities = v7
			}
			if (flags & (1 << 2)) != 0 {
				c8, err2 := d.ClazzID()
				if c8 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 8, c8)
					return err2
				}
				l8, err3 := d.Int()
				// v8 := make([]*InputPrivacyRule, l8)
				v8 := make([]InputPrivacyRuleClazz, l8)
				for i := 0; i < l8; i++ {
					// vv := new(InputPrivacyRule)
					// err3 = vv.Decode(d)
					// _ = err3
					// v8[i] = vv
					v8[i], _ = DecodeInputPrivacyRuleClazz(d)
					_ = err3
				}
				m.PrivacyRules = v8
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesDeleteStories <--
type TLStoriesDeleteStories struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLStoriesDeleteStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesDeleteStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xae59db5f: func() error {
			x.PutClazzID(0xae59db5f)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_deleteStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_deleteStories, layer)
	}
}

// Decode <--
func (m *TLStoriesDeleteStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xae59db5f: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesTogglePinned <--
type TLStoriesTogglePinned struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
	Pinned  BoolClazz      `json:"pinned"`
}

func (m *TLStoriesTogglePinned) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesTogglePinned) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9a75a1ef: func() error {
			x.PutClazzID(0x9a75a1ef)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			_ = m.Pinned.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_togglePinned, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_togglePinned, layer)
	}
}

// Decode <--
func (m *TLStoriesTogglePinned) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9a75a1ef: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			// m3 := &Bool{}
			// _ = m3.Decode(d)
			// m.Pinned = m3
			m.Pinned, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetAllStories <--
type TLStoriesGetAllStories struct {
	ClazzID uint32  `json:"_id"`
	Next    bool    `json:"next"`
	Hidden  bool    `json:"hidden"`
	State   *string `json:"state"`
}

func (m *TLStoriesGetAllStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetAllStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xeeb0d625: func() error {
			x.PutClazzID(0xeeb0d625)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Next == true {
					flags |= 1 << 1
				}
				if m.Hidden == true {
					flags |= 1 << 2
				}
				if m.State != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.State != nil {
				x.PutString(*m.State)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getAllStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getAllStories, layer)
	}
}

// Decode <--
func (m *TLStoriesGetAllStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xeeb0d625: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Next = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Hidden = true
			}
			if (flags & (1 << 0)) != 0 {
				m.State = new(string)
				*m.State, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetPinnedStories <--
type TLStoriesGetPinnedStories struct {
	ClazzID  uint32         `json:"_id"`
	Peer     InputPeerClazz `json:"peer"`
	OffsetId int32          `json:"offset_id"`
	Limit    int32          `json:"limit"`
}

func (m *TLStoriesGetPinnedStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetPinnedStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5821a5dc: func() error {
			x.PutClazzID(0x5821a5dc)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getPinnedStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getPinnedStories, layer)
	}
}

// Decode <--
func (m *TLStoriesGetPinnedStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5821a5dc: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.OffsetId, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetStoriesArchive <--
type TLStoriesGetStoriesArchive struct {
	ClazzID  uint32         `json:"_id"`
	Peer     InputPeerClazz `json:"peer"`
	OffsetId int32          `json:"offset_id"`
	Limit    int32          `json:"limit"`
}

func (m *TLStoriesGetStoriesArchive) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetStoriesArchive) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb4352016: func() error {
			x.PutClazzID(0xb4352016)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getStoriesArchive, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getStoriesArchive, layer)
	}
}

// Decode <--
func (m *TLStoriesGetStoriesArchive) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb4352016: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.OffsetId, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetStoriesByID <--
type TLStoriesGetStoriesByID struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLStoriesGetStoriesByID) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetStoriesByID) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5774ca74: func() error {
			x.PutClazzID(0x5774ca74)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getStoriesByID, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getStoriesByID, layer)
	}
}

// Decode <--
func (m *TLStoriesGetStoriesByID) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5774ca74: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesToggleAllStoriesHidden <--
type TLStoriesToggleAllStoriesHidden struct {
	ClazzID uint32    `json:"_id"`
	Hidden  BoolClazz `json:"hidden"`
}

func (m *TLStoriesToggleAllStoriesHidden) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesToggleAllStoriesHidden) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7c2557c4: func() error {
			x.PutClazzID(0x7c2557c4)

			_ = m.Hidden.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_toggleAllStoriesHidden, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_toggleAllStoriesHidden, layer)
	}
}

// Decode <--
func (m *TLStoriesToggleAllStoriesHidden) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7c2557c4: func() (err error) {

			// m1 := &Bool{}
			// _ = m1.Decode(d)
			// m.Hidden = m1
			m.Hidden, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesReadStories <--
type TLStoriesReadStories struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	MaxId   int32          `json:"max_id"`
}

func (m *TLStoriesReadStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesReadStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa556dac8: func() error {
			x.PutClazzID(0xa556dac8)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_readStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_readStories, layer)
	}
}

// Decode <--
func (m *TLStoriesReadStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa556dac8: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesIncrementStoryViews <--
type TLStoriesIncrementStoryViews struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLStoriesIncrementStoryViews) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesIncrementStoryViews) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb2028afb: func() error {
			x.PutClazzID(0xb2028afb)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_incrementStoryViews, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_incrementStoryViews, layer)
	}
}

// Decode <--
func (m *TLStoriesIncrementStoryViews) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb2028afb: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetStoryViewsList <--
type TLStoriesGetStoryViewsList struct {
	ClazzID        uint32         `json:"_id"`
	JustContacts   bool           `json:"just_contacts"`
	ReactionsFirst bool           `json:"reactions_first"`
	ForwardsFirst  bool           `json:"forwards_first"`
	Peer           InputPeerClazz `json:"peer"`
	Q              *string        `json:"q"`
	Id             int32          `json:"id"`
	Offset         string         `json:"offset"`
	Limit          int32          `json:"limit"`
}

func (m *TLStoriesGetStoryViewsList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetStoryViewsList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7ed23c57: func() error {
			x.PutClazzID(0x7ed23c57)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.JustContacts == true {
					flags |= 1 << 0
				}
				if m.ReactionsFirst == true {
					flags |= 1 << 2
				}
				if m.ForwardsFirst == true {
					flags |= 1 << 3
				}

				if m.Q != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.Q != nil {
				x.PutString(*m.Q)
			}

			x.PutInt32(m.Id)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getStoryViewsList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getStoryViewsList, layer)
	}
}

// Decode <--
func (m *TLStoriesGetStoryViewsList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7ed23c57: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.JustContacts = true
			}
			if (flags & (1 << 2)) != 0 {
				m.ReactionsFirst = true
			}
			if (flags & (1 << 3)) != 0 {
				m.ForwardsFirst = true
			}

			// m5 := &InputPeer{}
			// _ = m5.Decode(d)
			// m.Peer = m5
			m.Peer, _ = DecodeInputPeerClazz(d)

			if (flags & (1 << 1)) != 0 {
				m.Q = new(string)
				*m.Q, err = d.String()
			}

			m.Id, err = d.Int32()
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetStoriesViews <--
type TLStoriesGetStoriesViews struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLStoriesGetStoriesViews) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetStoriesViews) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x28e16cc8: func() error {
			x.PutClazzID(0x28e16cc8)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getStoriesViews, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getStoriesViews, layer)
	}
}

// Decode <--
func (m *TLStoriesGetStoriesViews) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x28e16cc8: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesExportStoryLink <--
type TLStoriesExportStoryLink struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      int32          `json:"id"`
}

func (m *TLStoriesExportStoryLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesExportStoryLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7b8def20: func() error {
			x.PutClazzID(0x7b8def20)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_exportStoryLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_exportStoryLink, layer)
	}
}

// Decode <--
func (m *TLStoriesExportStoryLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7b8def20: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesReport <--
type TLStoriesReport struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
	Option  []byte         `json:"option"`
	Message string         `json:"message"`
}

func (m *TLStoriesReport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesReport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x19d8eb45: func() error {
			x.PutClazzID(0x19d8eb45)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			x.PutBytes(m.Option)
			x.PutString(m.Message)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_report, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_report, layer)
	}
}

// Decode <--
func (m *TLStoriesReport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x19d8eb45: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			m.Option, err = d.Bytes()
			m.Message, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesActivateStealthMode <--
type TLStoriesActivateStealthMode struct {
	ClazzID uint32 `json:"_id"`
	Past    bool   `json:"past"`
	Future  bool   `json:"future"`
}

func (m *TLStoriesActivateStealthMode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesActivateStealthMode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x57bbd166: func() error {
			x.PutClazzID(0x57bbd166)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Past == true {
					flags |= 1 << 0
				}
				if m.Future == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_activateStealthMode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_activateStealthMode, layer)
	}
}

// Decode <--
func (m *TLStoriesActivateStealthMode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x57bbd166: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Past = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Future = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesSendReaction <--
type TLStoriesSendReaction struct {
	ClazzID     uint32         `json:"_id"`
	AddToRecent bool           `json:"add_to_recent"`
	Peer        InputPeerClazz `json:"peer"`
	StoryId     int32          `json:"story_id"`
	Reaction    ReactionClazz  `json:"reaction"`
}

func (m *TLStoriesSendReaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesSendReaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7fd736b2: func() error {
			x.PutClazzID(0x7fd736b2)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.AddToRecent == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.StoryId)
			_ = m.Reaction.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_sendReaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_sendReaction, layer)
	}
}

// Decode <--
func (m *TLStoriesSendReaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7fd736b2: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.AddToRecent = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.StoryId, err = d.Int32()

			// m5 := &Reaction{}
			// _ = m5.Decode(d)
			// m.Reaction = m5
			m.Reaction, _ = DecodeReactionClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetPeerStories <--
type TLStoriesGetPeerStories struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLStoriesGetPeerStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetPeerStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2c4ada50: func() error {
			x.PutClazzID(0x2c4ada50)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getPeerStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getPeerStories, layer)
	}
}

// Decode <--
func (m *TLStoriesGetPeerStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2c4ada50: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetAllReadPeerStories <--
type TLStoriesGetAllReadPeerStories struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLStoriesGetAllReadPeerStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetAllReadPeerStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9b5ae7f9: func() error {
			x.PutClazzID(0x9b5ae7f9)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getAllReadPeerStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getAllReadPeerStories, layer)
	}
}

// Decode <--
func (m *TLStoriesGetAllReadPeerStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9b5ae7f9: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetPeerMaxIDs <--
type TLStoriesGetPeerMaxIDs struct {
	ClazzID uint32           `json:"_id"`
	Id      []InputPeerClazz `json:"id"`
}

func (m *TLStoriesGetPeerMaxIDs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetPeerMaxIDs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x535983c3: func() error {
			x.PutClazzID(0x535983c3)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getPeerMaxIDs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getPeerMaxIDs, layer)
	}
}

// Decode <--
func (m *TLStoriesGetPeerMaxIDs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x535983c3: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			// v1 := make([]*InputPeer, l1)
			v1 := make([]InputPeerClazz, l1)
			for i := 0; i < l1; i++ {
				// vv := new(InputPeer)
				// err3 = vv.Decode(d)
				// _ = err3
				// v1[i] = vv
				v1[i], _ = DecodeInputPeerClazz(d)
				_ = err3
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetChatsToSend <--
type TLStoriesGetChatsToSend struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLStoriesGetChatsToSend) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetChatsToSend) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa56a8b60: func() error {
			x.PutClazzID(0xa56a8b60)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getChatsToSend, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getChatsToSend, layer)
	}
}

// Decode <--
func (m *TLStoriesGetChatsToSend) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa56a8b60: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesTogglePeerStoriesHidden <--
type TLStoriesTogglePeerStoriesHidden struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Hidden  BoolClazz      `json:"hidden"`
}

func (m *TLStoriesTogglePeerStoriesHidden) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesTogglePeerStoriesHidden) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbd0415c4: func() error {
			x.PutClazzID(0xbd0415c4)

			_ = m.Peer.Encode(x, layer)
			_ = m.Hidden.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_togglePeerStoriesHidden, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_togglePeerStoriesHidden, layer)
	}
}

// Decode <--
func (m *TLStoriesTogglePeerStoriesHidden) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbd0415c4: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &Bool{}
			// _ = m2.Decode(d)
			// m.Hidden = m2
			m.Hidden, _ = DecodeBoolClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetStoryReactionsList <--
type TLStoriesGetStoryReactionsList struct {
	ClazzID       uint32         `json:"_id"`
	ForwardsFirst bool           `json:"forwards_first"`
	Peer          InputPeerClazz `json:"peer"`
	Id            int32          `json:"id"`
	Reaction      ReactionClazz  `json:"reaction"`
	Offset        *string        `json:"offset"`
	Limit         int32          `json:"limit"`
}

func (m *TLStoriesGetStoryReactionsList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetStoryReactionsList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb9b2881f: func() error {
			x.PutClazzID(0xb9b2881f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForwardsFirst == true {
					flags |= 1 << 2
				}

				if m.Reaction != nil {
					flags |= 1 << 0
				}
				if m.Offset != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			if m.Reaction != nil {
				_ = m.Reaction.Encode(x, layer)
			}

			if m.Offset != nil {
				x.PutString(*m.Offset)
			}

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getStoryReactionsList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getStoryReactionsList, layer)
	}
}

// Decode <--
func (m *TLStoriesGetStoryReactionsList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb9b2881f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m.ForwardsFirst = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				// m5 := &Reaction{}
				// _ = m5.Decode(d)
				// m.Reaction = m5
				m.Reaction, _ = DecodeReactionClazz(d)
			}
			if (flags & (1 << 1)) != 0 {
				m.Offset = new(string)
				*m.Offset, err = d.String()
			}

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesTogglePinnedToTop <--
type TLStoriesTogglePinnedToTop struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Id      []int32        `json:"id"`
}

func (m *TLStoriesTogglePinnedToTop) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesTogglePinnedToTop) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb297e9b: func() error {
			x.PutClazzID(0xb297e9b)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_togglePinnedToTop, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_togglePinnedToTop, layer)
	}
}

// Decode <--
func (m *TLStoriesTogglePinnedToTop) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb297e9b: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesSearchPosts <--
type TLStoriesSearchPosts struct {
	ClazzID uint32         `json:"_id"`
	Hashtag *string        `json:"hashtag"`
	Area    MediaAreaClazz `json:"area"`
	Peer    InputPeerClazz `json:"peer"`
	Offset  string         `json:"offset"`
	Limit   int32          `json:"limit"`
}

func (m *TLStoriesSearchPosts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesSearchPosts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd1810907: func() error {
			x.PutClazzID(0xd1810907)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Hashtag != nil {
					flags |= 1 << 0
				}
				if m.Area != nil {
					flags |= 1 << 1
				}
				if m.Peer != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Hashtag != nil {
				x.PutString(*m.Hashtag)
			}

			if m.Area != nil {
				_ = m.Area.Encode(x, layer)
			}

			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_searchPosts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_searchPosts, layer)
	}
}

// Decode <--
func (m *TLStoriesSearchPosts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd1810907: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Hashtag = new(string)
				*m.Hashtag, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				// m3 := &MediaArea{}
				// _ = m3.Decode(d)
				// m.Area = m3
				m.Area, _ = DecodeMediaAreaClazz(d)
			}
			if (flags & (1 << 2)) != 0 {
				// m4 := &InputPeer{}
				// _ = m4.Decode(d)
				// m.Peer = m4
				m.Peer, _ = DecodeInputPeerClazz(d)
			}
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesCreateAlbum <--
type TLStoriesCreateAlbum struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Title   string         `json:"title"`
	Stories []int32        `json:"stories"`
}

func (m *TLStoriesCreateAlbum) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesCreateAlbum) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa36396e5: func() error {
			x.PutClazzID(0xa36396e5)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Title)

			iface.EncodeInt32List(x, m.Stories)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_createAlbum, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_createAlbum, layer)
	}
}

// Decode <--
func (m *TLStoriesCreateAlbum) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa36396e5: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Title, err = d.String()

			m.Stories, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesUpdateAlbum <--
type TLStoriesUpdateAlbum struct {
	ClazzID       uint32         `json:"_id"`
	Peer          InputPeerClazz `json:"peer"`
	AlbumId       int32          `json:"album_id"`
	Title         *string        `json:"title"`
	DeleteStories []int32        `json:"delete_stories"`
	AddStories    []int32        `json:"add_stories"`
	Order         []int32        `json:"order"`
}

func (m *TLStoriesUpdateAlbum) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesUpdateAlbum) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5e5259b6: func() error {
			x.PutClazzID(0x5e5259b6)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Title != nil {
					flags |= 1 << 0
				}
				if m.DeleteStories != nil {
					flags |= 1 << 1
				}
				if m.AddStories != nil {
					flags |= 1 << 2
				}
				if m.Order != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.AlbumId)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.DeleteStories != nil {
				iface.EncodeInt32List(x, m.DeleteStories)
			}
			if m.AddStories != nil {
				iface.EncodeInt32List(x, m.AddStories)
			}
			if m.Order != nil {
				iface.EncodeInt32List(x, m.Order)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_updateAlbum, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_updateAlbum, layer)
	}
}

// Decode <--
func (m *TLStoriesUpdateAlbum) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5e5259b6: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			// m2 := &InputPeer{}
			// _ = m2.Decode(d)
			// m.Peer = m2
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.AlbumId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.DeleteStories, err = iface.DecodeInt32List(d)
			}
			if (flags & (1 << 2)) != 0 {
				m.AddStories, err = iface.DecodeInt32List(d)
			}
			if (flags & (1 << 3)) != 0 {
				m.Order, err = iface.DecodeInt32List(d)
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesReorderAlbums <--
type TLStoriesReorderAlbums struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Order   []int32        `json:"order"`
}

func (m *TLStoriesReorderAlbums) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesReorderAlbums) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8535fbd9: func() error {
			x.PutClazzID(0x8535fbd9)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_reorderAlbums, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_reorderAlbums, layer)
	}
}

// Decode <--
func (m *TLStoriesReorderAlbums) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8535fbd9: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Order, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesDeleteAlbum <--
type TLStoriesDeleteAlbum struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	AlbumId int32          `json:"album_id"`
}

func (m *TLStoriesDeleteAlbum) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesDeleteAlbum) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8d3456d0: func() error {
			x.PutClazzID(0x8d3456d0)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.AlbumId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_deleteAlbum, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_deleteAlbum, layer)
	}
}

// Decode <--
func (m *TLStoriesDeleteAlbum) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8d3456d0: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.AlbumId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetAlbums <--
type TLStoriesGetAlbums struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	Hash    int64          `json:"hash"`
}

func (m *TLStoriesGetAlbums) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetAlbums) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x25b3eac7: func() error {
			x.PutClazzID(0x25b3eac7)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getAlbums, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getAlbums, layer)
	}
}

// Decode <--
func (m *TLStoriesGetAlbums) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x25b3eac7: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetAlbumStories <--
type TLStoriesGetAlbumStories struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	AlbumId int32          `json:"album_id"`
	Offset  int32          `json:"offset"`
	Limit   int32          `json:"limit"`
}

func (m *TLStoriesGetAlbumStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetAlbumStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xac806d61: func() error {
			x.PutClazzID(0xac806d61)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.AlbumId)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getAlbumStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getAlbumStories, layer)
	}
}

// Decode <--
func (m *TLStoriesGetAlbumStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xac806d61: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.AlbumId, err = d.Int32()
			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPremiumGetBoostsList <--
type TLPremiumGetBoostsList struct {
	ClazzID uint32         `json:"_id"`
	Gifts   bool           `json:"gifts"`
	Peer    InputPeerClazz `json:"peer"`
	Offset  string         `json:"offset"`
	Limit   int32          `json:"limit"`
}

func (m *TLPremiumGetBoostsList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPremiumGetBoostsList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x60f67660: func() error {
			x.PutClazzID(0x60f67660)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Gifts == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_premium_getBoostsList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_premium_getBoostsList, layer)
	}
}

// Decode <--
func (m *TLPremiumGetBoostsList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x60f67660: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Gifts = true
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPremiumGetMyBoosts <--
type TLPremiumGetMyBoosts struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPremiumGetMyBoosts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPremiumGetMyBoosts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbe77b4a: func() error {
			x.PutClazzID(0xbe77b4a)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_premium_getMyBoosts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_premium_getMyBoosts, layer)
	}
}

// Decode <--
func (m *TLPremiumGetMyBoosts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbe77b4a: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPremiumApplyBoost <--
type TLPremiumApplyBoost struct {
	ClazzID uint32         `json:"_id"`
	Slots   []int32        `json:"slots"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLPremiumApplyBoost) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPremiumApplyBoost) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6b7da746: func() error {
			x.PutClazzID(0x6b7da746)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Slots != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Slots != nil {
				iface.EncodeInt32List(x, m.Slots)
			}
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_premium_applyBoost, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_premium_applyBoost, layer)
	}
}

// Decode <--
func (m *TLPremiumApplyBoost) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6b7da746: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Slots, err = iface.DecodeInt32List(d)
			}

			// m3 := &InputPeer{}
			// _ = m3.Decode(d)
			// m.Peer = m3
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPremiumGetBoostsStatus <--
type TLPremiumGetBoostsStatus struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
}

func (m *TLPremiumGetBoostsStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPremiumGetBoostsStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x42f1f61: func() error {
			x.PutClazzID(0x42f1f61)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_premium_getBoostsStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_premium_getBoostsStatus, layer)
	}
}

// Decode <--
func (m *TLPremiumGetBoostsStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x42f1f61: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPremiumGetUserBoosts <--
type TLPremiumGetUserBoosts struct {
	ClazzID uint32         `json:"_id"`
	Peer    InputPeerClazz `json:"peer"`
	UserId  InputUserClazz `json:"user_id"`
}

func (m *TLPremiumGetUserBoosts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPremiumGetUserBoosts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x39854d1f: func() error {
			x.PutClazzID(0x39854d1f)

			_ = m.Peer.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_premium_getUserBoosts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_premium_getUserBoosts, layer)
	}
}

// Decode <--
func (m *TLPremiumGetUserBoosts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x39854d1f: func() (err error) {

			// m1 := &InputPeer{}
			// _ = m1.Decode(d)
			// m.Peer = m1
			m.Peer, _ = DecodeInputPeerClazz(d)

			// m2 := &InputUser{}
			// _ = m2.Decode(d)
			// m.UserId = m2
			m.UserId, _ = DecodeInputUserClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsIsEligibleToJoin <--
type TLSmsjobsIsEligibleToJoin struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLSmsjobsIsEligibleToJoin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsIsEligibleToJoin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xedc39d0: func() error {
			x.PutClazzID(0xedc39d0)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_isEligibleToJoin, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_isEligibleToJoin, layer)
	}
}

// Decode <--
func (m *TLSmsjobsIsEligibleToJoin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xedc39d0: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsJoin <--
type TLSmsjobsJoin struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLSmsjobsJoin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsJoin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa74ece2d: func() error {
			x.PutClazzID(0xa74ece2d)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_join, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_join, layer)
	}
}

// Decode <--
func (m *TLSmsjobsJoin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa74ece2d: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsLeave <--
type TLSmsjobsLeave struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLSmsjobsLeave) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsLeave) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9898ad73: func() error {
			x.PutClazzID(0x9898ad73)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_leave, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_leave, layer)
	}
}

// Decode <--
func (m *TLSmsjobsLeave) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9898ad73: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsUpdateSettings <--
type TLSmsjobsUpdateSettings struct {
	ClazzID            uint32 `json:"_id"`
	AllowInternational bool   `json:"allow_international"`
}

func (m *TLSmsjobsUpdateSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsUpdateSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x93fa0bf: func() error {
			x.PutClazzID(0x93fa0bf)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.AllowInternational == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_updateSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_updateSettings, layer)
	}
}

// Decode <--
func (m *TLSmsjobsUpdateSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x93fa0bf: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.AllowInternational = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsGetStatus <--
type TLSmsjobsGetStatus struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLSmsjobsGetStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsGetStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x10a698e8: func() error {
			x.PutClazzID(0x10a698e8)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_getStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_getStatus, layer)
	}
}

// Decode <--
func (m *TLSmsjobsGetStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x10a698e8: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsGetSmsJob <--
type TLSmsjobsGetSmsJob struct {
	ClazzID uint32 `json:"_id"`
	JobId   string `json:"job_id"`
}

func (m *TLSmsjobsGetSmsJob) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsGetSmsJob) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x778d902f: func() error {
			x.PutClazzID(0x778d902f)

			x.PutString(m.JobId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_getSmsJob, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_getSmsJob, layer)
	}
}

// Decode <--
func (m *TLSmsjobsGetSmsJob) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x778d902f: func() (err error) {
			m.JobId, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsFinishJob <--
type TLSmsjobsFinishJob struct {
	ClazzID uint32  `json:"_id"`
	JobId   string  `json:"job_id"`
	Error   *string `json:"error"`
}

func (m *TLSmsjobsFinishJob) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsFinishJob) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4f1ebf24: func() error {
			x.PutClazzID(0x4f1ebf24)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Error != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.JobId)
			if m.Error != nil {
				x.PutString(*m.Error)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_finishJob, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_finishJob, layer)
	}
}

// Decode <--
func (m *TLSmsjobsFinishJob) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4f1ebf24: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.JobId, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.Error = new(string)
				*m.Error, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLFragmentGetCollectibleInfo <--
type TLFragmentGetCollectibleInfo struct {
	ClazzID     uint32                `json:"_id"`
	Collectible InputCollectibleClazz `json:"collectible"`
}

func (m *TLFragmentGetCollectibleInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLFragmentGetCollectibleInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbe1e85ba: func() error {
			x.PutClazzID(0xbe1e85ba)

			_ = m.Collectible.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_fragment_getCollectibleInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_fragment_getCollectibleInfo, layer)
	}
}

// Decode <--
func (m *TLFragmentGetCollectibleInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbe1e85ba: func() (err error) {

			// m1 := &InputCollectible{}
			// _ = m1.Decode(d)
			// m.Collectible = m1
			m.Collectible, _ = DecodeInputCollectibleClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLTestParseInputAppEvent <--
type TLTestParseInputAppEvent struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLTestParseInputAppEvent) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLTestParseInputAppEvent) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbb0d87f1: func() error {
			x.PutClazzID(0xbb0d87f1)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_test_parseInputAppEvent, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_test_parseInputAppEvent, layer)
	}
}

// Decode <--
func (m *TLTestParseInputAppEvent) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbb0d87f1: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpTest <--
type TLHelpTest struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpTest) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpTest) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc0e202f7: func() error {
			x.PutClazzID(0xc0e202f7)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_test, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_test, layer)
	}
}

// Decode <--
func (m *TLHelpTest) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc0e202f7: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedCreatePredefinedUser <--
type TLPredefinedCreatePredefinedUser struct {
	ClazzID   uint32  `json:"_id"`
	Phone     string  `json:"phone"`
	FirstName *string `json:"first_name"`
	LastName  *string `json:"last_name"`
	Username  *string `json:"username"`
	Code      string  `json:"code"`
	Verified  bool    `json:"verified"`
}

func (m *TLPredefinedCreatePredefinedUser) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedCreatePredefinedUser) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x23e2e31e: func() error {
			x.PutClazzID(0x23e2e31e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FirstName != nil {
					flags |= 1 << 0
				}
				if m.LastName != nil {
					flags |= 1 << 1
				}
				if m.Username != nil {
					flags |= 1 << 2
				}

				if m.Verified == true {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Phone)
			if m.FirstName != nil {
				x.PutString(*m.FirstName)
			}

			if m.LastName != nil {
				x.PutString(*m.LastName)
			}

			if m.Username != nil {
				x.PutString(*m.Username)
			}

			x.PutString(m.Code)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_createPredefinedUser, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_createPredefinedUser, layer)
	}
}

// Decode <--
func (m *TLPredefinedCreatePredefinedUser) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x23e2e31e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Phone, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.FirstName = new(string)
				*m.FirstName, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.LastName = new(string)
				*m.LastName, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.Username = new(string)
				*m.Username, err = d.String()
			}

			m.Code, err = d.String()
			if (flags & (1 << 3)) != 0 {
				m.Verified = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedUpdatePredefinedUsername <--
type TLPredefinedUpdatePredefinedUsername struct {
	ClazzID  uint32 `json:"_id"`
	Phone    string `json:"phone"`
	Username string `json:"username"`
}

func (m *TLPredefinedUpdatePredefinedUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedUpdatePredefinedUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x12dc0d3a: func() error {
			x.PutClazzID(0x12dc0d3a)

			x.PutString(m.Phone)
			x.PutString(m.Username)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_updatePredefinedUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_updatePredefinedUsername, layer)
	}
}

// Decode <--
func (m *TLPredefinedUpdatePredefinedUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x12dc0d3a: func() (err error) {
			m.Phone, err = d.String()
			m.Username, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedUpdatePredefinedProfile <--
type TLPredefinedUpdatePredefinedProfile struct {
	ClazzID   uint32  `json:"_id"`
	Phone     string  `json:"phone"`
	FirstName *string `json:"first_name"`
	LastName  *string `json:"last_name"`
	About     *string `json:"about"`
}

func (m *TLPredefinedUpdatePredefinedProfile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedUpdatePredefinedProfile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2cdcf945: func() error {
			x.PutClazzID(0x2cdcf945)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FirstName != nil {
					flags |= 1 << 0
				}
				if m.LastName != nil {
					flags |= 1 << 1
				}
				if m.About != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Phone)
			if m.FirstName != nil {
				x.PutString(*m.FirstName)
			}

			if m.LastName != nil {
				x.PutString(*m.LastName)
			}

			if m.About != nil {
				x.PutString(*m.About)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_updatePredefinedProfile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_updatePredefinedProfile, layer)
	}
}

// Decode <--
func (m *TLPredefinedUpdatePredefinedProfile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2cdcf945: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Phone, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.FirstName = new(string)
				*m.FirstName, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.LastName = new(string)
				*m.LastName, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.About = new(string)
				*m.About, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedUpdatePredefinedVerified <--
type TLPredefinedUpdatePredefinedVerified struct {
	ClazzID  uint32 `json:"_id"`
	Phone    string `json:"phone"`
	Verified bool   `json:"verified"`
}

func (m *TLPredefinedUpdatePredefinedVerified) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedUpdatePredefinedVerified) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3f3528a9: func() error {
			x.PutClazzID(0x3f3528a9)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Verified == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Phone)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_updatePredefinedVerified, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_updatePredefinedVerified, layer)
	}
}

// Decode <--
func (m *TLPredefinedUpdatePredefinedVerified) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3f3528a9: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Phone, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.Verified = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedUpdatePredefinedCode <--
type TLPredefinedUpdatePredefinedCode struct {
	ClazzID uint32 `json:"_id"`
	Phone   string `json:"phone"`
	Code    string `json:"code"`
}

func (m *TLPredefinedUpdatePredefinedCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedUpdatePredefinedCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe5361587: func() error {
			x.PutClazzID(0xe5361587)

			x.PutString(m.Phone)
			x.PutString(m.Code)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_updatePredefinedCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_updatePredefinedCode, layer)
	}
}

// Decode <--
func (m *TLPredefinedUpdatePredefinedCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe5361587: func() (err error) {
			m.Phone, err = d.String()
			m.Code, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedGetPredefinedUser <--
type TLPredefinedGetPredefinedUser struct {
	ClazzID uint32 `json:"_id"`
	Phone   string `json:"phone"`
}

func (m *TLPredefinedGetPredefinedUser) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedGetPredefinedUser) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5202a415: func() error {
			x.PutClazzID(0x5202a415)

			x.PutString(m.Phone)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_getPredefinedUser, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_getPredefinedUser, layer)
	}
}

// Decode <--
func (m *TLPredefinedGetPredefinedUser) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5202a415: func() (err error) {
			m.Phone, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedGetPredefinedUsers <--
type TLPredefinedGetPredefinedUsers struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPredefinedGetPredefinedUsers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedGetPredefinedUsers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x29981ac4: func() error {
			x.PutClazzID(0x29981ac4)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_getPredefinedUsers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_getPredefinedUsers, layer)
	}
}

// Decode <--
func (m *TLPredefinedGetPredefinedUsers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x29981ac4: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetMe <--
type TLUsersGetMe struct {
	ClazzID uint32 `json:"_id"`
	Id      int64  `json:"id"`
	Token   string `json:"token"`
}

func (m *TLUsersGetMe) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetMe) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x31345712: func() error {
			x.PutClazzID(0x31345712)

			x.PutInt64(m.Id)
			x.PutString(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getMe, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getMe, layer)
	}
}

// Decode <--
func (m *TLUsersGetMe) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x31345712: func() (err error) {
			m.Id, err = d.Int64()
			m.Token, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateVerified <--
type TLAccountUpdateVerified struct {
	ClazzID  uint32 `json:"_id"`
	Id       int64  `json:"id"`
	Verified bool   `json:"verified"`
}

func (m *TLAccountUpdateVerified) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateVerified) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x15140971: func() error {
			x.PutClazzID(0x15140971)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Verified == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateVerified, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateVerified, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateVerified) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x15140971: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Id, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m.Verified = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthToggleBan <--
type TLAuthToggleBan struct {
	ClazzID    uint32  `json:"_id"`
	Phone      string  `json:"phone"`
	Predefined bool    `json:"predefined"`
	Expires    *int32  `json:"expires"`
	Reason     *string `json:"reason"`
}

func (m *TLAuthToggleBan) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthToggleBan) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe21f7938: func() error {
			x.PutClazzID(0xe21f7938)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Predefined == true {
					flags |= 1 << 0
				}
				if m.Expires != nil {
					flags |= 1 << 1
				}
				if m.Reason != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Phone)
			if m.Expires != nil {
				x.PutInt32(*m.Expires)
			}

			if m.Reason != nil {
				x.PutString(*m.Reason)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_toggleBan, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_toggleBan, layer)
	}
}

// Decode <--
func (m *TLAuthToggleBan) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe21f7938: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Phone, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.Predefined = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Expires = new(int32)
				*m.Expires, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m.Reason = new(string)
				*m.Reason, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBizInvokeBizDataRaw <--
type TLBizInvokeBizDataRaw struct {
	ClazzID uint32          `json:"_id"`
	BizData BizDataRawClazz `json:"biz_data"`
}

func (m *TLBizInvokeBizDataRaw) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBizInvokeBizDataRaw) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5a191146: func() error {
			x.PutClazzID(0x5a191146)

			_ = m.BizData.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_biz_invokeBizDataRaw, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_biz_invokeBizDataRaw, layer)
	}
}

// Decode <--
func (m *TLBizInvokeBizDataRaw) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5a191146: func() (err error) {

			// m1 := &BizDataRaw{}
			// _ = m1.Decode(d)
			// m.BizData = m1
			m.BizData, _ = DecodeBizDataRawClazz(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// Vector api result type
// ----------------------------------------------------------------------------
// VectorResList <--

// VectorSecureValue <--
type VectorSecureValue struct {
	Datas []SecureValueClazz `json:"_datas"`
}

func (m *VectorSecureValue) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorSecureValue) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorSecureValue) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[SecureValueClazz](d)

	return err
}

// VectorWallPaper <--
type VectorWallPaper struct {
	Datas []WallPaperClazz `json:"_datas"`
}

func (m *VectorWallPaper) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorWallPaper) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorWallPaper) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[WallPaperClazz](d)

	return err
}

// VectorUser <--
type VectorUser struct {
	Datas []UserClazz `json:"_datas"`
}

func (m *VectorUser) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorUser) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorUser) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[UserClazz](d)

	return err
}

// VectorRequirementToContact <--
type VectorRequirementToContact struct {
	Datas []RequirementToContactClazz `json:"_datas"`
}

func (m *VectorRequirementToContact) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorRequirementToContact) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorRequirementToContact) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[RequirementToContactClazz](d)

	return err
}

// VectorInt <--
type VectorInt struct {
	Datas []int32 `json:"_datas"`
}

func (m *VectorInt) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorInt) Encode(x *bin.Encoder, layer int32) error {
	iface.EncodeInt32List(x, m.Datas)

	return nil
}

// Decode <--
func (m *VectorInt) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeInt32List(d)

	return err
}

// VectorContactStatus <--
type VectorContactStatus struct {
	Datas []ContactStatusClazz `json:"_datas"`
}

func (m *VectorContactStatus) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorContactStatus) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorContactStatus) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[ContactStatusClazz](d)

	return err
}

// VectorSavedContact <--
type VectorSavedContact struct {
	Datas []SavedContactClazz `json:"_datas"`
}

func (m *VectorSavedContact) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorSavedContact) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorSavedContact) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[SavedContactClazz](d)

	return err
}

// VectorReceivedNotifyMessage <--
type VectorReceivedNotifyMessage struct {
	Datas []ReceivedNotifyMessageClazz `json:"_datas"`
}

func (m *VectorReceivedNotifyMessage) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorReceivedNotifyMessage) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorReceivedNotifyMessage) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[ReceivedNotifyMessageClazz](d)

	return err
}

// VectorLong <--
type VectorLong struct {
	Datas []int64 `json:"_datas"`
}

func (m *VectorLong) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorLong) Encode(x *bin.Encoder, layer int32) error {
	iface.EncodeInt64List(x, m.Datas)

	return nil
}

// Decode <--
func (m *VectorLong) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeInt64List(d)

	return err
}

// VectorStickerSetCovered <--
type VectorStickerSetCovered struct {
	Datas []StickerSetCoveredClazz `json:"_datas"`
}

func (m *VectorStickerSetCovered) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorStickerSetCovered) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorStickerSetCovered) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[StickerSetCoveredClazz](d)

	return err
}

// VectorMessageRange <--
type VectorMessageRange struct {
	Datas []MessageRangeClazz `json:"_datas"`
}

func (m *VectorMessageRange) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorMessageRange) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorMessageRange) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[MessageRangeClazz](d)

	return err
}

// VectorDialogPeer <--
type VectorDialogPeer struct {
	Datas []DialogPeerClazz `json:"_datas"`
}

func (m *VectorDialogPeer) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorDialogPeer) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorDialogPeer) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[DialogPeerClazz](d)

	return err
}

// VectorEmojiLanguage <--
type VectorEmojiLanguage struct {
	Datas []EmojiLanguageClazz `json:"_datas"`
}

func (m *VectorEmojiLanguage) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorEmojiLanguage) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorEmojiLanguage) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[EmojiLanguageClazz](d)

	return err
}

// VectorMessagesSearchCounter <--
type VectorMessagesSearchCounter struct {
	Datas []MessagesSearchCounterClazz `json:"_datas"`
}

func (m *VectorMessagesSearchCounter) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorMessagesSearchCounter) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorMessagesSearchCounter) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[MessagesSearchCounterClazz](d)

	return err
}

// VectorDialogFilterSuggested <--
type VectorDialogFilterSuggested struct {
	Datas []DialogFilterSuggestedClazz `json:"_datas"`
}

func (m *VectorDialogFilterSuggested) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorDialogFilterSuggested) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorDialogFilterSuggested) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[DialogFilterSuggestedClazz](d)

	return err
}

// VectorReadParticipantDate <--
type VectorReadParticipantDate struct {
	Datas []ReadParticipantDateClazz `json:"_datas"`
}

func (m *VectorReadParticipantDate) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorReadParticipantDate) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorReadParticipantDate) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[ReadParticipantDateClazz](d)

	return err
}

// VectorDocument <--
type VectorDocument struct {
	Datas []DocumentClazz `json:"_datas"`
}

func (m *VectorDocument) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorDocument) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorDocument) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[DocumentClazz](d)

	return err
}

// VectorFactCheck <--
type VectorFactCheck struct {
	Datas []FactCheckClazz `json:"_datas"`
}

func (m *VectorFactCheck) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorFactCheck) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorFactCheck) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[FactCheckClazz](d)

	return err
}

// VectorFileHash <--
type VectorFileHash struct {
	Datas []FileHashClazz `json:"_datas"`
}

func (m *VectorFileHash) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorFileHash) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorFileHash) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[FileHashClazz](d)

	return err
}

// VectorBotCommand <--
type VectorBotCommand struct {
	Datas []BotCommandClazz `json:"_datas"`
}

func (m *VectorBotCommand) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorBotCommand) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorBotCommand) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[BotCommandClazz](d)

	return err
}

// VectorBotPreviewMedia <--
type VectorBotPreviewMedia struct {
	Datas []BotPreviewMediaClazz `json:"_datas"`
}

func (m *VectorBotPreviewMedia) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorBotPreviewMedia) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorBotPreviewMedia) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[BotPreviewMediaClazz](d)

	return err
}

// VectorPremiumGiftCodeOption <--
type VectorPremiumGiftCodeOption struct {
	Datas []PremiumGiftCodeOptionClazz `json:"_datas"`
}

func (m *VectorPremiumGiftCodeOption) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorPremiumGiftCodeOption) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorPremiumGiftCodeOption) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[PremiumGiftCodeOptionClazz](d)

	return err
}

// VectorStarsTopupOption <--
type VectorStarsTopupOption struct {
	Datas []StarsTopupOptionClazz `json:"_datas"`
}

func (m *VectorStarsTopupOption) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorStarsTopupOption) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorStarsTopupOption) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[StarsTopupOptionClazz](d)

	return err
}

// VectorStarsGiftOption <--
type VectorStarsGiftOption struct {
	Datas []StarsGiftOptionClazz `json:"_datas"`
}

func (m *VectorStarsGiftOption) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorStarsGiftOption) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorStarsGiftOption) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[StarsGiftOptionClazz](d)

	return err
}

// VectorStarsGiveawayOption <--
type VectorStarsGiveawayOption struct {
	Datas []StarsGiveawayOptionClazz `json:"_datas"`
}

func (m *VectorStarsGiveawayOption) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorStarsGiveawayOption) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorStarsGiveawayOption) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[StarsGiveawayOptionClazz](d)

	return err
}

// VectorLangPackString <--
type VectorLangPackString struct {
	Datas []LangPackStringClazz `json:"_datas"`
}

func (m *VectorLangPackString) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorLangPackString) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorLangPackString) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[LangPackStringClazz](d)

	return err
}

// VectorLangPackLanguage <--
type VectorLangPackLanguage struct {
	Datas []LangPackLanguageClazz `json:"_datas"`
}

func (m *VectorLangPackLanguage) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorLangPackLanguage) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorLangPackLanguage) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[LangPackLanguageClazz](d)

	return err
}

// VectorPeer <--
type VectorPeer struct {
	Datas []PeerClazz `json:"_datas"`
}

func (m *VectorPeer) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorPeer) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorPeer) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[PeerClazz](d)

	return err
}

// VectorPredefinedUser <--
type VectorPredefinedUser struct {
	Datas []PredefinedUserClazz `json:"_datas"`
}

func (m *VectorPredefinedUser) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorPredefinedUser) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorPredefinedUser) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[PredefinedUserClazz](d)

	return err
}

//--------------------------------------------------------------------------------------------
// rpc

type RPCAuthorization interface {
	AuthSendCode(ctx context.Context, in *TLAuthSendCode) (*AuthSentCode, error)
	AuthSignUp(ctx context.Context, in *TLAuthSignUp) (*AuthAuthorization, error)
	AuthSignIn(ctx context.Context, in *TLAuthSignIn) (*AuthAuthorization, error)
	AuthLogOut(ctx context.Context, in *TLAuthLogOut) (*AuthLoggedOut, error)
	AuthResetAuthorizations(ctx context.Context, in *TLAuthResetAuthorizations) (*Bool, error)
	AuthExportAuthorization(ctx context.Context, in *TLAuthExportAuthorization) (*AuthExportedAuthorization, error)
	AuthImportAuthorization(ctx context.Context, in *TLAuthImportAuthorization) (*AuthAuthorization, error)
	AuthBindTempAuthKey(ctx context.Context, in *TLAuthBindTempAuthKey) (*Bool, error)
	AuthImportBotAuthorization(ctx context.Context, in *TLAuthImportBotAuthorization) (*AuthAuthorization, error)
	AuthCheckPassword(ctx context.Context, in *TLAuthCheckPassword) (*AuthAuthorization, error)
	AuthRequestPasswordRecovery(ctx context.Context, in *TLAuthRequestPasswordRecovery) (*AuthPasswordRecovery, error)
	AuthRecoverPassword(ctx context.Context, in *TLAuthRecoverPassword) (*AuthAuthorization, error)
	AuthResendCode(ctx context.Context, in *TLAuthResendCode) (*AuthSentCode, error)
	AuthCancelCode(ctx context.Context, in *TLAuthCancelCode) (*Bool, error)
	AuthDropTempAuthKeys(ctx context.Context, in *TLAuthDropTempAuthKeys) (*Bool, error)
	AuthCheckRecoveryPassword(ctx context.Context, in *TLAuthCheckRecoveryPassword) (*Bool, error)
	AuthImportWebTokenAuthorization(ctx context.Context, in *TLAuthImportWebTokenAuthorization) (*AuthAuthorization, error)
	AuthRequestFirebaseSms(ctx context.Context, in *TLAuthRequestFirebaseSms) (*Bool, error)
	AuthResetLoginEmail(ctx context.Context, in *TLAuthResetLoginEmail) (*AuthSentCode, error)
	AuthReportMissingCode(ctx context.Context, in *TLAuthReportMissingCode) (*Bool, error)
	AuthCheckPaidAuth(ctx context.Context, in *TLAuthCheckPaidAuth) (*AuthSentCode, error)
	AccountSendVerifyEmailCode(ctx context.Context, in *TLAccountSendVerifyEmailCode) (*AccountSentEmailCode, error)
	AccountVerifyEmail(ctx context.Context, in *TLAccountVerifyEmail) (*AccountEmailVerified, error)
	AccountResetPassword(ctx context.Context, in *TLAccountResetPassword) (*AccountResetPasswordResult, error)
	AccountSetAuthorizationTTL(ctx context.Context, in *TLAccountSetAuthorizationTTL) (*Bool, error)
	AccountChangeAuthorizationSettings(ctx context.Context, in *TLAccountChangeAuthorizationSettings) (*Bool, error)
	AccountInvalidateSignInCodes(ctx context.Context, in *TLAccountInvalidateSignInCodes) (*Bool, error)
	AuthToggleBan(ctx context.Context, in *TLAuthToggleBan) (*PredefinedUser, error)
}

type RPCQrCode interface {
	AuthExportLoginToken(ctx context.Context, in *TLAuthExportLoginToken) (*AuthLoginToken, error)
	AuthImportLoginToken(ctx context.Context, in *TLAuthImportLoginToken) (*AuthLoginToken, error)
	AuthAcceptLoginToken(ctx context.Context, in *TLAuthAcceptLoginToken) (*Authorization, error)
}

type RPCNotification interface {
	AccountRegisterDevice(ctx context.Context, in *TLAccountRegisterDevice) (*Bool, error)
	AccountUnregisterDevice(ctx context.Context, in *TLAccountUnregisterDevice) (*Bool, error)
	AccountUpdateNotifySettings(ctx context.Context, in *TLAccountUpdateNotifySettings) (*Bool, error)
	AccountGetNotifySettings(ctx context.Context, in *TLAccountGetNotifySettings) (*PeerNotifySettings, error)
	AccountResetNotifySettings(ctx context.Context, in *TLAccountResetNotifySettings) (*Bool, error)
	AccountUpdateDeviceLocked(ctx context.Context, in *TLAccountUpdateDeviceLocked) (*Bool, error)
	AccountGetNotifyExceptions(ctx context.Context, in *TLAccountGetNotifyExceptions) (*Updates, error)
}

type RPCUserChannelProfiles interface {
	AccountUpdateProfile(ctx context.Context, in *TLAccountUpdateProfile) (*User, error)
	AccountUpdateStatus(ctx context.Context, in *TLAccountUpdateStatus) (*Bool, error)
	AccountUpdateBirthday(ctx context.Context, in *TLAccountUpdateBirthday) (*Bool, error)
	AccountUpdatePersonalChannel(ctx context.Context, in *TLAccountUpdatePersonalChannel) (*Bool, error)
	AccountSetMainProfileTab(ctx context.Context, in *TLAccountSetMainProfileTab) (*Bool, error)
	AccountSaveMusic(ctx context.Context, in *TLAccountSaveMusic) (*Bool, error)
	AccountGetSavedMusicIds(ctx context.Context, in *TLAccountGetSavedMusicIds) (*AccountSavedMusicIds, error)
	UsersGetSavedMusic(ctx context.Context, in *TLUsersGetSavedMusic) (*UsersSavedMusic, error)
	UsersGetSavedMusicByID(ctx context.Context, in *TLUsersGetSavedMusicByID) (*UsersSavedMusic, error)
	UsersSuggestBirthday(ctx context.Context, in *TLUsersSuggestBirthday) (*Updates, error)
	ContactsGetBirthdays(ctx context.Context, in *TLContactsGetBirthdays) (*ContactsContactBirthdays, error)
	PhotosUpdateProfilePhoto(ctx context.Context, in *TLPhotosUpdateProfilePhoto) (*PhotosPhoto, error)
	PhotosUploadProfilePhoto(ctx context.Context, in *TLPhotosUploadProfilePhoto) (*PhotosPhoto, error)
	PhotosDeletePhotos(ctx context.Context, in *TLPhotosDeletePhotos) (*VectorLong, error)
	PhotosGetUserPhotos(ctx context.Context, in *TLPhotosGetUserPhotos) (*PhotosPhotos, error)
	PhotosUploadContactProfilePhoto(ctx context.Context, in *TLPhotosUploadContactProfilePhoto) (*PhotosPhoto, error)
	ChannelsSetMainProfileTab(ctx context.Context, in *TLChannelsSetMainProfileTab) (*Bool, error)
	AccountUpdateVerified(ctx context.Context, in *TLAccountUpdateVerified) (*User, error)
}

type RPCWallpapers interface {
	AccountGetWallPapers(ctx context.Context, in *TLAccountGetWallPapers) (*AccountWallPapers, error)
	AccountGetWallPaper(ctx context.Context, in *TLAccountGetWallPaper) (*WallPaper, error)
	AccountUploadWallPaper(ctx context.Context, in *TLAccountUploadWallPaper) (*WallPaper, error)
	AccountSaveWallPaper(ctx context.Context, in *TLAccountSaveWallPaper) (*Bool, error)
	AccountInstallWallPaper(ctx context.Context, in *TLAccountInstallWallPaper) (*Bool, error)
	AccountResetWallPapers(ctx context.Context, in *TLAccountResetWallPapers) (*Bool, error)
	AccountGetMultiWallPapers(ctx context.Context, in *TLAccountGetMultiWallPapers) (*VectorWallPaper, error)
	MessagesSetChatWallPaper(ctx context.Context, in *TLMessagesSetChatWallPaper) (*Updates, error)
}

type RPCReports interface {
	AccountReportPeer(ctx context.Context, in *TLAccountReportPeer) (*Bool, error)
	AccountReportProfilePhoto(ctx context.Context, in *TLAccountReportProfilePhoto) (*Bool, error)
	MessagesReportSpam(ctx context.Context, in *TLMessagesReportSpam) (*Bool, error)
	MessagesReport(ctx context.Context, in *TLMessagesReport) (*ReportResult, error)
	MessagesReportEncryptedSpam(ctx context.Context, in *TLMessagesReportEncryptedSpam) (*Bool, error)
	ChannelsReportSpam(ctx context.Context, in *TLChannelsReportSpam) (*Bool, error)
}

type RPCUsernames interface {
	AccountCheckUsername(ctx context.Context, in *TLAccountCheckUsername) (*Bool, error)
	AccountUpdateUsername(ctx context.Context, in *TLAccountUpdateUsername) (*User, error)
	ContactsResolveUsername(ctx context.Context, in *TLContactsResolveUsername) (*ContactsResolvedPeer, error)
	ChannelsCheckUsername(ctx context.Context, in *TLChannelsCheckUsername) (*Bool, error)
	ChannelsUpdateUsername(ctx context.Context, in *TLChannelsUpdateUsername) (*Bool, error)
}

type RPCPrivacySettings interface {
	AccountGetPrivacy(ctx context.Context, in *TLAccountGetPrivacy) (*AccountPrivacyRules, error)
	AccountSetPrivacy(ctx context.Context, in *TLAccountSetPrivacy) (*AccountPrivacyRules, error)
	AccountGetGlobalPrivacySettings(ctx context.Context, in *TLAccountGetGlobalPrivacySettings) (*GlobalPrivacySettings, error)
	AccountSetGlobalPrivacySettings(ctx context.Context, in *TLAccountSetGlobalPrivacySettings) (*GlobalPrivacySettings, error)
	UsersGetRequirementsToContact(ctx context.Context, in *TLUsersGetRequirementsToContact) (*VectorRequirementToContact, error)
	MessagesSetDefaultHistoryTTL(ctx context.Context, in *TLMessagesSetDefaultHistoryTTL) (*Bool, error)
	MessagesGetDefaultHistoryTTL(ctx context.Context, in *TLMessagesGetDefaultHistoryTTL) (*DefaultHistoryTTL, error)
}

type RPCAccount interface {
	AccountDeleteAccount(ctx context.Context, in *TLAccountDeleteAccount) (*Bool, error)
	AccountGetAccountTTL(ctx context.Context, in *TLAccountGetAccountTTL) (*AccountDaysTTL, error)
	AccountSetAccountTTL(ctx context.Context, in *TLAccountSetAccountTTL) (*Bool, error)
	AccountSendChangePhoneCode(ctx context.Context, in *TLAccountSendChangePhoneCode) (*AuthSentCode, error)
	AccountChangePhone(ctx context.Context, in *TLAccountChangePhone) (*User, error)
	AccountResetAuthorization(ctx context.Context, in *TLAccountResetAuthorization) (*Bool, error)
	AccountSendConfirmPhoneCode(ctx context.Context, in *TLAccountSendConfirmPhoneCode) (*AuthSentCode, error)
	AccountConfirmPhone(ctx context.Context, in *TLAccountConfirmPhone) (*Bool, error)
}

type RPCPassport interface {
	AccountGetAuthorizations(ctx context.Context, in *TLAccountGetAuthorizations) (*AccountAuthorizations, error)
	AccountGetAllSecureValues(ctx context.Context, in *TLAccountGetAllSecureValues) (*VectorSecureValue, error)
	AccountGetSecureValue(ctx context.Context, in *TLAccountGetSecureValue) (*VectorSecureValue, error)
	AccountSaveSecureValue(ctx context.Context, in *TLAccountSaveSecureValue) (*SecureValue, error)
	AccountDeleteSecureValue(ctx context.Context, in *TLAccountDeleteSecureValue) (*Bool, error)
	AccountGetAuthorizationForm(ctx context.Context, in *TLAccountGetAuthorizationForm) (*AccountAuthorizationForm, error)
	AccountAcceptAuthorization(ctx context.Context, in *TLAccountAcceptAuthorization) (*Bool, error)
	AccountSendVerifyPhoneCode(ctx context.Context, in *TLAccountSendVerifyPhoneCode) (*AuthSentCode, error)
	AccountVerifyPhone(ctx context.Context, in *TLAccountVerifyPhone) (*Bool, error)
	UsersSetSecureValueErrors(ctx context.Context, in *TLUsersSetSecureValueErrors) (*Bool, error)
	HelpGetPassportConfig(ctx context.Context, in *TLHelpGetPassportConfig) (*HelpPassportConfig, error)
}

type RPCTwoFa interface {
	AccountGetPassword(ctx context.Context, in *TLAccountGetPassword) (*AccountPassword, error)
	AccountGetPasswordSettings(ctx context.Context, in *TLAccountGetPasswordSettings) (*AccountPasswordSettings, error)
	AccountUpdatePasswordSettings(ctx context.Context, in *TLAccountUpdatePasswordSettings) (*Bool, error)
	AccountConfirmPasswordEmail(ctx context.Context, in *TLAccountConfirmPasswordEmail) (*Bool, error)
	AccountResendPasswordEmail(ctx context.Context, in *TLAccountResendPasswordEmail) (*Bool, error)
	AccountCancelPasswordEmail(ctx context.Context, in *TLAccountCancelPasswordEmail) (*Bool, error)
	AccountDeclinePasswordReset(ctx context.Context, in *TLAccountDeclinePasswordReset) (*Bool, error)
}

type RPCPayments interface {
	AccountGetTmpPassword(ctx context.Context, in *TLAccountGetTmpPassword) (*AccountTmpPassword, error)
	MessagesSetBotShippingResults(ctx context.Context, in *TLMessagesSetBotShippingResults) (*Bool, error)
	MessagesSetBotPrecheckoutResults(ctx context.Context, in *TLMessagesSetBotPrecheckoutResults) (*Bool, error)
	PaymentsGetPaymentForm(ctx context.Context, in *TLPaymentsGetPaymentForm) (*PaymentsPaymentForm, error)
	PaymentsGetPaymentReceipt(ctx context.Context, in *TLPaymentsGetPaymentReceipt) (*PaymentsPaymentReceipt, error)
	PaymentsValidateRequestedInfo(ctx context.Context, in *TLPaymentsValidateRequestedInfo) (*PaymentsValidatedRequestedInfo, error)
	PaymentsSendPaymentForm(ctx context.Context, in *TLPaymentsSendPaymentForm) (*PaymentsPaymentResult, error)
	PaymentsGetSavedInfo(ctx context.Context, in *TLPaymentsGetSavedInfo) (*PaymentsSavedInfo, error)
	PaymentsClearSavedInfo(ctx context.Context, in *TLPaymentsClearSavedInfo) (*Bool, error)
	PaymentsGetBankCardData(ctx context.Context, in *TLPaymentsGetBankCardData) (*PaymentsBankCardData, error)
	PaymentsExportInvoice(ctx context.Context, in *TLPaymentsExportInvoice) (*PaymentsExportedInvoice, error)
}

type RPCSeamless interface {
	AccountGetWebAuthorizations(ctx context.Context, in *TLAccountGetWebAuthorizations) (*AccountWebAuthorizations, error)
	AccountResetWebAuthorization(ctx context.Context, in *TLAccountResetWebAuthorization) (*Bool, error)
	AccountResetWebAuthorizations(ctx context.Context, in *TLAccountResetWebAuthorizations) (*Bool, error)
	MessagesRequestUrlAuth(ctx context.Context, in *TLMessagesRequestUrlAuth) (*UrlAuthResult, error)
	MessagesAcceptUrlAuth(ctx context.Context, in *TLMessagesAcceptUrlAuth) (*UrlAuthResult, error)
}

type RPCTakeout interface {
	AccountInitTakeoutSession(ctx context.Context, in *TLAccountInitTakeoutSession) (*AccountTakeout, error)
	AccountFinishTakeoutSession(ctx context.Context, in *TLAccountFinishTakeoutSession) (*Bool, error)
	MessagesGetSplitRanges(ctx context.Context, in *TLMessagesGetSplitRanges) (*VectorMessageRange, error)
	ChannelsGetLeftChannels(ctx context.Context, in *TLChannelsGetLeftChannels) (*MessagesChats, error)
}

type RPCContacts interface {
	AccountGetContactSignUpNotification(ctx context.Context, in *TLAccountGetContactSignUpNotification) (*Bool, error)
	AccountSetContactSignUpNotification(ctx context.Context, in *TLAccountSetContactSignUpNotification) (*Bool, error)
	ContactsGetContactIDs(ctx context.Context, in *TLContactsGetContactIDs) (*VectorInt, error)
	ContactsGetStatuses(ctx context.Context, in *TLContactsGetStatuses) (*VectorContactStatus, error)
	ContactsGetContacts(ctx context.Context, in *TLContactsGetContacts) (*ContactsContacts, error)
	ContactsImportContacts(ctx context.Context, in *TLContactsImportContacts) (*ContactsImportedContacts, error)
	ContactsDeleteContacts(ctx context.Context, in *TLContactsDeleteContacts) (*Updates, error)
	ContactsDeleteByPhones(ctx context.Context, in *TLContactsDeleteByPhones) (*Bool, error)
	ContactsBlock(ctx context.Context, in *TLContactsBlock) (*Bool, error)
	ContactsUnblock(ctx context.Context, in *TLContactsUnblock) (*Bool, error)
	ContactsGetBlocked(ctx context.Context, in *TLContactsGetBlocked) (*ContactsBlocked, error)
	ContactsSearch(ctx context.Context, in *TLContactsSearch) (*ContactsFound, error)
	ContactsGetTopPeers(ctx context.Context, in *TLContactsGetTopPeers) (*ContactsTopPeers, error)
	ContactsResetTopPeerRating(ctx context.Context, in *TLContactsResetTopPeerRating) (*Bool, error)
	ContactsResetSaved(ctx context.Context, in *TLContactsResetSaved) (*Bool, error)
	ContactsGetSaved(ctx context.Context, in *TLContactsGetSaved) (*VectorSavedContact, error)
	ContactsToggleTopPeers(ctx context.Context, in *TLContactsToggleTopPeers) (*Bool, error)
	ContactsAddContact(ctx context.Context, in *TLContactsAddContact) (*Updates, error)
	ContactsAcceptContact(ctx context.Context, in *TLContactsAcceptContact) (*Updates, error)
	ContactsGetLocated(ctx context.Context, in *TLContactsGetLocated) (*Updates, error)
	ContactsEditCloseFriends(ctx context.Context, in *TLContactsEditCloseFriends) (*Bool, error)
	ContactsSetBlocked(ctx context.Context, in *TLContactsSetBlocked) (*Bool, error)
	ContactsUpdateContactNote(ctx context.Context, in *TLContactsUpdateContactNote) (*Bool, error)
}

type RPCAutoDownload interface {
	AccountGetAutoDownloadSettings(ctx context.Context, in *TLAccountGetAutoDownloadSettings) (*AccountAutoDownloadSettings, error)
	AccountSaveAutoDownloadSettings(ctx context.Context, in *TLAccountSaveAutoDownloadSettings) (*Bool, error)
}

type RPCThemes interface {
	AccountUploadTheme(ctx context.Context, in *TLAccountUploadTheme) (*Document, error)
	AccountCreateTheme(ctx context.Context, in *TLAccountCreateTheme) (*Theme, error)
	AccountUpdateTheme(ctx context.Context, in *TLAccountUpdateTheme) (*Theme, error)
	AccountSaveTheme(ctx context.Context, in *TLAccountSaveTheme) (*Bool, error)
	AccountInstallTheme(ctx context.Context, in *TLAccountInstallTheme) (*Bool, error)
	AccountGetTheme(ctx context.Context, in *TLAccountGetTheme) (*Theme, error)
	AccountGetThemes(ctx context.Context, in *TLAccountGetThemes) (*AccountThemes, error)
	AccountGetChatThemes(ctx context.Context, in *TLAccountGetChatThemes) (*AccountThemes, error)
	AccountGetUniqueGiftChatThemes(ctx context.Context, in *TLAccountGetUniqueGiftChatThemes) (*AccountChatThemes, error)
	MessagesSetChatTheme(ctx context.Context, in *TLMessagesSetChatTheme) (*Updates, error)
}

type RPCNsfw interface {
	AccountSetContentSettings(ctx context.Context, in *TLAccountSetContentSettings) (*Bool, error)
	AccountGetContentSettings(ctx context.Context, in *TLAccountGetContentSettings) (*AccountContentSettings, error)
}

type RPCRingtone interface {
	AccountGetSavedRingtones(ctx context.Context, in *TLAccountGetSavedRingtones) (*AccountSavedRingtones, error)
	AccountSaveRingtone(ctx context.Context, in *TLAccountSaveRingtone) (*AccountSavedRingtone, error)
	AccountUploadRingtone(ctx context.Context, in *TLAccountUploadRingtone) (*Document, error)
}

type RPCEmojiStatus interface {
	AccountUpdateEmojiStatus(ctx context.Context, in *TLAccountUpdateEmojiStatus) (*Bool, error)
	AccountGetDefaultEmojiStatuses(ctx context.Context, in *TLAccountGetDefaultEmojiStatuses) (*AccountEmojiStatuses, error)
	AccountGetRecentEmojiStatuses(ctx context.Context, in *TLAccountGetRecentEmojiStatuses) (*AccountEmojiStatuses, error)
	AccountClearRecentEmojiStatuses(ctx context.Context, in *TLAccountClearRecentEmojiStatuses) (*Bool, error)
	AccountGetChannelDefaultEmojiStatuses(ctx context.Context, in *TLAccountGetChannelDefaultEmojiStatuses) (*AccountEmojiStatuses, error)
	AccountGetChannelRestrictedStatusEmojis(ctx context.Context, in *TLAccountGetChannelRestrictedStatusEmojis) (*EmojiList, error)
	AccountGetCollectibleEmojiStatuses(ctx context.Context, in *TLAccountGetCollectibleEmojiStatuses) (*AccountEmojiStatuses, error)
	ChannelsUpdateEmojiStatus(ctx context.Context, in *TLChannelsUpdateEmojiStatus) (*Updates, error)
	BotsUpdateUserEmojiStatus(ctx context.Context, in *TLBotsUpdateUserEmojiStatus) (*Bool, error)
	BotsToggleUserEmojiStatusPermission(ctx context.Context, in *TLBotsToggleUserEmojiStatusPermission) (*Bool, error)
}

type RPCFragment interface {
	AccountReorderUsernames(ctx context.Context, in *TLAccountReorderUsernames) (*Bool, error)
	AccountToggleUsername(ctx context.Context, in *TLAccountToggleUsername) (*Bool, error)
	ChannelsReorderUsernames(ctx context.Context, in *TLChannelsReorderUsernames) (*Bool, error)
	ChannelsToggleUsername(ctx context.Context, in *TLChannelsToggleUsername) (*Bool, error)
	ChannelsDeactivateAllUsernames(ctx context.Context, in *TLChannelsDeactivateAllUsernames) (*Bool, error)
	BotsReorderUsernames(ctx context.Context, in *TLBotsReorderUsernames) (*Bool, error)
	BotsToggleUsername(ctx context.Context, in *TLBotsToggleUsername) (*Bool, error)
}

type RPCCustomEmojis interface {
	AccountGetDefaultProfilePhotoEmojis(ctx context.Context, in *TLAccountGetDefaultProfilePhotoEmojis) (*EmojiList, error)
	AccountGetDefaultGroupPhotoEmojis(ctx context.Context, in *TLAccountGetDefaultGroupPhotoEmojis) (*EmojiList, error)
	MessagesGetCustomEmojiDocuments(ctx context.Context, in *TLMessagesGetCustomEmojiDocuments) (*VectorDocument, error)
	MessagesGetEmojiStickers(ctx context.Context, in *TLMessagesGetEmojiStickers) (*MessagesAllStickers, error)
	MessagesGetFeaturedEmojiStickers(ctx context.Context, in *TLMessagesGetFeaturedEmojiStickers) (*MessagesFeaturedStickers, error)
	MessagesSearchCustomEmoji(ctx context.Context, in *TLMessagesSearchCustomEmoji) (*EmojiList, error)
}

type RPCAutosave interface {
	AccountGetAutoSaveSettings(ctx context.Context, in *TLAccountGetAutoSaveSettings) (*AccountAutoSaveSettings, error)
	AccountSaveAutoSaveSettings(ctx context.Context, in *TLAccountSaveAutoSaveSettings) (*Bool, error)
	AccountDeleteAutoSaveExceptions(ctx context.Context, in *TLAccountDeleteAutoSaveExceptions) (*Bool, error)
}

type RPCAccentColors interface {
	AccountUpdateColor(ctx context.Context, in *TLAccountUpdateColor) (*Bool, error)
	AccountGetDefaultBackgroundEmojis(ctx context.Context, in *TLAccountGetDefaultBackgroundEmojis) (*EmojiList, error)
	HelpGetPeerColors(ctx context.Context, in *TLHelpGetPeerColors) (*HelpPeerColors, error)
	HelpGetPeerProfileColors(ctx context.Context, in *TLHelpGetPeerProfileColors) (*HelpPeerColors, error)
	ChannelsUpdateColor(ctx context.Context, in *TLChannelsUpdateColor) (*Updates, error)
}

type RPCBusinessOpeningHours interface {
	AccountUpdateBusinessWorkHours(ctx context.Context, in *TLAccountUpdateBusinessWorkHours) (*Bool, error)
}

type RPCBusinessLocation interface {
	AccountUpdateBusinessLocation(ctx context.Context, in *TLAccountUpdateBusinessLocation) (*Bool, error)
}

type RPCBusinessGreeting interface {
	AccountUpdateBusinessGreetingMessage(ctx context.Context, in *TLAccountUpdateBusinessGreetingMessage) (*Bool, error)
	AccountUpdateBusinessAwayMessage(ctx context.Context, in *TLAccountUpdateBusinessAwayMessage) (*Bool, error)
}

type RPCBusinessConnectedBots interface {
	AccountUpdateConnectedBot(ctx context.Context, in *TLAccountUpdateConnectedBot) (*Updates, error)
	AccountGetConnectedBots(ctx context.Context, in *TLAccountGetConnectedBots) (*AccountConnectedBots, error)
	AccountGetBotBusinessConnection(ctx context.Context, in *TLAccountGetBotBusinessConnection) (*Updates, error)
	AccountToggleConnectedBotPaused(ctx context.Context, in *TLAccountToggleConnectedBotPaused) (*Bool, error)
	AccountDisablePeerConnectedBot(ctx context.Context, in *TLAccountDisablePeerConnectedBot) (*Bool, error)
}

type RPCBusinessIntro interface {
	AccountUpdateBusinessIntro(ctx context.Context, in *TLAccountUpdateBusinessIntro) (*Bool, error)
}

type RPCBusinessChatLinks interface {
	AccountCreateBusinessChatLink(ctx context.Context, in *TLAccountCreateBusinessChatLink) (*BusinessChatLink, error)
	AccountEditBusinessChatLink(ctx context.Context, in *TLAccountEditBusinessChatLink) (*BusinessChatLink, error)
	AccountDeleteBusinessChatLink(ctx context.Context, in *TLAccountDeleteBusinessChatLink) (*Bool, error)
	AccountGetBusinessChatLinks(ctx context.Context, in *TLAccountGetBusinessChatLinks) (*AccountBusinessChatLinks, error)
	AccountResolveBusinessChatLink(ctx context.Context, in *TLAccountResolveBusinessChatLink) (*AccountResolvedBusinessChatLinks, error)
}

type RPCSponsoredMessages interface {
	AccountToggleSponsoredMessages(ctx context.Context, in *TLAccountToggleSponsoredMessages) (*Bool, error)
	ContactsGetSponsoredPeers(ctx context.Context, in *TLContactsGetSponsoredPeers) (*ContactsSponsoredPeers, error)
	MessagesViewSponsoredMessage(ctx context.Context, in *TLMessagesViewSponsoredMessage) (*Bool, error)
	MessagesClickSponsoredMessage(ctx context.Context, in *TLMessagesClickSponsoredMessage) (*Bool, error)
	MessagesReportSponsoredMessage(ctx context.Context, in *TLMessagesReportSponsoredMessage) (*ChannelsSponsoredMessageReportResult, error)
	MessagesGetSponsoredMessages(ctx context.Context, in *TLMessagesGetSponsoredMessages) (*MessagesSponsoredMessages, error)
	ChannelsRestrictSponsoredMessages(ctx context.Context, in *TLChannelsRestrictSponsoredMessages) (*Updates, error)
}

type RPCReactionNotification interface {
	AccountGetReactionsNotifySettings(ctx context.Context, in *TLAccountGetReactionsNotifySettings) (*ReactionsNotifySettings, error)
	AccountSetReactionsNotifySettings(ctx context.Context, in *TLAccountSetReactionsNotifySettings) (*ReactionsNotifySettings, error)
}

type RPCPaidMessage interface {
	AccountGetPaidMessagesRevenue(ctx context.Context, in *TLAccountGetPaidMessagesRevenue) (*AccountPaidMessagesRevenue, error)
	AccountToggleNoPaidMessagesException(ctx context.Context, in *TLAccountToggleNoPaidMessagesException) (*Bool, error)
	ChannelsUpdatePaidMessagesPrice(ctx context.Context, in *TLChannelsUpdatePaidMessagesPrice) (*Updates, error)
}

type RPCUsers interface {
	UsersGetUsers(ctx context.Context, in *TLUsersGetUsers) (*VectorUser, error)
	UsersGetFullUser(ctx context.Context, in *TLUsersGetFullUser) (*UsersUserFull, error)
	ContactsResolvePhone(ctx context.Context, in *TLContactsResolvePhone) (*ContactsResolvedPeer, error)
	UsersGetMe(ctx context.Context, in *TLUsersGetMe) (*User, error)
}

type RPCMessageThreads interface {
	ContactsBlockFromReplies(ctx context.Context, in *TLContactsBlockFromReplies) (*Updates, error)
	MessagesGetReplies(ctx context.Context, in *TLMessagesGetReplies) (*MessagesMessages, error)
	MessagesGetDiscussionMessage(ctx context.Context, in *TLMessagesGetDiscussionMessage) (*MessagesDiscussionMessage, error)
	MessagesReadDiscussion(ctx context.Context, in *TLMessagesReadDiscussion) (*Bool, error)
}

type RPCProfileLinks interface {
	ContactsExportContactToken(ctx context.Context, in *TLContactsExportContactToken) (*ExportedContactToken, error)
	ContactsImportContactToken(ctx context.Context, in *TLContactsImportContactToken) (*User, error)
}

type RPCMessages interface {
	MessagesGetMessages(ctx context.Context, in *TLMessagesGetMessages) (*MessagesMessages, error)
	MessagesGetHistory(ctx context.Context, in *TLMessagesGetHistory) (*MessagesMessages, error)
	MessagesSearch(ctx context.Context, in *TLMessagesSearch) (*MessagesMessages, error)
	MessagesReadHistory(ctx context.Context, in *TLMessagesReadHistory) (*MessagesAffectedMessages, error)
	MessagesDeleteHistory(ctx context.Context, in *TLMessagesDeleteHistory) (*MessagesAffectedHistory, error)
	MessagesDeleteMessages(ctx context.Context, in *TLMessagesDeleteMessages) (*MessagesAffectedMessages, error)
	MessagesReceivedMessages(ctx context.Context, in *TLMessagesReceivedMessages) (*VectorReceivedNotifyMessage, error)
	MessagesSendMessage(ctx context.Context, in *TLMessagesSendMessage) (*Updates, error)
	MessagesSendMedia(ctx context.Context, in *TLMessagesSendMedia) (*Updates, error)
	MessagesForwardMessages(ctx context.Context, in *TLMessagesForwardMessages) (*Updates, error)
	MessagesReadMessageContents(ctx context.Context, in *TLMessagesReadMessageContents) (*MessagesAffectedMessages, error)
	MessagesGetMessagesViews(ctx context.Context, in *TLMessagesGetMessagesViews) (*MessagesMessageViews, error)
	MessagesSearchGlobal(ctx context.Context, in *TLMessagesSearchGlobal) (*MessagesMessages, error)
	MessagesGetMessageEditData(ctx context.Context, in *TLMessagesGetMessageEditData) (*MessagesMessageEditData, error)
	MessagesEditMessage(ctx context.Context, in *TLMessagesEditMessage) (*Updates, error)
	MessagesGetUnreadMentions(ctx context.Context, in *TLMessagesGetUnreadMentions) (*MessagesMessages, error)
	MessagesReadMentions(ctx context.Context, in *TLMessagesReadMentions) (*MessagesAffectedHistory, error)
	MessagesGetRecentLocations(ctx context.Context, in *TLMessagesGetRecentLocations) (*MessagesMessages, error)
	MessagesSendMultiMedia(ctx context.Context, in *TLMessagesSendMultiMedia) (*Updates, error)
	MessagesUpdatePinnedMessage(ctx context.Context, in *TLMessagesUpdatePinnedMessage) (*Updates, error)
	MessagesGetSearchCounters(ctx context.Context, in *TLMessagesGetSearchCounters) (*VectorMessagesSearchCounter, error)
	MessagesUnpinAllMessages(ctx context.Context, in *TLMessagesUnpinAllMessages) (*MessagesAffectedHistory, error)
	MessagesGetSearchResultsCalendar(ctx context.Context, in *TLMessagesGetSearchResultsCalendar) (*MessagesSearchResultsCalendar, error)
	MessagesGetSearchResultsPositions(ctx context.Context, in *TLMessagesGetSearchResultsPositions) (*MessagesSearchResultsPositions, error)
	MessagesToggleNoForwards(ctx context.Context, in *TLMessagesToggleNoForwards) (*Updates, error)
	MessagesSaveDefaultSendAs(ctx context.Context, in *TLMessagesSaveDefaultSendAs) (*Bool, error)
	MessagesSearchSentMedia(ctx context.Context, in *TLMessagesSearchSentMedia) (*MessagesMessages, error)
	MessagesGetOutboxReadDate(ctx context.Context, in *TLMessagesGetOutboxReadDate) (*OutboxReadDate, error)
	ChannelsGetSendAs(ctx context.Context, in *TLChannelsGetSendAs) (*ChannelsSendAsPeers, error)
	ChannelsSearchPosts(ctx context.Context, in *TLChannelsSearchPosts) (*MessagesMessages, error)
	ChannelsCheckSearchPostsFlood(ctx context.Context, in *TLChannelsCheckSearchPostsFlood) (*SearchPostsFlood, error)
}

type RPCDialogs interface {
	MessagesGetDialogs(ctx context.Context, in *TLMessagesGetDialogs) (*MessagesDialogs, error)
	MessagesSetTyping(ctx context.Context, in *TLMessagesSetTyping) (*Bool, error)
	MessagesGetPeerSettings(ctx context.Context, in *TLMessagesGetPeerSettings) (*MessagesPeerSettings, error)
	MessagesGetPeerDialogs(ctx context.Context, in *TLMessagesGetPeerDialogs) (*MessagesPeerDialogs, error)
	MessagesToggleDialogPin(ctx context.Context, in *TLMessagesToggleDialogPin) (*Bool, error)
	MessagesReorderPinnedDialogs(ctx context.Context, in *TLMessagesReorderPinnedDialogs) (*Bool, error)
	MessagesGetPinnedDialogs(ctx context.Context, in *TLMessagesGetPinnedDialogs) (*MessagesPeerDialogs, error)
	MessagesSendScreenshotNotification(ctx context.Context, in *TLMessagesSendScreenshotNotification) (*Updates, error)
	MessagesMarkDialogUnread(ctx context.Context, in *TLMessagesMarkDialogUnread) (*Bool, error)
	MessagesGetDialogUnreadMarks(ctx context.Context, in *TLMessagesGetDialogUnreadMarks) (*VectorDialogPeer, error)
	MessagesGetOnlines(ctx context.Context, in *TLMessagesGetOnlines) (*ChatOnlines, error)
	MessagesHidePeerSettingsBar(ctx context.Context, in *TLMessagesHidePeerSettingsBar) (*Bool, error)
	MessagesSetHistoryTTL(ctx context.Context, in *TLMessagesSetHistoryTTL) (*Updates, error)
}

type RPCChats interface {
	MessagesGetChats(ctx context.Context, in *TLMessagesGetChats) (*MessagesChats, error)
	MessagesGetFullChat(ctx context.Context, in *TLMessagesGetFullChat) (*MessagesChatFull, error)
	MessagesEditChatTitle(ctx context.Context, in *TLMessagesEditChatTitle) (*Updates, error)
	MessagesEditChatPhoto(ctx context.Context, in *TLMessagesEditChatPhoto) (*Updates, error)
	MessagesAddChatUser(ctx context.Context, in *TLMessagesAddChatUser) (*MessagesInvitedUsers, error)
	MessagesDeleteChatUser(ctx context.Context, in *TLMessagesDeleteChatUser) (*Updates, error)
	MessagesCreateChat(ctx context.Context, in *TLMessagesCreateChat) (*MessagesInvitedUsers, error)
	MessagesEditChatAdmin(ctx context.Context, in *TLMessagesEditChatAdmin) (*Bool, error)
	MessagesMigrateChat(ctx context.Context, in *TLMessagesMigrateChat) (*Updates, error)
	MessagesGetCommonChats(ctx context.Context, in *TLMessagesGetCommonChats) (*MessagesChats, error)
	MessagesEditChatAbout(ctx context.Context, in *TLMessagesEditChatAbout) (*Bool, error)
	MessagesEditChatDefaultBannedRights(ctx context.Context, in *TLMessagesEditChatDefaultBannedRights) (*Updates, error)
	MessagesDeleteChat(ctx context.Context, in *TLMessagesDeleteChat) (*Bool, error)
	MessagesGetMessageReadParticipants(ctx context.Context, in *TLMessagesGetMessageReadParticipants) (*VectorReadParticipantDate, error)
	ChannelsConvertToGigagroup(ctx context.Context, in *TLChannelsConvertToGigagroup) (*Updates, error)
	ChannelsSetEmojiStickers(ctx context.Context, in *TLChannelsSetEmojiStickers) (*Bool, error)
}

type RPCSecretChats interface {
	MessagesGetDhConfig(ctx context.Context, in *TLMessagesGetDhConfig) (*MessagesDhConfig, error)
	MessagesRequestEncryption(ctx context.Context, in *TLMessagesRequestEncryption) (*EncryptedChat, error)
	MessagesAcceptEncryption(ctx context.Context, in *TLMessagesAcceptEncryption) (*EncryptedChat, error)
	MessagesDiscardEncryption(ctx context.Context, in *TLMessagesDiscardEncryption) (*Bool, error)
	MessagesSetEncryptedTyping(ctx context.Context, in *TLMessagesSetEncryptedTyping) (*Bool, error)
	MessagesReadEncryptedHistory(ctx context.Context, in *TLMessagesReadEncryptedHistory) (*Bool, error)
	MessagesSendEncrypted(ctx context.Context, in *TLMessagesSendEncrypted) (*MessagesSentEncryptedMessage, error)
	MessagesSendEncryptedFile(ctx context.Context, in *TLMessagesSendEncryptedFile) (*MessagesSentEncryptedMessage, error)
	MessagesSendEncryptedService(ctx context.Context, in *TLMessagesSendEncryptedService) (*MessagesSentEncryptedMessage, error)
	MessagesReceivedQueue(ctx context.Context, in *TLMessagesReceivedQueue) (*VectorLong, error)
}

type RPCStickers interface {
	MessagesGetStickers(ctx context.Context, in *TLMessagesGetStickers) (*MessagesStickers, error)
	MessagesGetAllStickers(ctx context.Context, in *TLMessagesGetAllStickers) (*MessagesAllStickers, error)
	MessagesGetStickerSet(ctx context.Context, in *TLMessagesGetStickerSet) (*MessagesStickerSet, error)
	MessagesInstallStickerSet(ctx context.Context, in *TLMessagesInstallStickerSet) (*MessagesStickerSetInstallResult, error)
	MessagesUninstallStickerSet(ctx context.Context, in *TLMessagesUninstallStickerSet) (*Bool, error)
	MessagesReorderStickerSets(ctx context.Context, in *TLMessagesReorderStickerSets) (*Bool, error)
	MessagesGetFeaturedStickers(ctx context.Context, in *TLMessagesGetFeaturedStickers) (*MessagesFeaturedStickers, error)
	MessagesReadFeaturedStickers(ctx context.Context, in *TLMessagesReadFeaturedStickers) (*Bool, error)
	MessagesGetRecentStickers(ctx context.Context, in *TLMessagesGetRecentStickers) (*MessagesRecentStickers, error)
	MessagesSaveRecentSticker(ctx context.Context, in *TLMessagesSaveRecentSticker) (*Bool, error)
	MessagesClearRecentStickers(ctx context.Context, in *TLMessagesClearRecentStickers) (*Bool, error)
	MessagesGetArchivedStickers(ctx context.Context, in *TLMessagesGetArchivedStickers) (*MessagesArchivedStickers, error)
	MessagesGetMaskStickers(ctx context.Context, in *TLMessagesGetMaskStickers) (*MessagesAllStickers, error)
	MessagesGetAttachedStickers(ctx context.Context, in *TLMessagesGetAttachedStickers) (*VectorStickerSetCovered, error)
	MessagesGetFavedStickers(ctx context.Context, in *TLMessagesGetFavedStickers) (*MessagesFavedStickers, error)
	MessagesFaveSticker(ctx context.Context, in *TLMessagesFaveSticker) (*Bool, error)
	MessagesSearchStickerSets(ctx context.Context, in *TLMessagesSearchStickerSets) (*MessagesFoundStickerSets, error)
	MessagesToggleStickerSets(ctx context.Context, in *TLMessagesToggleStickerSets) (*Bool, error)
	MessagesGetOldFeaturedStickers(ctx context.Context, in *TLMessagesGetOldFeaturedStickers) (*MessagesFeaturedStickers, error)
	MessagesSearchEmojiStickerSets(ctx context.Context, in *TLMessagesSearchEmojiStickerSets) (*MessagesFoundStickerSets, error)
	MessagesGetMyStickers(ctx context.Context, in *TLMessagesGetMyStickers) (*MessagesMyStickers, error)
	MessagesSearchStickers(ctx context.Context, in *TLMessagesSearchStickers) (*MessagesFoundStickers, error)
	StickersCreateStickerSet(ctx context.Context, in *TLStickersCreateStickerSet) (*MessagesStickerSet, error)
	StickersRemoveStickerFromSet(ctx context.Context, in *TLStickersRemoveStickerFromSet) (*MessagesStickerSet, error)
	StickersChangeStickerPosition(ctx context.Context, in *TLStickersChangeStickerPosition) (*MessagesStickerSet, error)
	StickersAddStickerToSet(ctx context.Context, in *TLStickersAddStickerToSet) (*MessagesStickerSet, error)
	StickersSetStickerSetThumb(ctx context.Context, in *TLStickersSetStickerSetThumb) (*MessagesStickerSet, error)
	StickersCheckShortName(ctx context.Context, in *TLStickersCheckShortName) (*Bool, error)
	StickersSuggestShortName(ctx context.Context, in *TLStickersSuggestShortName) (*StickersSuggestedShortName, error)
	StickersChangeSticker(ctx context.Context, in *TLStickersChangeSticker) (*MessagesStickerSet, error)
	StickersRenameStickerSet(ctx context.Context, in *TLStickersRenameStickerSet) (*MessagesStickerSet, error)
	StickersDeleteStickerSet(ctx context.Context, in *TLStickersDeleteStickerSet) (*Bool, error)
	StickersReplaceSticker(ctx context.Context, in *TLStickersReplaceSticker) (*MessagesStickerSet, error)
}

type RPCWebPage interface {
	MessagesGetWebPagePreview(ctx context.Context, in *TLMessagesGetWebPagePreview) (*MessagesWebPagePreview, error)
	MessagesGetWebPage(ctx context.Context, in *TLMessagesGetWebPage) (*MessagesWebPage, error)
}

type RPCChatInvites interface {
	MessagesExportChatInvite(ctx context.Context, in *TLMessagesExportChatInvite) (*ExportedChatInvite, error)
	MessagesCheckChatInvite(ctx context.Context, in *TLMessagesCheckChatInvite) (*ChatInvite, error)
	MessagesImportChatInvite(ctx context.Context, in *TLMessagesImportChatInvite) (*Updates, error)
	MessagesGetExportedChatInvites(ctx context.Context, in *TLMessagesGetExportedChatInvites) (*MessagesExportedChatInvites, error)
	MessagesGetExportedChatInvite(ctx context.Context, in *TLMessagesGetExportedChatInvite) (*MessagesExportedChatInvite, error)
	MessagesEditExportedChatInvite(ctx context.Context, in *TLMessagesEditExportedChatInvite) (*MessagesExportedChatInvite, error)
	MessagesDeleteRevokedExportedChatInvites(ctx context.Context, in *TLMessagesDeleteRevokedExportedChatInvites) (*Bool, error)
	MessagesDeleteExportedChatInvite(ctx context.Context, in *TLMessagesDeleteExportedChatInvite) (*Bool, error)
	MessagesGetAdminsWithInvites(ctx context.Context, in *TLMessagesGetAdminsWithInvites) (*MessagesChatAdminsWithInvites, error)
	MessagesGetChatInviteImporters(ctx context.Context, in *TLMessagesGetChatInviteImporters) (*MessagesChatInviteImporters, error)
	MessagesHideChatJoinRequest(ctx context.Context, in *TLMessagesHideChatJoinRequest) (*Updates, error)
	MessagesHideAllChatJoinRequests(ctx context.Context, in *TLMessagesHideAllChatJoinRequests) (*Updates, error)
	ChannelsToggleJoinToSend(ctx context.Context, in *TLChannelsToggleJoinToSend) (*Updates, error)
	ChannelsToggleJoinRequest(ctx context.Context, in *TLChannelsToggleJoinRequest) (*Updates, error)
}

type RPCDeepLinks interface {
	MessagesStartBot(ctx context.Context, in *TLMessagesStartBot) (*Updates, error)
	HelpGetRecentMeUrls(ctx context.Context, in *TLHelpGetRecentMeUrls) (*HelpRecentMeUrls, error)
	HelpGetDeepLinkInfo(ctx context.Context, in *TLHelpGetDeepLinkInfo) (*HelpDeepLinkInfo, error)
}

type RPCFiles interface {
	MessagesGetDocumentByHash(ctx context.Context, in *TLMessagesGetDocumentByHash) (*Document, error)
	MessagesUploadMedia(ctx context.Context, in *TLMessagesUploadMedia) (*MessageMedia, error)
	MessagesUploadEncryptedFile(ctx context.Context, in *TLMessagesUploadEncryptedFile) (*EncryptedFile, error)
	UploadSaveFilePart(ctx context.Context, in *TLUploadSaveFilePart) (*Bool, error)
	UploadGetFile(ctx context.Context, in *TLUploadGetFile) (*UploadFile, error)
	UploadSaveBigFilePart(ctx context.Context, in *TLUploadSaveBigFilePart) (*Bool, error)
	UploadGetWebFile(ctx context.Context, in *TLUploadGetWebFile) (*UploadWebFile, error)
	UploadGetCdnFile(ctx context.Context, in *TLUploadGetCdnFile) (*UploadCdnFile, error)
	UploadReuploadCdnFile(ctx context.Context, in *TLUploadReuploadCdnFile) (*VectorFileHash, error)
	UploadGetCdnFileHashes(ctx context.Context, in *TLUploadGetCdnFileHashes) (*VectorFileHash, error)
	UploadGetFileHashes(ctx context.Context, in *TLUploadGetFileHashes) (*VectorFileHash, error)
	HelpGetCdnConfig(ctx context.Context, in *TLHelpGetCdnConfig) (*CdnConfig, error)
}

type RPCGifs interface {
	MessagesGetSavedGifs(ctx context.Context, in *TLMessagesGetSavedGifs) (*MessagesSavedGifs, error)
	MessagesSaveGif(ctx context.Context, in *TLMessagesSaveGif) (*Bool, error)
}

type RPCInlineBot interface {
	MessagesGetInlineBotResults(ctx context.Context, in *TLMessagesGetInlineBotResults) (*MessagesBotResults, error)
	MessagesSetInlineBotResults(ctx context.Context, in *TLMessagesSetInlineBotResults) (*Bool, error)
	MessagesSendInlineBotResult(ctx context.Context, in *TLMessagesSendInlineBotResult) (*Updates, error)
	MessagesEditInlineBotMessage(ctx context.Context, in *TLMessagesEditInlineBotMessage) (*Bool, error)
	MessagesGetBotCallbackAnswer(ctx context.Context, in *TLMessagesGetBotCallbackAnswer) (*MessagesBotCallbackAnswer, error)
	MessagesSetBotCallbackAnswer(ctx context.Context, in *TLMessagesSetBotCallbackAnswer) (*Bool, error)
	MessagesSendBotRequestedPeer(ctx context.Context, in *TLMessagesSendBotRequestedPeer) (*Updates, error)
}

type RPCDrafts interface {
	MessagesSaveDraft(ctx context.Context, in *TLMessagesSaveDraft) (*Bool, error)
	MessagesGetAllDrafts(ctx context.Context, in *TLMessagesGetAllDrafts) (*Updates, error)
	MessagesClearAllDrafts(ctx context.Context, in *TLMessagesClearAllDrafts) (*Bool, error)
}

type RPCGames interface {
	MessagesSetGameScore(ctx context.Context, in *TLMessagesSetGameScore) (*Updates, error)
	MessagesSetInlineGameScore(ctx context.Context, in *TLMessagesSetInlineGameScore) (*Bool, error)
	MessagesGetGameHighScores(ctx context.Context, in *TLMessagesGetGameHighScores) (*MessagesHighScores, error)
	MessagesGetInlineGameHighScores(ctx context.Context, in *TLMessagesGetInlineGameHighScores) (*MessagesHighScores, error)
}

type RPCPolls interface {
	MessagesSendVote(ctx context.Context, in *TLMessagesSendVote) (*Updates, error)
	MessagesGetPollResults(ctx context.Context, in *TLMessagesGetPollResults) (*Updates, error)
	MessagesGetPollVotes(ctx context.Context, in *TLMessagesGetPollVotes) (*MessagesVotesList, error)
}

type RPCEmoji interface {
	MessagesGetEmojiKeywords(ctx context.Context, in *TLMessagesGetEmojiKeywords) (*EmojiKeywordsDifference, error)
	MessagesGetEmojiKeywordsDifference(ctx context.Context, in *TLMessagesGetEmojiKeywordsDifference) (*EmojiKeywordsDifference, error)
	MessagesGetEmojiKeywordsLanguages(ctx context.Context, in *TLMessagesGetEmojiKeywordsLanguages) (*VectorEmojiLanguage, error)
	MessagesGetEmojiURL(ctx context.Context, in *TLMessagesGetEmojiURL) (*EmojiURL, error)
}

type RPCScheduledMessages interface {
	MessagesGetScheduledHistory(ctx context.Context, in *TLMessagesGetScheduledHistory) (*MessagesMessages, error)
	MessagesGetScheduledMessages(ctx context.Context, in *TLMessagesGetScheduledMessages) (*MessagesMessages, error)
	MessagesSendScheduledMessages(ctx context.Context, in *TLMessagesSendScheduledMessages) (*Updates, error)
	MessagesDeleteScheduledMessages(ctx context.Context, in *TLMessagesDeleteScheduledMessages) (*Updates, error)
}

type RPCFolders interface {
	MessagesGetDialogFilters(ctx context.Context, in *TLMessagesGetDialogFilters) (*MessagesDialogFilters, error)
	MessagesGetSuggestedDialogFilters(ctx context.Context, in *TLMessagesGetSuggestedDialogFilters) (*VectorDialogFilterSuggested, error)
	MessagesUpdateDialogFilter(ctx context.Context, in *TLMessagesUpdateDialogFilter) (*Bool, error)
	MessagesUpdateDialogFiltersOrder(ctx context.Context, in *TLMessagesUpdateDialogFiltersOrder) (*Bool, error)
	FoldersEditPeerFolders(ctx context.Context, in *TLFoldersEditPeerFolders) (*Updates, error)
	ChatlistsExportChatlistInvite(ctx context.Context, in *TLChatlistsExportChatlistInvite) (*ChatlistsExportedChatlistInvite, error)
	ChatlistsDeleteExportedInvite(ctx context.Context, in *TLChatlistsDeleteExportedInvite) (*Bool, error)
	ChatlistsEditExportedInvite(ctx context.Context, in *TLChatlistsEditExportedInvite) (*ExportedChatlistInvite, error)
	ChatlistsGetExportedInvites(ctx context.Context, in *TLChatlistsGetExportedInvites) (*ChatlistsExportedInvites, error)
	ChatlistsCheckChatlistInvite(ctx context.Context, in *TLChatlistsCheckChatlistInvite) (*ChatlistsChatlistInvite, error)
	ChatlistsJoinChatlistInvite(ctx context.Context, in *TLChatlistsJoinChatlistInvite) (*Updates, error)
	ChatlistsGetChatlistUpdates(ctx context.Context, in *TLChatlistsGetChatlistUpdates) (*ChatlistsChatlistUpdates, error)
	ChatlistsJoinChatlistUpdates(ctx context.Context, in *TLChatlistsJoinChatlistUpdates) (*Updates, error)
	ChatlistsHideChatlistUpdates(ctx context.Context, in *TLChatlistsHideChatlistUpdates) (*Bool, error)
	ChatlistsGetLeaveChatlistSuggestions(ctx context.Context, in *TLChatlistsGetLeaveChatlistSuggestions) (*VectorPeer, error)
	ChatlistsLeaveChatlist(ctx context.Context, in *TLChatlistsLeaveChatlist) (*Updates, error)
}

type RPCVoipCalls interface {
	MessagesDeletePhoneCallHistory(ctx context.Context, in *TLMessagesDeletePhoneCallHistory) (*MessagesAffectedFoundMessages, error)
	PhoneGetCallConfig(ctx context.Context, in *TLPhoneGetCallConfig) (*DataJSON, error)
	PhoneRequestCall(ctx context.Context, in *TLPhoneRequestCall) (*PhonePhoneCall, error)
	PhoneAcceptCall(ctx context.Context, in *TLPhoneAcceptCall) (*PhonePhoneCall, error)
	PhoneConfirmCall(ctx context.Context, in *TLPhoneConfirmCall) (*PhonePhoneCall, error)
	PhoneReceivedCall(ctx context.Context, in *TLPhoneReceivedCall) (*Bool, error)
	PhoneDiscardCall(ctx context.Context, in *TLPhoneDiscardCall) (*Updates, error)
	PhoneSetCallRating(ctx context.Context, in *TLPhoneSetCallRating) (*Updates, error)
	PhoneSaveCallDebug(ctx context.Context, in *TLPhoneSaveCallDebug) (*Bool, error)
	PhoneSendSignalingData(ctx context.Context, in *TLPhoneSendSignalingData) (*Bool, error)
	PhoneSaveCallLog(ctx context.Context, in *TLPhoneSaveCallLog) (*Bool, error)
}

type RPCImportedChats interface {
	MessagesCheckHistoryImport(ctx context.Context, in *TLMessagesCheckHistoryImport) (*MessagesHistoryImportParsed, error)
	MessagesInitHistoryImport(ctx context.Context, in *TLMessagesInitHistoryImport) (*MessagesHistoryImport, error)
	MessagesUploadImportedMedia(ctx context.Context, in *TLMessagesUploadImportedMedia) (*MessageMedia, error)
	MessagesStartHistoryImport(ctx context.Context, in *TLMessagesStartHistoryImport) (*Bool, error)
	MessagesCheckHistoryImportPeer(ctx context.Context, in *TLMessagesCheckHistoryImportPeer) (*MessagesCheckedHistoryImportPeer, error)
}

type RPCReactions interface {
	MessagesSendReaction(ctx context.Context, in *TLMessagesSendReaction) (*Updates, error)
	MessagesGetMessagesReactions(ctx context.Context, in *TLMessagesGetMessagesReactions) (*Updates, error)
	MessagesGetMessageReactionsList(ctx context.Context, in *TLMessagesGetMessageReactionsList) (*MessagesMessageReactionsList, error)
	MessagesSetChatAvailableReactions(ctx context.Context, in *TLMessagesSetChatAvailableReactions) (*Updates, error)
	MessagesGetAvailableReactions(ctx context.Context, in *TLMessagesGetAvailableReactions) (*MessagesAvailableReactions, error)
	MessagesSetDefaultReaction(ctx context.Context, in *TLMessagesSetDefaultReaction) (*Bool, error)
	MessagesGetUnreadReactions(ctx context.Context, in *TLMessagesGetUnreadReactions) (*MessagesMessages, error)
	MessagesReadReactions(ctx context.Context, in *TLMessagesReadReactions) (*MessagesAffectedHistory, error)
	MessagesReportReaction(ctx context.Context, in *TLMessagesReportReaction) (*Bool, error)
	MessagesGetTopReactions(ctx context.Context, in *TLMessagesGetTopReactions) (*MessagesReactions, error)
	MessagesGetRecentReactions(ctx context.Context, in *TLMessagesGetRecentReactions) (*MessagesReactions, error)
	MessagesClearRecentReactions(ctx context.Context, in *TLMessagesClearRecentReactions) (*Bool, error)
	MessagesSendPaidReaction(ctx context.Context, in *TLMessagesSendPaidReaction) (*Updates, error)
	MessagesTogglePaidReactionPrivacy(ctx context.Context, in *TLMessagesTogglePaidReactionPrivacy) (*Bool, error)
	MessagesGetPaidReactionPrivacy(ctx context.Context, in *TLMessagesGetPaidReactionPrivacy) (*Updates, error)
}

type RPCTranslation interface {
	MessagesTranslateText(ctx context.Context, in *TLMessagesTranslateText) (*MessagesTranslatedText, error)
	MessagesTogglePeerTranslations(ctx context.Context, in *TLMessagesTogglePeerTranslations) (*Bool, error)
	ChannelsToggleAutotranslation(ctx context.Context, in *TLChannelsToggleAutotranslation) (*Updates, error)
}

type RPCBotMenu interface {
	MessagesGetAttachMenuBots(ctx context.Context, in *TLMessagesGetAttachMenuBots) (*AttachMenuBots, error)
	MessagesGetAttachMenuBot(ctx context.Context, in *TLMessagesGetAttachMenuBot) (*AttachMenuBotsBot, error)
	MessagesToggleBotInAttachMenu(ctx context.Context, in *TLMessagesToggleBotInAttachMenu) (*Bool, error)
}

type RPCMiniBotApps interface {
	MessagesRequestWebView(ctx context.Context, in *TLMessagesRequestWebView) (*WebViewResult, error)
	MessagesProlongWebView(ctx context.Context, in *TLMessagesProlongWebView) (*Bool, error)
	MessagesRequestSimpleWebView(ctx context.Context, in *TLMessagesRequestSimpleWebView) (*WebViewResult, error)
	MessagesSendWebViewResultMessage(ctx context.Context, in *TLMessagesSendWebViewResultMessage) (*WebViewMessageSent, error)
	MessagesSendWebViewData(ctx context.Context, in *TLMessagesSendWebViewData) (*Updates, error)
	MessagesGetBotApp(ctx context.Context, in *TLMessagesGetBotApp) (*MessagesBotApp, error)
	MessagesRequestAppWebView(ctx context.Context, in *TLMessagesRequestAppWebView) (*WebViewResult, error)
	BotsCanSendMessage(ctx context.Context, in *TLBotsCanSendMessage) (*Bool, error)
	BotsAllowSendMessage(ctx context.Context, in *TLBotsAllowSendMessage) (*Updates, error)
	BotsInvokeWebViewCustomMethod(ctx context.Context, in *TLBotsInvokeWebViewCustomMethod) (*DataJSON, error)
	BotsCheckDownloadFileParams(ctx context.Context, in *TLBotsCheckDownloadFileParams) (*Bool, error)
}

type RPCTranscription interface {
	MessagesTranscribeAudio(ctx context.Context, in *TLMessagesTranscribeAudio) (*MessagesTranscribedAudio, error)
	MessagesRateTranscribedAudio(ctx context.Context, in *TLMessagesRateTranscribedAudio) (*Bool, error)
}

type RPCPaidMedia interface {
	MessagesGetExtendedMedia(ctx context.Context, in *TLMessagesGetExtendedMedia) (*Updates, error)
}

type RPCEmojiCategories interface {
	MessagesGetEmojiGroups(ctx context.Context, in *TLMessagesGetEmojiGroups) (*MessagesEmojiGroups, error)
	MessagesGetEmojiStatusGroups(ctx context.Context, in *TLMessagesGetEmojiStatusGroups) (*MessagesEmojiGroups, error)
	MessagesGetEmojiProfilePhotoGroups(ctx context.Context, in *TLMessagesGetEmojiProfilePhotoGroups) (*MessagesEmojiGroups, error)
	MessagesGetEmojiStickerGroups(ctx context.Context, in *TLMessagesGetEmojiStickerGroups) (*MessagesEmojiGroups, error)
}

type RPCSavedMessageDialogs interface {
	MessagesGetSavedDialogs(ctx context.Context, in *TLMessagesGetSavedDialogs) (*MessagesSavedDialogs, error)
	MessagesGetSavedHistory(ctx context.Context, in *TLMessagesGetSavedHistory) (*MessagesMessages, error)
	MessagesDeleteSavedHistory(ctx context.Context, in *TLMessagesDeleteSavedHistory) (*MessagesAffectedHistory, error)
	MessagesGetPinnedSavedDialogs(ctx context.Context, in *TLMessagesGetPinnedSavedDialogs) (*MessagesSavedDialogs, error)
	MessagesToggleSavedDialogPin(ctx context.Context, in *TLMessagesToggleSavedDialogPin) (*Bool, error)
	MessagesReorderPinnedSavedDialogs(ctx context.Context, in *TLMessagesReorderPinnedSavedDialogs) (*Bool, error)
	MessagesGetSavedDialogsByID(ctx context.Context, in *TLMessagesGetSavedDialogsByID) (*MessagesSavedDialogs, error)
	MessagesReadSavedHistory(ctx context.Context, in *TLMessagesReadSavedHistory) (*Bool, error)
	ChannelsGetMessageAuthor(ctx context.Context, in *TLChannelsGetMessageAuthor) (*User, error)
}

type RPCSavedMessageTags interface {
	MessagesGetSavedReactionTags(ctx context.Context, in *TLMessagesGetSavedReactionTags) (*MessagesSavedReactionTags, error)
	MessagesUpdateSavedReactionTag(ctx context.Context, in *TLMessagesUpdateSavedReactionTag) (*Bool, error)
	MessagesGetDefaultTagReactions(ctx context.Context, in *TLMessagesGetDefaultTagReactions) (*MessagesReactions, error)
}

type RPCBusinessQuickReply interface {
	MessagesGetQuickReplies(ctx context.Context, in *TLMessagesGetQuickReplies) (*MessagesQuickReplies, error)
	MessagesReorderQuickReplies(ctx context.Context, in *TLMessagesReorderQuickReplies) (*Bool, error)
	MessagesCheckQuickReplyShortcut(ctx context.Context, in *TLMessagesCheckQuickReplyShortcut) (*Bool, error)
	MessagesEditQuickReplyShortcut(ctx context.Context, in *TLMessagesEditQuickReplyShortcut) (*Bool, error)
	MessagesDeleteQuickReplyShortcut(ctx context.Context, in *TLMessagesDeleteQuickReplyShortcut) (*Bool, error)
	MessagesGetQuickReplyMessages(ctx context.Context, in *TLMessagesGetQuickReplyMessages) (*MessagesMessages, error)
	MessagesSendQuickReplyMessages(ctx context.Context, in *TLMessagesSendQuickReplyMessages) (*Updates, error)
	MessagesDeleteQuickReplyMessages(ctx context.Context, in *TLMessagesDeleteQuickReplyMessages) (*Updates, error)
}

type RPCFolderTags interface {
	MessagesToggleDialogFilterTags(ctx context.Context, in *TLMessagesToggleDialogFilterTags) (*Bool, error)
}

type RPCMessageEffects interface {
	MessagesGetAvailableEffects(ctx context.Context, in *TLMessagesGetAvailableEffects) (*MessagesAvailableEffects, error)
}

type RPCFactChecks interface {
	MessagesEditFactCheck(ctx context.Context, in *TLMessagesEditFactCheck) (*Updates, error)
	MessagesDeleteFactCheck(ctx context.Context, in *TLMessagesDeleteFactCheck) (*Updates, error)
	MessagesGetFactCheck(ctx context.Context, in *TLMessagesGetFactCheck) (*VectorFactCheck, error)
}

type RPCMainMiniBotApps interface {
	MessagesRequestMainWebView(ctx context.Context, in *TLMessagesRequestMainWebView) (*WebViewResult, error)
	BotsGetPopularAppBots(ctx context.Context, in *TLBotsGetPopularAppBots) (*BotsPopularAppBots, error)
	BotsAddPreviewMedia(ctx context.Context, in *TLBotsAddPreviewMedia) (*BotPreviewMedia, error)
	BotsEditPreviewMedia(ctx context.Context, in *TLBotsEditPreviewMedia) (*BotPreviewMedia, error)
	BotsDeletePreviewMedia(ctx context.Context, in *TLBotsDeletePreviewMedia) (*Bool, error)
	BotsReorderPreviewMedias(ctx context.Context, in *TLBotsReorderPreviewMedias) (*Bool, error)
	BotsGetPreviewInfo(ctx context.Context, in *TLBotsGetPreviewInfo) (*BotsPreviewInfo, error)
	BotsGetPreviewMedias(ctx context.Context, in *TLBotsGetPreviewMedias) (*VectorBotPreviewMedia, error)
}

type RPCPreparedInlineMessages interface {
	MessagesSavePreparedInlineMessage(ctx context.Context, in *TLMessagesSavePreparedInlineMessage) (*MessagesBotPreparedInlineMessage, error)
	MessagesGetPreparedInlineMessage(ctx context.Context, in *TLMessagesGetPreparedInlineMessage) (*MessagesPreparedInlineMessage, error)
}

type RPCGatewayVerificationMessages interface {
	MessagesReportMessagesDelivery(ctx context.Context, in *TLMessagesReportMessagesDelivery) (*Bool, error)
}

type RPCTodoLists interface {
	MessagesToggleTodoCompleted(ctx context.Context, in *TLMessagesToggleTodoCompleted) (*Updates, error)
	MessagesAppendTodoList(ctx context.Context, in *TLMessagesAppendTodoList) (*Updates, error)
}

type RPCSuggestedPosts interface {
	MessagesToggleSuggestedPostApproval(ctx context.Context, in *TLMessagesToggleSuggestedPostApproval) (*Updates, error)
}

type RPCForums interface {
	MessagesGetForumTopics(ctx context.Context, in *TLMessagesGetForumTopics) (*MessagesForumTopics, error)
	MessagesGetForumTopicsByID(ctx context.Context, in *TLMessagesGetForumTopicsByID) (*MessagesForumTopics, error)
	MessagesEditForumTopic(ctx context.Context, in *TLMessagesEditForumTopic) (*Updates, error)
	MessagesUpdatePinnedForumTopic(ctx context.Context, in *TLMessagesUpdatePinnedForumTopic) (*Updates, error)
	MessagesReorderPinnedForumTopics(ctx context.Context, in *TLMessagesReorderPinnedForumTopics) (*Updates, error)
	MessagesCreateForumTopic(ctx context.Context, in *TLMessagesCreateForumTopic) (*Updates, error)
	MessagesDeleteTopicHistory(ctx context.Context, in *TLMessagesDeleteTopicHistory) (*MessagesAffectedHistory, error)
	ChannelsToggleForum(ctx context.Context, in *TLChannelsToggleForum) (*Updates, error)
	ChannelsToggleViewForumAsMessages(ctx context.Context, in *TLChannelsToggleViewForumAsMessages) (*Updates, error)
}

type RPCUpdates interface {
	UpdatesGetState(ctx context.Context, in *TLUpdatesGetState) (*UpdatesState, error)
	UpdatesGetDifference(ctx context.Context, in *TLUpdatesGetDifference) (*UpdatesDifference, error)
	UpdatesGetChannelDifference(ctx context.Context, in *TLUpdatesGetChannelDifference) (*UpdatesChannelDifference, error)
}

type RPCConfiguration interface {
	HelpGetConfig(ctx context.Context, in *TLHelpGetConfig) (*Config, error)
	HelpGetNearestDc(ctx context.Context, in *TLHelpGetNearestDc) (*NearestDc, error)
	HelpGetAppUpdate(ctx context.Context, in *TLHelpGetAppUpdate) (*HelpAppUpdate, error)
	HelpGetInviteText(ctx context.Context, in *TLHelpGetInviteText) (*HelpInviteText, error)
	HelpGetSupport(ctx context.Context, in *TLHelpGetSupport) (*HelpSupport, error)
	HelpGetAppConfig(ctx context.Context, in *TLHelpGetAppConfig) (*HelpAppConfig, error)
	HelpGetSupportName(ctx context.Context, in *TLHelpGetSupportName) (*HelpSupportName, error)
	HelpDismissSuggestion(ctx context.Context, in *TLHelpDismissSuggestion) (*Bool, error)
	HelpGetCountriesList(ctx context.Context, in *TLHelpGetCountriesList) (*HelpCountriesList, error)
}

type RPCInternalBot interface {
	HelpSetBotUpdatesStatus(ctx context.Context, in *TLHelpSetBotUpdatesStatus) (*Bool, error)
	BotsSendCustomRequest(ctx context.Context, in *TLBotsSendCustomRequest) (*DataJSON, error)
	BotsAnswerWebhookJSONQuery(ctx context.Context, in *TLBotsAnswerWebhookJSONQuery) (*Bool, error)
}

type RPCTos interface {
	HelpGetTermsOfServiceUpdate(ctx context.Context, in *TLHelpGetTermsOfServiceUpdate) (*HelpTermsOfServiceUpdate, error)
	HelpAcceptTermsOfService(ctx context.Context, in *TLHelpAcceptTermsOfService) (*Bool, error)
}

type RPCMiscellaneous interface {
	HelpSaveAppLog(ctx context.Context, in *TLHelpSaveAppLog) (*Bool, error)
	HelpTest(ctx context.Context, in *TLHelpTest) (*Bool, error)
}

type RPCTsf interface {
	HelpGetUserInfo(ctx context.Context, in *TLHelpGetUserInfo) (*HelpUserInfo, error)
	HelpEditUserInfo(ctx context.Context, in *TLHelpEditUserInfo) (*HelpUserInfo, error)
}

type RPCPromoData interface {
	HelpGetPromoData(ctx context.Context, in *TLHelpGetPromoData) (*HelpPromoData, error)
	HelpHidePromoData(ctx context.Context, in *TLHelpHidePromoData) (*Bool, error)
}

type RPCPremium interface {
	HelpGetPremiumPromo(ctx context.Context, in *TLHelpGetPremiumPromo) (*HelpPremiumPromo, error)
	PaymentsAssignAppStoreTransaction(ctx context.Context, in *TLPaymentsAssignAppStoreTransaction) (*Updates, error)
	PaymentsAssignPlayMarketTransaction(ctx context.Context, in *TLPaymentsAssignPlayMarketTransaction) (*Updates, error)
	PaymentsCanPurchaseStore(ctx context.Context, in *TLPaymentsCanPurchaseStore) (*Bool, error)
}

type RPCTimezones interface {
	HelpGetTimezonesList(ctx context.Context, in *TLHelpGetTimezonesList) (*HelpTimezonesList, error)
}

type RPCChannels interface {
	ChannelsReadHistory(ctx context.Context, in *TLChannelsReadHistory) (*Bool, error)
	ChannelsDeleteMessages(ctx context.Context, in *TLChannelsDeleteMessages) (*MessagesAffectedMessages, error)
	ChannelsGetMessages(ctx context.Context, in *TLChannelsGetMessages) (*MessagesMessages, error)
	ChannelsGetParticipants(ctx context.Context, in *TLChannelsGetParticipants) (*ChannelsChannelParticipants, error)
	ChannelsGetParticipant(ctx context.Context, in *TLChannelsGetParticipant) (*ChannelsChannelParticipant, error)
	ChannelsGetChannels(ctx context.Context, in *TLChannelsGetChannels) (*MessagesChats, error)
	ChannelsGetFullChannel(ctx context.Context, in *TLChannelsGetFullChannel) (*MessagesChatFull, error)
	ChannelsCreateChannel(ctx context.Context, in *TLChannelsCreateChannel) (*Updates, error)
	ChannelsEditAdmin(ctx context.Context, in *TLChannelsEditAdmin) (*Updates, error)
	ChannelsEditTitle(ctx context.Context, in *TLChannelsEditTitle) (*Updates, error)
	ChannelsEditPhoto(ctx context.Context, in *TLChannelsEditPhoto) (*Updates, error)
	ChannelsJoinChannel(ctx context.Context, in *TLChannelsJoinChannel) (*Updates, error)
	ChannelsLeaveChannel(ctx context.Context, in *TLChannelsLeaveChannel) (*Updates, error)
	ChannelsInviteToChannel(ctx context.Context, in *TLChannelsInviteToChannel) (*MessagesInvitedUsers, error)
	ChannelsDeleteChannel(ctx context.Context, in *TLChannelsDeleteChannel) (*Updates, error)
	ChannelsExportMessageLink(ctx context.Context, in *TLChannelsExportMessageLink) (*ExportedMessageLink, error)
	ChannelsToggleSignatures(ctx context.Context, in *TLChannelsToggleSignatures) (*Updates, error)
	ChannelsGetAdminedPublicChannels(ctx context.Context, in *TLChannelsGetAdminedPublicChannels) (*MessagesChats, error)
	ChannelsEditBanned(ctx context.Context, in *TLChannelsEditBanned) (*Updates, error)
	ChannelsGetAdminLog(ctx context.Context, in *TLChannelsGetAdminLog) (*ChannelsAdminLogResults, error)
	ChannelsSetStickers(ctx context.Context, in *TLChannelsSetStickers) (*Bool, error)
	ChannelsReadMessageContents(ctx context.Context, in *TLChannelsReadMessageContents) (*Bool, error)
	ChannelsDeleteHistory(ctx context.Context, in *TLChannelsDeleteHistory) (*Updates, error)
	ChannelsTogglePreHistoryHidden(ctx context.Context, in *TLChannelsTogglePreHistoryHidden) (*Updates, error)
	ChannelsGetGroupsForDiscussion(ctx context.Context, in *TLChannelsGetGroupsForDiscussion) (*MessagesChats, error)
	ChannelsSetDiscussionGroup(ctx context.Context, in *TLChannelsSetDiscussionGroup) (*Bool, error)
	ChannelsEditCreator(ctx context.Context, in *TLChannelsEditCreator) (*Updates, error)
	ChannelsEditLocation(ctx context.Context, in *TLChannelsEditLocation) (*Bool, error)
	ChannelsToggleSlowMode(ctx context.Context, in *TLChannelsToggleSlowMode) (*Updates, error)
	ChannelsGetInactiveChannels(ctx context.Context, in *TLChannelsGetInactiveChannels) (*MessagesInactiveChats, error)
	ChannelsDeleteParticipantHistory(ctx context.Context, in *TLChannelsDeleteParticipantHistory) (*MessagesAffectedHistory, error)
	ChannelsToggleParticipantsHidden(ctx context.Context, in *TLChannelsToggleParticipantsHidden) (*Updates, error)
}

type RPCAntiSpam interface {
	ChannelsToggleAntiSpam(ctx context.Context, in *TLChannelsToggleAntiSpam) (*Updates, error)
	ChannelsReportAntiSpamFalsePositive(ctx context.Context, in *TLChannelsReportAntiSpamFalsePositive) (*Bool, error)
}

type RPCChannelRecommendations interface {
	ChannelsGetChannelRecommendations(ctx context.Context, in *TLChannelsGetChannelRecommendations) (*MessagesChats, error)
}

type RPCBoosts interface {
	ChannelsSetBoostsToUnblockRestrictions(ctx context.Context, in *TLChannelsSetBoostsToUnblockRestrictions) (*Updates, error)
	PremiumGetBoostsList(ctx context.Context, in *TLPremiumGetBoostsList) (*PremiumBoostsList, error)
	PremiumGetMyBoosts(ctx context.Context, in *TLPremiumGetMyBoosts) (*PremiumMyBoosts, error)
	PremiumApplyBoost(ctx context.Context, in *TLPremiumApplyBoost) (*PremiumMyBoosts, error)
	PremiumGetBoostsStatus(ctx context.Context, in *TLPremiumGetBoostsStatus) (*PremiumBoostsStatus, error)
	PremiumGetUserBoosts(ctx context.Context, in *TLPremiumGetUserBoosts) (*PremiumBoostsList, error)
}

type RPCBots interface {
	BotsSetBotCommands(ctx context.Context, in *TLBotsSetBotCommands) (*Bool, error)
	BotsResetBotCommands(ctx context.Context, in *TLBotsResetBotCommands) (*Bool, error)
	BotsGetBotCommands(ctx context.Context, in *TLBotsGetBotCommands) (*VectorBotCommand, error)
	BotsSetBotInfo(ctx context.Context, in *TLBotsSetBotInfo) (*Bool, error)
	BotsGetBotInfo(ctx context.Context, in *TLBotsGetBotInfo) (*BotsBotInfo, error)
	BotsGetAdminedBots(ctx context.Context, in *TLBotsGetAdminedBots) (*VectorUser, error)
}

type RPCBotMenuButton interface {
	BotsSetBotMenuButton(ctx context.Context, in *TLBotsSetBotMenuButton) (*Bool, error)
	BotsGetBotMenuButton(ctx context.Context, in *TLBotsGetBotMenuButton) (*BotMenuButton, error)
}

type RPCBotAdminRight interface {
	BotsSetBotBroadcastDefaultAdminRights(ctx context.Context, in *TLBotsSetBotBroadcastDefaultAdminRights) (*Bool, error)
	BotsSetBotGroupDefaultAdminRights(ctx context.Context, in *TLBotsSetBotGroupDefaultAdminRights) (*Bool, error)
}

type RPCAffiliatePrograms interface {
	BotsUpdateStarRefProgram(ctx context.Context, in *TLBotsUpdateStarRefProgram) (*StarRefProgram, error)
	PaymentsGetConnectedStarRefBots(ctx context.Context, in *TLPaymentsGetConnectedStarRefBots) (*PaymentsConnectedStarRefBots, error)
	PaymentsGetConnectedStarRefBot(ctx context.Context, in *TLPaymentsGetConnectedStarRefBot) (*PaymentsConnectedStarRefBots, error)
	PaymentsGetSuggestedStarRefBots(ctx context.Context, in *TLPaymentsGetSuggestedStarRefBots) (*PaymentsSuggestedStarRefBots, error)
	PaymentsConnectStarRefBot(ctx context.Context, in *TLPaymentsConnectStarRefBot) (*PaymentsConnectedStarRefBots, error)
	PaymentsEditConnectedStarRefBot(ctx context.Context, in *TLPaymentsEditConnectedStarRefBot) (*PaymentsConnectedStarRefBots, error)
}

type RPCBotVerificationIcons interface {
	BotsSetCustomVerification(ctx context.Context, in *TLBotsSetCustomVerification) (*Bool, error)
	BotsGetBotRecommendations(ctx context.Context, in *TLBotsGetBotRecommendations) (*UsersUsers, error)
}

type RPCGiveaways interface {
	PaymentsGetPremiumGiftCodeOptions(ctx context.Context, in *TLPaymentsGetPremiumGiftCodeOptions) (*VectorPremiumGiftCodeOption, error)
	PaymentsGetGiveawayInfo(ctx context.Context, in *TLPaymentsGetGiveawayInfo) (*PaymentsGiveawayInfo, error)
	PaymentsLaunchPrepaidGiveaway(ctx context.Context, in *TLPaymentsLaunchPrepaidGiveaway) (*Updates, error)
	PaymentsGetStarsGiveawayOptions(ctx context.Context, in *TLPaymentsGetStarsGiveawayOptions) (*VectorStarsGiveawayOption, error)
}

type RPCGiftCodes interface {
	PaymentsCheckGiftCode(ctx context.Context, in *TLPaymentsCheckGiftCode) (*PaymentsCheckedGiftCode, error)
	PaymentsApplyGiftCode(ctx context.Context, in *TLPaymentsApplyGiftCode) (*Updates, error)
}

type RPCStars interface {
	PaymentsGetStarsTopupOptions(ctx context.Context, in *TLPaymentsGetStarsTopupOptions) (*VectorStarsTopupOption, error)
	PaymentsGetStarsStatus(ctx context.Context, in *TLPaymentsGetStarsStatus) (*PaymentsStarsStatus, error)
	PaymentsGetStarsTransactions(ctx context.Context, in *TLPaymentsGetStarsTransactions) (*PaymentsStarsStatus, error)
	PaymentsSendStarsForm(ctx context.Context, in *TLPaymentsSendStarsForm) (*PaymentsPaymentResult, error)
	PaymentsRefundStarsCharge(ctx context.Context, in *TLPaymentsRefundStarsCharge) (*Updates, error)
	PaymentsGetStarsRevenueStats(ctx context.Context, in *TLPaymentsGetStarsRevenueStats) (*PaymentsStarsRevenueStats, error)
	PaymentsGetStarsRevenueWithdrawalUrl(ctx context.Context, in *TLPaymentsGetStarsRevenueWithdrawalUrl) (*PaymentsStarsRevenueWithdrawalUrl, error)
	PaymentsGetStarsRevenueAdsAccountUrl(ctx context.Context, in *TLPaymentsGetStarsRevenueAdsAccountUrl) (*PaymentsStarsRevenueAdsAccountUrl, error)
	PaymentsGetStarsTransactionsByID(ctx context.Context, in *TLPaymentsGetStarsTransactionsByID) (*PaymentsStarsStatus, error)
	PaymentsGetStarsGiftOptions(ctx context.Context, in *TLPaymentsGetStarsGiftOptions) (*VectorStarsGiftOption, error)
}

type RPCStarSubscriptions interface {
	PaymentsGetStarsSubscriptions(ctx context.Context, in *TLPaymentsGetStarsSubscriptions) (*PaymentsStarsStatus, error)
	PaymentsChangeStarsSubscription(ctx context.Context, in *TLPaymentsChangeStarsSubscription) (*Bool, error)
	PaymentsFulfillStarsSubscription(ctx context.Context, in *TLPaymentsFulfillStarsSubscription) (*Bool, error)
	PaymentsBotCancelStarsSubscription(ctx context.Context, in *TLPaymentsBotCancelStarsSubscription) (*Bool, error)
}

type RPCGifts interface {
	PaymentsGetStarGifts(ctx context.Context, in *TLPaymentsGetStarGifts) (*PaymentsStarGifts, error)
	PaymentsSaveStarGift(ctx context.Context, in *TLPaymentsSaveStarGift) (*Bool, error)
	PaymentsConvertStarGift(ctx context.Context, in *TLPaymentsConvertStarGift) (*Bool, error)
	PaymentsGetStarGiftUpgradePreview(ctx context.Context, in *TLPaymentsGetStarGiftUpgradePreview) (*PaymentsStarGiftUpgradePreview, error)
	PaymentsUpgradeStarGift(ctx context.Context, in *TLPaymentsUpgradeStarGift) (*Updates, error)
	PaymentsTransferStarGift(ctx context.Context, in *TLPaymentsTransferStarGift) (*Updates, error)
	PaymentsGetUniqueStarGift(ctx context.Context, in *TLPaymentsGetUniqueStarGift) (*PaymentsUniqueStarGift, error)
	PaymentsGetSavedStarGifts(ctx context.Context, in *TLPaymentsGetSavedStarGifts) (*PaymentsSavedStarGifts, error)
	PaymentsGetSavedStarGift(ctx context.Context, in *TLPaymentsGetSavedStarGift) (*PaymentsSavedStarGifts, error)
	PaymentsGetStarGiftWithdrawalUrl(ctx context.Context, in *TLPaymentsGetStarGiftWithdrawalUrl) (*PaymentsStarGiftWithdrawalUrl, error)
	PaymentsToggleChatStarGiftNotifications(ctx context.Context, in *TLPaymentsToggleChatStarGiftNotifications) (*Bool, error)
	PaymentsToggleStarGiftsPinnedToTop(ctx context.Context, in *TLPaymentsToggleStarGiftsPinnedToTop) (*Bool, error)
	PaymentsGetResaleStarGifts(ctx context.Context, in *TLPaymentsGetResaleStarGifts) (*PaymentsResaleStarGifts, error)
	PaymentsUpdateStarGiftPrice(ctx context.Context, in *TLPaymentsUpdateStarGiftPrice) (*Updates, error)
	PaymentsGetUniqueStarGiftValueInfo(ctx context.Context, in *TLPaymentsGetUniqueStarGiftValueInfo) (*PaymentsUniqueStarGiftValueInfo, error)
	PaymentsCheckCanSendGift(ctx context.Context, in *TLPaymentsCheckCanSendGift) (*PaymentsCheckCanSendGiftResult, error)
}

type RPCGiftCollections interface {
	PaymentsCreateStarGiftCollection(ctx context.Context, in *TLPaymentsCreateStarGiftCollection) (*StarGiftCollection, error)
	PaymentsUpdateStarGiftCollection(ctx context.Context, in *TLPaymentsUpdateStarGiftCollection) (*StarGiftCollection, error)
	PaymentsReorderStarGiftCollections(ctx context.Context, in *TLPaymentsReorderStarGiftCollections) (*Bool, error)
	PaymentsDeleteStarGiftCollection(ctx context.Context, in *TLPaymentsDeleteStarGiftCollection) (*Bool, error)
	PaymentsGetStarGiftCollections(ctx context.Context, in *TLPaymentsGetStarGiftCollections) (*PaymentsStarGiftCollections, error)
}

type RPCGroupCalls interface {
	PhoneCreateGroupCall(ctx context.Context, in *TLPhoneCreateGroupCall) (*Updates, error)
	PhoneJoinGroupCall(ctx context.Context, in *TLPhoneJoinGroupCall) (*Updates, error)
	PhoneLeaveGroupCall(ctx context.Context, in *TLPhoneLeaveGroupCall) (*Updates, error)
	PhoneInviteToGroupCall(ctx context.Context, in *TLPhoneInviteToGroupCall) (*Updates, error)
	PhoneDiscardGroupCall(ctx context.Context, in *TLPhoneDiscardGroupCall) (*Updates, error)
	PhoneToggleGroupCallSettings(ctx context.Context, in *TLPhoneToggleGroupCallSettings) (*Updates, error)
	PhoneGetGroupCall(ctx context.Context, in *TLPhoneGetGroupCall) (*PhoneGroupCall, error)
	PhoneGetGroupParticipants(ctx context.Context, in *TLPhoneGetGroupParticipants) (*PhoneGroupParticipants, error)
	PhoneCheckGroupCall(ctx context.Context, in *TLPhoneCheckGroupCall) (*VectorInt, error)
	PhoneToggleGroupCallRecord(ctx context.Context, in *TLPhoneToggleGroupCallRecord) (*Updates, error)
	PhoneEditGroupCallParticipant(ctx context.Context, in *TLPhoneEditGroupCallParticipant) (*Updates, error)
	PhoneEditGroupCallTitle(ctx context.Context, in *TLPhoneEditGroupCallTitle) (*Updates, error)
	PhoneGetGroupCallJoinAs(ctx context.Context, in *TLPhoneGetGroupCallJoinAs) (*PhoneJoinAsPeers, error)
	PhoneExportGroupCallInvite(ctx context.Context, in *TLPhoneExportGroupCallInvite) (*PhoneExportedGroupCallInvite, error)
	PhoneToggleGroupCallStartSubscription(ctx context.Context, in *TLPhoneToggleGroupCallStartSubscription) (*Updates, error)
	PhoneStartScheduledGroupCall(ctx context.Context, in *TLPhoneStartScheduledGroupCall) (*Updates, error)
	PhoneSaveDefaultGroupCallJoinAs(ctx context.Context, in *TLPhoneSaveDefaultGroupCallJoinAs) (*Bool, error)
	PhoneJoinGroupCallPresentation(ctx context.Context, in *TLPhoneJoinGroupCallPresentation) (*Updates, error)
	PhoneLeaveGroupCallPresentation(ctx context.Context, in *TLPhoneLeaveGroupCallPresentation) (*Updates, error)
	PhoneGetGroupCallStreamChannels(ctx context.Context, in *TLPhoneGetGroupCallStreamChannels) (*PhoneGroupCallStreamChannels, error)
	PhoneGetGroupCallStreamRtmpUrl(ctx context.Context, in *TLPhoneGetGroupCallStreamRtmpUrl) (*PhoneGroupCallStreamRtmpUrl, error)
	PhoneSendGroupCallMessage(ctx context.Context, in *TLPhoneSendGroupCallMessage) (*Bool, error)
}

type RPCE2EConferenceCalls interface {
	PhoneCreateConferenceCall(ctx context.Context, in *TLPhoneCreateConferenceCall) (*Updates, error)
	PhoneDeleteConferenceCallParticipants(ctx context.Context, in *TLPhoneDeleteConferenceCallParticipants) (*Updates, error)
	PhoneSendConferenceCallBroadcast(ctx context.Context, in *TLPhoneSendConferenceCallBroadcast) (*Updates, error)
	PhoneInviteConferenceCallParticipant(ctx context.Context, in *TLPhoneInviteConferenceCallParticipant) (*Updates, error)
	PhoneDeclineConferenceCallInvite(ctx context.Context, in *TLPhoneDeclineConferenceCallInvite) (*Updates, error)
	PhoneGetGroupCallChainBlocks(ctx context.Context, in *TLPhoneGetGroupCallChainBlocks) (*Updates, error)
	PhoneSendGroupCallEncryptedMessage(ctx context.Context, in *TLPhoneSendGroupCallEncryptedMessage) (*Bool, error)
}

type RPCLangpack interface {
	LangpackGetLangPack(ctx context.Context, in *TLLangpackGetLangPack) (*LangPackDifference, error)
	LangpackGetStrings(ctx context.Context, in *TLLangpackGetStrings) (*VectorLangPackString, error)
	LangpackGetDifference(ctx context.Context, in *TLLangpackGetDifference) (*LangPackDifference, error)
	LangpackGetLanguages(ctx context.Context, in *TLLangpackGetLanguages) (*VectorLangPackLanguage, error)
	LangpackGetLanguage(ctx context.Context, in *TLLangpackGetLanguage) (*LangPackLanguage, error)
}

type RPCStatistics interface {
	StatsGetBroadcastStats(ctx context.Context, in *TLStatsGetBroadcastStats) (*StatsBroadcastStats, error)
	StatsLoadAsyncGraph(ctx context.Context, in *TLStatsLoadAsyncGraph) (*StatsGraph, error)
	StatsGetMegagroupStats(ctx context.Context, in *TLStatsGetMegagroupStats) (*StatsMegagroupStats, error)
	StatsGetMessagePublicForwards(ctx context.Context, in *TLStatsGetMessagePublicForwards) (*StatsPublicForwards, error)
	StatsGetMessageStats(ctx context.Context, in *TLStatsGetMessageStats) (*StatsMessageStats, error)
	StatsGetStoryStats(ctx context.Context, in *TLStatsGetStoryStats) (*StatsStoryStats, error)
	StatsGetStoryPublicForwards(ctx context.Context, in *TLStatsGetStoryPublicForwards) (*StatsPublicForwards, error)
}

type RPCStories interface {
	StoriesCanSendStory(ctx context.Context, in *TLStoriesCanSendStory) (*StoriesCanSendStoryCount, error)
	StoriesSendStory(ctx context.Context, in *TLStoriesSendStory) (*Updates, error)
	StoriesEditStory(ctx context.Context, in *TLStoriesEditStory) (*Updates, error)
	StoriesDeleteStories(ctx context.Context, in *TLStoriesDeleteStories) (*VectorInt, error)
	StoriesTogglePinned(ctx context.Context, in *TLStoriesTogglePinned) (*VectorInt, error)
	StoriesGetAllStories(ctx context.Context, in *TLStoriesGetAllStories) (*StoriesAllStories, error)
	StoriesGetPinnedStories(ctx context.Context, in *TLStoriesGetPinnedStories) (*StoriesStories, error)
	StoriesGetStoriesArchive(ctx context.Context, in *TLStoriesGetStoriesArchive) (*StoriesStories, error)
	StoriesGetStoriesByID(ctx context.Context, in *TLStoriesGetStoriesByID) (*StoriesStories, error)
	StoriesToggleAllStoriesHidden(ctx context.Context, in *TLStoriesToggleAllStoriesHidden) (*Bool, error)
	StoriesReadStories(ctx context.Context, in *TLStoriesReadStories) (*VectorInt, error)
	StoriesIncrementStoryViews(ctx context.Context, in *TLStoriesIncrementStoryViews) (*Bool, error)
	StoriesGetStoryViewsList(ctx context.Context, in *TLStoriesGetStoryViewsList) (*StoriesStoryViewsList, error)
	StoriesGetStoriesViews(ctx context.Context, in *TLStoriesGetStoriesViews) (*StoriesStoryViews, error)
	StoriesExportStoryLink(ctx context.Context, in *TLStoriesExportStoryLink) (*ExportedStoryLink, error)
	StoriesReport(ctx context.Context, in *TLStoriesReport) (*ReportResult, error)
	StoriesActivateStealthMode(ctx context.Context, in *TLStoriesActivateStealthMode) (*Updates, error)
	StoriesSendReaction(ctx context.Context, in *TLStoriesSendReaction) (*Updates, error)
	StoriesGetPeerStories(ctx context.Context, in *TLStoriesGetPeerStories) (*StoriesPeerStories, error)
	StoriesGetAllReadPeerStories(ctx context.Context, in *TLStoriesGetAllReadPeerStories) (*Updates, error)
	StoriesGetPeerMaxIDs(ctx context.Context, in *TLStoriesGetPeerMaxIDs) (*VectorInt, error)
	StoriesGetChatsToSend(ctx context.Context, in *TLStoriesGetChatsToSend) (*MessagesChats, error)
	StoriesTogglePeerStoriesHidden(ctx context.Context, in *TLStoriesTogglePeerStoriesHidden) (*Bool, error)
	StoriesGetStoryReactionsList(ctx context.Context, in *TLStoriesGetStoryReactionsList) (*StoriesStoryReactionsList, error)
	StoriesTogglePinnedToTop(ctx context.Context, in *TLStoriesTogglePinnedToTop) (*Bool, error)
	StoriesSearchPosts(ctx context.Context, in *TLStoriesSearchPosts) (*StoriesFoundStories, error)
	StoriesCreateAlbum(ctx context.Context, in *TLStoriesCreateAlbum) (*StoryAlbum, error)
	StoriesUpdateAlbum(ctx context.Context, in *TLStoriesUpdateAlbum) (*StoryAlbum, error)
	StoriesReorderAlbums(ctx context.Context, in *TLStoriesReorderAlbums) (*Bool, error)
	StoriesDeleteAlbum(ctx context.Context, in *TLStoriesDeleteAlbum) (*Bool, error)
	StoriesGetAlbums(ctx context.Context, in *TLStoriesGetAlbums) (*StoriesAlbums, error)
	StoriesGetAlbumStories(ctx context.Context, in *TLStoriesGetAlbumStories) (*StoriesStories, error)
}

type RPCSmsjobs interface {
	SmsjobsIsEligibleToJoin(ctx context.Context, in *TLSmsjobsIsEligibleToJoin) (*SmsjobsEligibilityToJoin, error)
	SmsjobsJoin(ctx context.Context, in *TLSmsjobsJoin) (*Bool, error)
	SmsjobsLeave(ctx context.Context, in *TLSmsjobsLeave) (*Bool, error)
	SmsjobsUpdateSettings(ctx context.Context, in *TLSmsjobsUpdateSettings) (*Bool, error)
	SmsjobsGetStatus(ctx context.Context, in *TLSmsjobsGetStatus) (*SmsjobsStatus, error)
	SmsjobsGetSmsJob(ctx context.Context, in *TLSmsjobsGetSmsJob) (*SmsJob, error)
	SmsjobsFinishJob(ctx context.Context, in *TLSmsjobsFinishJob) (*Bool, error)
}

type RPCFragmentCollectibles interface {
	FragmentGetCollectibleInfo(ctx context.Context, in *TLFragmentGetCollectibleInfo) (*FragmentCollectibleInfo, error)
}

type RPCtest interface {
	TestParseInputAppEvent(ctx context.Context, in *TLTestParseInputAppEvent) (*InputAppEvent, error)
}

type RPCPredefined interface {
	PredefinedCreatePredefinedUser(ctx context.Context, in *TLPredefinedCreatePredefinedUser) (*PredefinedUser, error)
	PredefinedUpdatePredefinedUsername(ctx context.Context, in *TLPredefinedUpdatePredefinedUsername) (*PredefinedUser, error)
	PredefinedUpdatePredefinedProfile(ctx context.Context, in *TLPredefinedUpdatePredefinedProfile) (*PredefinedUser, error)
	PredefinedUpdatePredefinedVerified(ctx context.Context, in *TLPredefinedUpdatePredefinedVerified) (*PredefinedUser, error)
	PredefinedUpdatePredefinedCode(ctx context.Context, in *TLPredefinedUpdatePredefinedCode) (*PredefinedUser, error)
	PredefinedGetPredefinedUser(ctx context.Context, in *TLPredefinedGetPredefinedUser) (*PredefinedUser, error)
	PredefinedGetPredefinedUsers(ctx context.Context, in *TLPredefinedGetPredefinedUsers) (*VectorPredefinedUser, error)
}

type RPCbiz interface {
	BizInvokeBizDataRaw(ctx context.Context, in *TLBizInvokeBizDataRaw) (*BizDataRaw, error)
}
