/*
 * WARNING! All changes made in this file will be lost!
 * Created from 'scheme.tl' by 'mtprotoc'
 *
 * Copyright (c) 2025-present,  Teamgram Authors.
 *  All rights reserved.
 *
 * Author: Benqi (wubenqi@gmail.com)
 */

package tg

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/teamgram/proto/v2/bin"
	"github.com/teamgram/proto/v2/iface"
)

var (
	_ iface.TLObject
	_ context.Context
)

// TLInvokeAfterMsg <--
type TLInvokeAfterMsg struct {
	ClazzID uint32 `json:"_id"`
	MsgId   int64  `json:"msg_id"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeAfterMsg) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeAfterMsg) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcb9f372d: func() error {
			x.PutClazzID(0xcb9f372d)

			x.PutInt64(m.MsgId)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeAfterMsg, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeAfterMsg, layer)
	}
}

// Decode <--
func (m *TLInvokeAfterMsg) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcb9f372d: func() (err error) {
			m.MsgId, err = d.Int64()
			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeAfterMsgs <--
type TLInvokeAfterMsgs struct {
	ClazzID uint32  `json:"_id"`
	MsgIds  []int64 `json:"msg_ids"`
	Query   []byte  `json:"query"`
}

func (m *TLInvokeAfterMsgs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeAfterMsgs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3dc4b4f0: func() error {
			x.PutClazzID(0x3dc4b4f0)

			iface.EncodeInt64List(x, m.MsgIds)

			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeAfterMsgs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeAfterMsgs, layer)
	}
}

// Decode <--
func (m *TLInvokeAfterMsgs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3dc4b4f0: func() (err error) {

			m.MsgIds, err = iface.DecodeInt64List(d)

			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInitConnection <--
type TLInitConnection struct {
	ClazzID        uint32            `json:"_id"`
	ApiId          int32             `json:"api_id"`
	DeviceModel    string            `json:"device_model"`
	SystemVersion  string            `json:"system_version"`
	AppVersion     string            `json:"app_version"`
	SystemLangCode string            `json:"system_lang_code"`
	LangPack       string            `json:"lang_pack"`
	LangCode       string            `json:"lang_code"`
	Proxy          *InputClientProxy `json:"proxy"`
	Params         *JSONValue        `json:"params"`
	Query          []byte            `json:"query"`
}

func (m *TLInitConnection) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInitConnection) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc1cd5ea9: func() error {
			x.PutClazzID(0xc1cd5ea9)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Proxy != nil {
					flags |= 1 << 0
				}
				if m.Params != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.ApiId)
			x.PutString(m.DeviceModel)
			x.PutString(m.SystemVersion)
			x.PutString(m.AppVersion)
			x.PutString(m.SystemLangCode)
			x.PutString(m.LangPack)
			x.PutString(m.LangCode)
			if m.Proxy != nil {
				_ = m.Proxy.Encode(x, layer)
			}

			if m.Params != nil {
				_ = m.Params.Encode(x, layer)
			}

			// template Debug by @benqi

			return nil
		},
		0x785188b8: func() error {
			x.PutClazzID(0x785188b8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Proxy != nil {
					flags |= 1 << 0
				}
				if m.Params != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.ApiId)
			x.PutString(m.DeviceModel)
			x.PutString(m.SystemVersion)
			x.PutString(m.AppVersion)
			x.PutString(m.SystemLangCode)
			x.PutString(m.LangPack)
			x.PutString(m.LangCode)
			if m.Proxy != nil {
				_ = m.Proxy.Encode(x, layer)
			}

			if m.Params != nil {
				_ = m.Params.Encode(x, layer)
			}

			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_initConnection, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_initConnection, layer)
	}
}

// Decode <--
func (m *TLInitConnection) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc1cd5ea9: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.ApiId, err = d.Int32()
			m.DeviceModel, err = d.String()
			m.SystemVersion, err = d.String()
			m.AppVersion, err = d.String()
			m.SystemLangCode, err = d.String()
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m9 := &InputClientProxy{}
				_ = m9.Decode(d)
				m.Proxy = m9
			}
			if (flags & (1 << 1)) != 0 {
				m10 := &JSONValue{}
				_ = m10.Decode(d)
				m.Params = m10
			}
			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
		0x785188b8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.ApiId, err = d.Int32()
			m.DeviceModel, err = d.String()
			m.SystemVersion, err = d.String()
			m.AppVersion, err = d.String()
			m.SystemLangCode, err = d.String()
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m9 := &InputClientProxy{}
				_ = m9.Decode(d)
				m.Proxy = m9
			}
			if (flags & (1 << 1)) != 0 {
				m10 := &JSONValue{}
				_ = m10.Decode(d)
				m.Params = m10
			}
			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithLayer <--
type TLInvokeWithLayer struct {
	ClazzID uint32 `json:"_id"`
	Layer   int32  `json:"layer"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeWithLayer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithLayer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xda9b0d0d: func() error {
			x.PutClazzID(0xda9b0d0d)

			x.PutInt32(m.Layer)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithLayer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithLayer, layer)
	}
}

// Decode <--
func (m *TLInvokeWithLayer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xda9b0d0d: func() (err error) {
			m.Layer, err = d.Int32()
			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithoutUpdates <--
type TLInvokeWithoutUpdates struct {
	ClazzID uint32 `json:"_id"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeWithoutUpdates) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithoutUpdates) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbf9459b7: func() error {
			x.PutClazzID(0xbf9459b7)

			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithoutUpdates, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithoutUpdates, layer)
	}
}

// Decode <--
func (m *TLInvokeWithoutUpdates) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbf9459b7: func() (err error) {
			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithMessagesRange <--
type TLInvokeWithMessagesRange struct {
	ClazzID uint32        `json:"_id"`
	Range   *MessageRange `json:"range"`
	Query   []byte        `json:"query"`
}

func (m *TLInvokeWithMessagesRange) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithMessagesRange) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x365275f2: func() error {
			x.PutClazzID(0x365275f2)

			_ = m.Range.Encode(x, layer)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithMessagesRange, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithMessagesRange, layer)
	}
}

// Decode <--
func (m *TLInvokeWithMessagesRange) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x365275f2: func() (err error) {

			m1 := &MessageRange{}
			_ = m1.Decode(d)
			m.Range = m1

			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithTakeout <--
type TLInvokeWithTakeout struct {
	ClazzID   uint32 `json:"_id"`
	TakeoutId int64  `json:"takeout_id"`
	Query     []byte `json:"query"`
}

func (m *TLInvokeWithTakeout) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithTakeout) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaca9fd2e: func() error {
			x.PutClazzID(0xaca9fd2e)

			x.PutInt64(m.TakeoutId)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithTakeout, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithTakeout, layer)
	}
}

// Decode <--
func (m *TLInvokeWithTakeout) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaca9fd2e: func() (err error) {
			m.TakeoutId, err = d.Int64()
			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithBusinessConnection <--
type TLInvokeWithBusinessConnection struct {
	ClazzID      uint32 `json:"_id"`
	ConnectionId string `json:"connection_id"`
	Query        []byte `json:"query"`
}

func (m *TLInvokeWithBusinessConnection) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithBusinessConnection) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdd289f8e: func() error {
			x.PutClazzID(0xdd289f8e)

			x.PutString(m.ConnectionId)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithBusinessConnection, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithBusinessConnection, layer)
	}
}

// Decode <--
func (m *TLInvokeWithBusinessConnection) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdd289f8e: func() (err error) {
			m.ConnectionId, err = d.String()
			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithGooglePlayIntegrity <--
type TLInvokeWithGooglePlayIntegrity struct {
	ClazzID uint32 `json:"_id"`
	Nonce   string `json:"nonce"`
	Token   string `json:"token"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeWithGooglePlayIntegrity) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithGooglePlayIntegrity) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1df92984: func() error {
			x.PutClazzID(0x1df92984)

			x.PutString(m.Nonce)
			x.PutString(m.Token)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithGooglePlayIntegrity, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithGooglePlayIntegrity, layer)
	}
}

// Decode <--
func (m *TLInvokeWithGooglePlayIntegrity) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1df92984: func() (err error) {
			m.Nonce, err = d.String()
			m.Token, err = d.String()
			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithApnsSecret <--
type TLInvokeWithApnsSecret struct {
	ClazzID uint32 `json:"_id"`
	Nonce   string `json:"nonce"`
	Secret  string `json:"secret"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeWithApnsSecret) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithApnsSecret) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdae54f8: func() error {
			x.PutClazzID(0xdae54f8)

			x.PutString(m.Nonce)
			x.PutString(m.Secret)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithApnsSecret, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithApnsSecret, layer)
	}
}

// Decode <--
func (m *TLInvokeWithApnsSecret) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdae54f8: func() (err error) {
			m.Nonce, err = d.String()
			m.Secret, err = d.String()
			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLInvokeWithReCaptcha <--
type TLInvokeWithReCaptcha struct {
	ClazzID uint32 `json:"_id"`
	Token   string `json:"token"`
	Query   []byte `json:"query"`
}

func (m *TLInvokeWithReCaptcha) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLInvokeWithReCaptcha) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xadbb0f94: func() error {
			x.PutClazzID(0xadbb0f94)

			x.PutString(m.Token)
			// template Debug by @benqi

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_invokeWithReCaptcha, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_invokeWithReCaptcha, layer)
	}
}

// Decode <--
func (m *TLInvokeWithReCaptcha) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xadbb0f94: func() (err error) {
			m.Token, err = d.String()
			// template Debug by @benqi
			m.Query = d.Raw()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthSendCode <--
type TLAuthSendCode struct {
	ClazzID     uint32        `json:"_id"`
	PhoneNumber string        `json:"phone_number"`
	ApiId       int32         `json:"api_id"`
	ApiHash     string        `json:"api_hash"`
	Settings    *CodeSettings `json:"settings"`
}

func (m *TLAuthSendCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthSendCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa677244f: func() error {
			x.PutClazzID(0xa677244f)

			x.PutString(m.PhoneNumber)
			x.PutInt32(m.ApiId)
			x.PutString(m.ApiHash)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_sendCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_sendCode, layer)
	}
}

// Decode <--
func (m *TLAuthSendCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa677244f: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.ApiId, err = d.Int32()
			m.ApiHash, err = d.String()

			m4 := &CodeSettings{}
			_ = m4.Decode(d)
			m.Settings = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthSignUp <--
type TLAuthSignUp struct {
	ClazzID               uint32 `json:"_id"`
	NoJoinedNotifications bool   `json:"no_joined_notifications"`
	PhoneNumber           string `json:"phone_number"`
	PhoneCodeHash         string `json:"phone_code_hash"`
	FirstName             string `json:"first_name"`
	LastName              string `json:"last_name"`
}

func (m *TLAuthSignUp) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthSignUp) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaac7b717: func() error {
			x.PutClazzID(0xaac7b717)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoJoinedNotifications == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			x.PutString(m.FirstName)
			x.PutString(m.LastName)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_signUp, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_signUp, layer)
	}
}

// Decode <--
func (m *TLAuthSignUp) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaac7b717: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.NoJoinedNotifications = true
			}
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			m.FirstName, err = d.String()
			m.LastName, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthSignIn <--
type TLAuthSignIn struct {
	ClazzID           uint32             `json:"_id"`
	PhoneNumber       string             `json:"phone_number"`
	PhoneCodeHash     string             `json:"phone_code_hash"`
	PhoneCode         *string            `json:"phone_code"`
	EmailVerification *EmailVerification `json:"email_verification"`
}

func (m *TLAuthSignIn) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthSignIn) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8d52a951: func() error {
			x.PutClazzID(0x8d52a951)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.PhoneCode != nil {
					flags |= 1 << 0
				}
				if m.EmailVerification != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			if m.PhoneCode != nil {
				x.PutString(*m.PhoneCode)
			}

			if m.EmailVerification != nil {
				_ = m.EmailVerification.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_signIn, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_signIn, layer)
	}
}

// Decode <--
func (m *TLAuthSignIn) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8d52a951: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.PhoneCode = new(string)
				*m.PhoneCode, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m5 := &EmailVerification{}
				_ = m5.Decode(d)
				m.EmailVerification = m5
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthLogOut <--
type TLAuthLogOut struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAuthLogOut) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthLogOut) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3e72ba19: func() error {
			x.PutClazzID(0x3e72ba19)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_logOut, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_logOut, layer)
	}
}

// Decode <--
func (m *TLAuthLogOut) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3e72ba19: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthResetAuthorizations <--
type TLAuthResetAuthorizations struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAuthResetAuthorizations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthResetAuthorizations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9fab0d1a: func() error {
			x.PutClazzID(0x9fab0d1a)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_resetAuthorizations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_resetAuthorizations, layer)
	}
}

// Decode <--
func (m *TLAuthResetAuthorizations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9fab0d1a: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthExportAuthorization <--
type TLAuthExportAuthorization struct {
	ClazzID uint32 `json:"_id"`
	DcId    int32  `json:"dc_id"`
}

func (m *TLAuthExportAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthExportAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe5bfffcd: func() error {
			x.PutClazzID(0xe5bfffcd)

			x.PutInt32(m.DcId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_exportAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_exportAuthorization, layer)
	}
}

// Decode <--
func (m *TLAuthExportAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe5bfffcd: func() (err error) {
			m.DcId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthImportAuthorization <--
type TLAuthImportAuthorization struct {
	ClazzID uint32 `json:"_id"`
	Id      int64  `json:"id"`
	Bytes   []byte `json:"bytes"`
}

func (m *TLAuthImportAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthImportAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa57a7dad: func() error {
			x.PutClazzID(0xa57a7dad)

			x.PutInt64(m.Id)
			x.PutBytes(m.Bytes)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_importAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_importAuthorization, layer)
	}
}

// Decode <--
func (m *TLAuthImportAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa57a7dad: func() (err error) {
			m.Id, err = d.Int64()
			m.Bytes, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthBindTempAuthKey <--
type TLAuthBindTempAuthKey struct {
	ClazzID          uint32 `json:"_id"`
	PermAuthKeyId    int64  `json:"perm_auth_key_id"`
	Nonce            int64  `json:"nonce"`
	ExpiresAt        int32  `json:"expires_at"`
	EncryptedMessage []byte `json:"encrypted_message"`
}

func (m *TLAuthBindTempAuthKey) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthBindTempAuthKey) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcdd42a05: func() error {
			x.PutClazzID(0xcdd42a05)

			x.PutInt64(m.PermAuthKeyId)
			x.PutInt64(m.Nonce)
			x.PutInt32(m.ExpiresAt)
			x.PutBytes(m.EncryptedMessage)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_bindTempAuthKey, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_bindTempAuthKey, layer)
	}
}

// Decode <--
func (m *TLAuthBindTempAuthKey) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcdd42a05: func() (err error) {
			m.PermAuthKeyId, err = d.Int64()
			m.Nonce, err = d.Int64()
			m.ExpiresAt, err = d.Int32()
			m.EncryptedMessage, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthImportBotAuthorization <--
type TLAuthImportBotAuthorization struct {
	ClazzID      uint32 `json:"_id"`
	Flags        int32  `json:"flags"`
	ApiId        int32  `json:"api_id"`
	ApiHash      string `json:"api_hash"`
	BotAuthToken string `json:"bot_auth_token"`
}

func (m *TLAuthImportBotAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthImportBotAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x67a3ff2c: func() error {
			x.PutClazzID(0x67a3ff2c)

			x.PutInt32(m.Flags)
			x.PutInt32(m.ApiId)
			x.PutString(m.ApiHash)
			x.PutString(m.BotAuthToken)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_importBotAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_importBotAuthorization, layer)
	}
}

// Decode <--
func (m *TLAuthImportBotAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x67a3ff2c: func() (err error) {
			m.Flags, err = d.Int32()
			m.ApiId, err = d.Int32()
			m.ApiHash, err = d.String()
			m.BotAuthToken, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthCheckPassword <--
type TLAuthCheckPassword struct {
	ClazzID  uint32                 `json:"_id"`
	Password *InputCheckPasswordSRP `json:"password"`
}

func (m *TLAuthCheckPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthCheckPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd18b4d16: func() error {
			x.PutClazzID(0xd18b4d16)

			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_checkPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_checkPassword, layer)
	}
}

// Decode <--
func (m *TLAuthCheckPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd18b4d16: func() (err error) {

			m1 := &InputCheckPasswordSRP{}
			_ = m1.Decode(d)
			m.Password = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthRequestPasswordRecovery <--
type TLAuthRequestPasswordRecovery struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAuthRequestPasswordRecovery) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthRequestPasswordRecovery) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd897bc66: func() error {
			x.PutClazzID(0xd897bc66)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_requestPasswordRecovery, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_requestPasswordRecovery, layer)
	}
}

// Decode <--
func (m *TLAuthRequestPasswordRecovery) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd897bc66: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthRecoverPassword <--
type TLAuthRecoverPassword struct {
	ClazzID     uint32                        `json:"_id"`
	Code        string                        `json:"code"`
	NewSettings *AccountPasswordInputSettings `json:"new_settings"`
}

func (m *TLAuthRecoverPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthRecoverPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x37096c70: func() error {
			x.PutClazzID(0x37096c70)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NewSettings != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Code)
			if m.NewSettings != nil {
				_ = m.NewSettings.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_recoverPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_recoverPassword, layer)
	}
}

// Decode <--
func (m *TLAuthRecoverPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x37096c70: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Code, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m3 := &AccountPasswordInputSettings{}
				_ = m3.Decode(d)
				m.NewSettings = m3
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthResendCode <--
type TLAuthResendCode struct {
	ClazzID       uint32  `json:"_id"`
	PhoneNumber   string  `json:"phone_number"`
	PhoneCodeHash string  `json:"phone_code_hash"`
	Reason        *string `json:"reason"`
}

func (m *TLAuthResendCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthResendCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcae47523: func() error {
			x.PutClazzID(0xcae47523)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Reason != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			if m.Reason != nil {
				x.PutString(*m.Reason)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_resendCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_resendCode, layer)
	}
}

// Decode <--
func (m *TLAuthResendCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcae47523: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.Reason = new(string)
				*m.Reason, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthCancelCode <--
type TLAuthCancelCode struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
}

func (m *TLAuthCancelCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthCancelCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1f040578: func() error {
			x.PutClazzID(0x1f040578)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_cancelCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_cancelCode, layer)
	}
}

// Decode <--
func (m *TLAuthCancelCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1f040578: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthDropTempAuthKeys <--
type TLAuthDropTempAuthKeys struct {
	ClazzID        uint32  `json:"_id"`
	ExceptAuthKeys []int64 `json:"except_auth_keys"`
}

func (m *TLAuthDropTempAuthKeys) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthDropTempAuthKeys) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8e48a188: func() error {
			x.PutClazzID(0x8e48a188)

			iface.EncodeInt64List(x, m.ExceptAuthKeys)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_dropTempAuthKeys, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_dropTempAuthKeys, layer)
	}
}

// Decode <--
func (m *TLAuthDropTempAuthKeys) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8e48a188: func() (err error) {

			m.ExceptAuthKeys, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthExportLoginToken <--
type TLAuthExportLoginToken struct {
	ClazzID   uint32  `json:"_id"`
	ApiId     int32   `json:"api_id"`
	ApiHash   string  `json:"api_hash"`
	ExceptIds []int64 `json:"except_ids"`
}

func (m *TLAuthExportLoginToken) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthExportLoginToken) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb7e085fe: func() error {
			x.PutClazzID(0xb7e085fe)

			x.PutInt32(m.ApiId)
			x.PutString(m.ApiHash)

			iface.EncodeInt64List(x, m.ExceptIds)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_exportLoginToken, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_exportLoginToken, layer)
	}
}

// Decode <--
func (m *TLAuthExportLoginToken) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb7e085fe: func() (err error) {
			m.ApiId, err = d.Int32()
			m.ApiHash, err = d.String()

			m.ExceptIds, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthImportLoginToken <--
type TLAuthImportLoginToken struct {
	ClazzID uint32 `json:"_id"`
	Token   []byte `json:"token"`
}

func (m *TLAuthImportLoginToken) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthImportLoginToken) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x95ac5ce4: func() error {
			x.PutClazzID(0x95ac5ce4)

			x.PutBytes(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_importLoginToken, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_importLoginToken, layer)
	}
}

// Decode <--
func (m *TLAuthImportLoginToken) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x95ac5ce4: func() (err error) {
			m.Token, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthAcceptLoginToken <--
type TLAuthAcceptLoginToken struct {
	ClazzID uint32 `json:"_id"`
	Token   []byte `json:"token"`
}

func (m *TLAuthAcceptLoginToken) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthAcceptLoginToken) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe894ad4d: func() error {
			x.PutClazzID(0xe894ad4d)

			x.PutBytes(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_acceptLoginToken, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_acceptLoginToken, layer)
	}
}

// Decode <--
func (m *TLAuthAcceptLoginToken) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe894ad4d: func() (err error) {
			m.Token, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthCheckRecoveryPassword <--
type TLAuthCheckRecoveryPassword struct {
	ClazzID uint32 `json:"_id"`
	Code    string `json:"code"`
}

func (m *TLAuthCheckRecoveryPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthCheckRecoveryPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd36bf79: func() error {
			x.PutClazzID(0xd36bf79)

			x.PutString(m.Code)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_checkRecoveryPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_checkRecoveryPassword, layer)
	}
}

// Decode <--
func (m *TLAuthCheckRecoveryPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd36bf79: func() (err error) {
			m.Code, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthImportWebTokenAuthorization <--
type TLAuthImportWebTokenAuthorization struct {
	ClazzID      uint32 `json:"_id"`
	ApiId        int32  `json:"api_id"`
	ApiHash      string `json:"api_hash"`
	WebAuthToken string `json:"web_auth_token"`
}

func (m *TLAuthImportWebTokenAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthImportWebTokenAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2db873a9: func() error {
			x.PutClazzID(0x2db873a9)

			x.PutInt32(m.ApiId)
			x.PutString(m.ApiHash)
			x.PutString(m.WebAuthToken)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_importWebTokenAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_importWebTokenAuthorization, layer)
	}
}

// Decode <--
func (m *TLAuthImportWebTokenAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2db873a9: func() (err error) {
			m.ApiId, err = d.Int32()
			m.ApiHash, err = d.String()
			m.WebAuthToken, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthRequestFirebaseSms <--
type TLAuthRequestFirebaseSms struct {
	ClazzID            uint32  `json:"_id"`
	PhoneNumber        string  `json:"phone_number"`
	PhoneCodeHash      string  `json:"phone_code_hash"`
	SafetyNetToken     *string `json:"safety_net_token"`
	PlayIntegrityToken *string `json:"play_integrity_token"`
	IosPushSecret      *string `json:"ios_push_secret"`
}

func (m *TLAuthRequestFirebaseSms) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthRequestFirebaseSms) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8e39261e: func() error {
			x.PutClazzID(0x8e39261e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SafetyNetToken != nil {
					flags |= 1 << 0
				}
				if m.PlayIntegrityToken != nil {
					flags |= 1 << 2
				}
				if m.IosPushSecret != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			if m.SafetyNetToken != nil {
				x.PutString(*m.SafetyNetToken)
			}

			if m.PlayIntegrityToken != nil {
				x.PutString(*m.PlayIntegrityToken)
			}

			if m.IosPushSecret != nil {
				x.PutString(*m.IosPushSecret)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_requestFirebaseSms, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_requestFirebaseSms, layer)
	}
}

// Decode <--
func (m *TLAuthRequestFirebaseSms) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8e39261e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.SafetyNetToken = new(string)
				*m.SafetyNetToken, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.PlayIntegrityToken = new(string)
				*m.PlayIntegrityToken, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.IosPushSecret = new(string)
				*m.IosPushSecret, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthResetLoginEmail <--
type TLAuthResetLoginEmail struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
}

func (m *TLAuthResetLoginEmail) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthResetLoginEmail) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7e960193: func() error {
			x.PutClazzID(0x7e960193)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_resetLoginEmail, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_resetLoginEmail, layer)
	}
}

// Decode <--
func (m *TLAuthResetLoginEmail) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7e960193: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthReportMissingCode <--
type TLAuthReportMissingCode struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
	Mnc           string `json:"mnc"`
}

func (m *TLAuthReportMissingCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthReportMissingCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcb9deff6: func() error {
			x.PutClazzID(0xcb9deff6)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			x.PutString(m.Mnc)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_reportMissingCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_reportMissingCode, layer)
	}
}

// Decode <--
func (m *TLAuthReportMissingCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcb9deff6: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			m.Mnc, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountRegisterDevice <--
type TLAccountRegisterDevice struct {
	ClazzID    uint32  `json:"_id"`
	NoMuted    bool    `json:"no_muted"`
	TokenType  int32   `json:"token_type"`
	Token      string  `json:"token"`
	AppSandbox *Bool   `json:"app_sandbox"`
	Secret     []byte  `json:"secret"`
	OtherUids  []int64 `json:"other_uids"`
}

func (m *TLAccountRegisterDevice) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountRegisterDevice) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xec86017a: func() error {
			x.PutClazzID(0xec86017a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoMuted == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.TokenType)
			x.PutString(m.Token)
			_ = m.AppSandbox.Encode(x, layer)
			x.PutBytes(m.Secret)

			iface.EncodeInt64List(x, m.OtherUids)

			return nil
		},
		0x637ea878: func() error {
			x.PutClazzID(0x637ea878)

			x.PutInt32(m.TokenType)
			x.PutString(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_registerDevice, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_registerDevice, layer)
	}
}

// Decode <--
func (m *TLAccountRegisterDevice) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xec86017a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.NoMuted = true
			}
			m.TokenType, err = d.Int32()
			m.Token, err = d.String()

			m5 := &Bool{}
			_ = m5.Decode(d)
			m.AppSandbox = m5

			m.Secret, err = d.Bytes()

			m.OtherUids, err = iface.DecodeInt64List(d)

			return nil
		},
		0x637ea878: func() (err error) {
			m.TokenType, err = d.Int32()
			m.Token, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUnregisterDevice <--
type TLAccountUnregisterDevice struct {
	ClazzID   uint32  `json:"_id"`
	TokenType int32   `json:"token_type"`
	Token     string  `json:"token"`
	OtherUids []int64 `json:"other_uids"`
}

func (m *TLAccountUnregisterDevice) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUnregisterDevice) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6a0d3206: func() error {
			x.PutClazzID(0x6a0d3206)

			x.PutInt32(m.TokenType)
			x.PutString(m.Token)

			iface.EncodeInt64List(x, m.OtherUids)

			return nil
		},
		0x65c55b40: func() error {
			x.PutClazzID(0x65c55b40)

			x.PutInt32(m.TokenType)
			x.PutString(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_unregisterDevice, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_unregisterDevice, layer)
	}
}

// Decode <--
func (m *TLAccountUnregisterDevice) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6a0d3206: func() (err error) {
			m.TokenType, err = d.Int32()
			m.Token, err = d.String()

			m.OtherUids, err = iface.DecodeInt64List(d)

			return nil
		},
		0x65c55b40: func() (err error) {
			m.TokenType, err = d.Int32()
			m.Token, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateNotifySettings <--
type TLAccountUpdateNotifySettings struct {
	ClazzID  uint32                   `json:"_id"`
	Peer     *InputNotifyPeer         `json:"peer"`
	Settings *InputPeerNotifySettings `json:"settings"`
}

func (m *TLAccountUpdateNotifySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateNotifySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x84be5b93: func() error {
			x.PutClazzID(0x84be5b93)

			_ = m.Peer.Encode(x, layer)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateNotifySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateNotifySettings, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateNotifySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x84be5b93: func() (err error) {

			m1 := &InputNotifyPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputPeerNotifySettings{}
			_ = m2.Decode(d)
			m.Settings = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetNotifySettings <--
type TLAccountGetNotifySettings struct {
	ClazzID uint32           `json:"_id"`
	Peer    *InputNotifyPeer `json:"peer"`
}

func (m *TLAccountGetNotifySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetNotifySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x12b3ad31: func() error {
			x.PutClazzID(0x12b3ad31)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getNotifySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getNotifySettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetNotifySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x12b3ad31: func() (err error) {

			m1 := &InputNotifyPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetNotifySettings <--
type TLAccountResetNotifySettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountResetNotifySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetNotifySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdb7e1747: func() error {
			x.PutClazzID(0xdb7e1747)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetNotifySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetNotifySettings, layer)
	}
}

// Decode <--
func (m *TLAccountResetNotifySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdb7e1747: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateProfile <--
type TLAccountUpdateProfile struct {
	ClazzID   uint32  `json:"_id"`
	FirstName *string `json:"first_name"`
	LastName  *string `json:"last_name"`
	About     *string `json:"about"`
}

func (m *TLAccountUpdateProfile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateProfile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x78515775: func() error {
			x.PutClazzID(0x78515775)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FirstName != nil {
					flags |= 1 << 0
				}
				if m.LastName != nil {
					flags |= 1 << 1
				}
				if m.About != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.FirstName != nil {
				x.PutString(*m.FirstName)
			}

			if m.LastName != nil {
				x.PutString(*m.LastName)
			}

			if m.About != nil {
				x.PutString(*m.About)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateProfile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateProfile, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateProfile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x78515775: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.FirstName = new(string)
				*m.FirstName, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.LastName = new(string)
				*m.LastName, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.About = new(string)
				*m.About, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateStatus <--
type TLAccountUpdateStatus struct {
	ClazzID uint32 `json:"_id"`
	Offline *Bool  `json:"offline"`
}

func (m *TLAccountUpdateStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6628562c: func() error {
			x.PutClazzID(0x6628562c)

			_ = m.Offline.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateStatus, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6628562c: func() (err error) {

			m1 := &Bool{}
			_ = m1.Decode(d)
			m.Offline = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetWallPapers <--
type TLAccountGetWallPapers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetWallPapers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetWallPapers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7967d36: func() error {
			x.PutClazzID(0x7967d36)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getWallPapers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getWallPapers, layer)
	}
}

// Decode <--
func (m *TLAccountGetWallPapers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7967d36: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountReportPeer <--
type TLAccountReportPeer struct {
	ClazzID uint32        `json:"_id"`
	Peer    *InputPeer    `json:"peer"`
	Reason  *ReportReason `json:"reason"`
	Message string        `json:"message"`
}

func (m *TLAccountReportPeer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountReportPeer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc5ba3d86: func() error {
			x.PutClazzID(0xc5ba3d86)

			_ = m.Peer.Encode(x, layer)
			_ = m.Reason.Encode(x, layer)
			x.PutString(m.Message)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_reportPeer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_reportPeer, layer)
	}
}

// Decode <--
func (m *TLAccountReportPeer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc5ba3d86: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &ReportReason{}
			_ = m2.Decode(d)
			m.Reason = m2

			m.Message, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountCheckUsername <--
type TLAccountCheckUsername struct {
	ClazzID  uint32 `json:"_id"`
	Username string `json:"username"`
}

func (m *TLAccountCheckUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountCheckUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2714d86c: func() error {
			x.PutClazzID(0x2714d86c)

			x.PutString(m.Username)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_checkUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_checkUsername, layer)
	}
}

// Decode <--
func (m *TLAccountCheckUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2714d86c: func() (err error) {
			m.Username, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateUsername <--
type TLAccountUpdateUsername struct {
	ClazzID  uint32 `json:"_id"`
	Username string `json:"username"`
}

func (m *TLAccountUpdateUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3e0bdd7c: func() error {
			x.PutClazzID(0x3e0bdd7c)

			x.PutString(m.Username)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateUsername, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3e0bdd7c: func() (err error) {
			m.Username, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetPrivacy <--
type TLAccountGetPrivacy struct {
	ClazzID uint32           `json:"_id"`
	Key     *InputPrivacyKey `json:"key"`
}

func (m *TLAccountGetPrivacy) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetPrivacy) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdadbc950: func() error {
			x.PutClazzID(0xdadbc950)

			_ = m.Key.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getPrivacy, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getPrivacy, layer)
	}
}

// Decode <--
func (m *TLAccountGetPrivacy) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdadbc950: func() (err error) {

			m1 := &InputPrivacyKey{}
			_ = m1.Decode(d)
			m.Key = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetPrivacy <--
type TLAccountSetPrivacy struct {
	ClazzID uint32              `json:"_id"`
	Key     *InputPrivacyKey    `json:"key"`
	Rules   []*InputPrivacyRule `json:"rules"`
}

func (m *TLAccountSetPrivacy) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetPrivacy) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc9f81ce8: func() error {
			x.PutClazzID(0xc9f81ce8)

			_ = m.Key.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Rules, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setPrivacy, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setPrivacy, layer)
	}
}

// Decode <--
func (m *TLAccountSetPrivacy) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc9f81ce8: func() (err error) {

			m1 := &InputPrivacyKey{}
			_ = m1.Decode(d)
			m.Key = m1

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputPrivacyRule, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputPrivacyRule)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Rules = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDeleteAccount <--
type TLAccountDeleteAccount struct {
	ClazzID  uint32                 `json:"_id"`
	Reason   string                 `json:"reason"`
	Password *InputCheckPasswordSRP `json:"password"`
}

func (m *TLAccountDeleteAccount) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDeleteAccount) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa2c0cf74: func() error {
			x.PutClazzID(0xa2c0cf74)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Password != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Reason)
			if m.Password != nil {
				_ = m.Password.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_deleteAccount, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_deleteAccount, layer)
	}
}

// Decode <--
func (m *TLAccountDeleteAccount) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa2c0cf74: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Reason, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m3 := &InputCheckPasswordSRP{}
				_ = m3.Decode(d)
				m.Password = m3
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAccountTTL <--
type TLAccountGetAccountTTL struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetAccountTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAccountTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8fc711d: func() error {
			x.PutClazzID(0x8fc711d)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAccountTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAccountTTL, layer)
	}
}

// Decode <--
func (m *TLAccountGetAccountTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8fc711d: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetAccountTTL <--
type TLAccountSetAccountTTL struct {
	ClazzID uint32          `json:"_id"`
	Ttl     *AccountDaysTTL `json:"ttl"`
}

func (m *TLAccountSetAccountTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetAccountTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2442485e: func() error {
			x.PutClazzID(0x2442485e)

			_ = m.Ttl.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setAccountTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setAccountTTL, layer)
	}
}

// Decode <--
func (m *TLAccountSetAccountTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2442485e: func() (err error) {

			m1 := &AccountDaysTTL{}
			_ = m1.Decode(d)
			m.Ttl = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSendChangePhoneCode <--
type TLAccountSendChangePhoneCode struct {
	ClazzID     uint32        `json:"_id"`
	PhoneNumber string        `json:"phone_number"`
	Settings    *CodeSettings `json:"settings"`
}

func (m *TLAccountSendChangePhoneCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSendChangePhoneCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x82574ae5: func() error {
			x.PutClazzID(0x82574ae5)

			x.PutString(m.PhoneNumber)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_sendChangePhoneCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_sendChangePhoneCode, layer)
	}
}

// Decode <--
func (m *TLAccountSendChangePhoneCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x82574ae5: func() (err error) {
			m.PhoneNumber, err = d.String()

			m2 := &CodeSettings{}
			_ = m2.Decode(d)
			m.Settings = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountChangePhone <--
type TLAccountChangePhone struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
	PhoneCode     string `json:"phone_code"`
}

func (m *TLAccountChangePhone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountChangePhone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x70c32edb: func() error {
			x.PutClazzID(0x70c32edb)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			x.PutString(m.PhoneCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_changePhone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_changePhone, layer)
	}
}

// Decode <--
func (m *TLAccountChangePhone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x70c32edb: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			m.PhoneCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateDeviceLocked <--
type TLAccountUpdateDeviceLocked struct {
	ClazzID uint32 `json:"_id"`
	Period  int32  `json:"period"`
}

func (m *TLAccountUpdateDeviceLocked) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateDeviceLocked) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x38df3532: func() error {
			x.PutClazzID(0x38df3532)

			x.PutInt32(m.Period)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateDeviceLocked, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateDeviceLocked, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateDeviceLocked) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x38df3532: func() (err error) {
			m.Period, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAuthorizations <--
type TLAccountGetAuthorizations struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetAuthorizations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAuthorizations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe320c158: func() error {
			x.PutClazzID(0xe320c158)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAuthorizations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAuthorizations, layer)
	}
}

// Decode <--
func (m *TLAccountGetAuthorizations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe320c158: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetAuthorization <--
type TLAccountResetAuthorization struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountResetAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdf77f3bc: func() error {
			x.PutClazzID(0xdf77f3bc)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetAuthorization, layer)
	}
}

// Decode <--
func (m *TLAccountResetAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdf77f3bc: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetPassword <--
type TLAccountGetPassword struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x548a30f5: func() error {
			x.PutClazzID(0x548a30f5)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getPassword, layer)
	}
}

// Decode <--
func (m *TLAccountGetPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x548a30f5: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetPasswordSettings <--
type TLAccountGetPasswordSettings struct {
	ClazzID  uint32                 `json:"_id"`
	Password *InputCheckPasswordSRP `json:"password"`
}

func (m *TLAccountGetPasswordSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetPasswordSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9cd4eaf9: func() error {
			x.PutClazzID(0x9cd4eaf9)

			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getPasswordSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getPasswordSettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetPasswordSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9cd4eaf9: func() (err error) {

			m1 := &InputCheckPasswordSRP{}
			_ = m1.Decode(d)
			m.Password = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdatePasswordSettings <--
type TLAccountUpdatePasswordSettings struct {
	ClazzID     uint32                        `json:"_id"`
	Password    *InputCheckPasswordSRP        `json:"password"`
	NewSettings *AccountPasswordInputSettings `json:"new_settings"`
}

func (m *TLAccountUpdatePasswordSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdatePasswordSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa59b102f: func() error {
			x.PutClazzID(0xa59b102f)

			_ = m.Password.Encode(x, layer)
			_ = m.NewSettings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updatePasswordSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updatePasswordSettings, layer)
	}
}

// Decode <--
func (m *TLAccountUpdatePasswordSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa59b102f: func() (err error) {

			m1 := &InputCheckPasswordSRP{}
			_ = m1.Decode(d)
			m.Password = m1

			m2 := &AccountPasswordInputSettings{}
			_ = m2.Decode(d)
			m.NewSettings = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSendConfirmPhoneCode <--
type TLAccountSendConfirmPhoneCode struct {
	ClazzID  uint32        `json:"_id"`
	Hash     string        `json:"hash"`
	Settings *CodeSettings `json:"settings"`
}

func (m *TLAccountSendConfirmPhoneCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSendConfirmPhoneCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1b3faa88: func() error {
			x.PutClazzID(0x1b3faa88)

			x.PutString(m.Hash)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_sendConfirmPhoneCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_sendConfirmPhoneCode, layer)
	}
}

// Decode <--
func (m *TLAccountSendConfirmPhoneCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1b3faa88: func() (err error) {
			m.Hash, err = d.String()

			m2 := &CodeSettings{}
			_ = m2.Decode(d)
			m.Settings = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountConfirmPhone <--
type TLAccountConfirmPhone struct {
	ClazzID       uint32 `json:"_id"`
	PhoneCodeHash string `json:"phone_code_hash"`
	PhoneCode     string `json:"phone_code"`
}

func (m *TLAccountConfirmPhone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountConfirmPhone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5f2178c3: func() error {
			x.PutClazzID(0x5f2178c3)

			x.PutString(m.PhoneCodeHash)
			x.PutString(m.PhoneCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_confirmPhone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_confirmPhone, layer)
	}
}

// Decode <--
func (m *TLAccountConfirmPhone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5f2178c3: func() (err error) {
			m.PhoneCodeHash, err = d.String()
			m.PhoneCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetTmpPassword <--
type TLAccountGetTmpPassword struct {
	ClazzID  uint32                 `json:"_id"`
	Password *InputCheckPasswordSRP `json:"password"`
	Period   int32                  `json:"period"`
}

func (m *TLAccountGetTmpPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetTmpPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x449e0b51: func() error {
			x.PutClazzID(0x449e0b51)

			_ = m.Password.Encode(x, layer)
			x.PutInt32(m.Period)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getTmpPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getTmpPassword, layer)
	}
}

// Decode <--
func (m *TLAccountGetTmpPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x449e0b51: func() (err error) {

			m1 := &InputCheckPasswordSRP{}
			_ = m1.Decode(d)
			m.Password = m1

			m.Period, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetWebAuthorizations <--
type TLAccountGetWebAuthorizations struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetWebAuthorizations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetWebAuthorizations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x182e6d6f: func() error {
			x.PutClazzID(0x182e6d6f)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getWebAuthorizations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getWebAuthorizations, layer)
	}
}

// Decode <--
func (m *TLAccountGetWebAuthorizations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x182e6d6f: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetWebAuthorization <--
type TLAccountResetWebAuthorization struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountResetWebAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetWebAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2d01b9ef: func() error {
			x.PutClazzID(0x2d01b9ef)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetWebAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetWebAuthorization, layer)
	}
}

// Decode <--
func (m *TLAccountResetWebAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2d01b9ef: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetWebAuthorizations <--
type TLAccountResetWebAuthorizations struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountResetWebAuthorizations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetWebAuthorizations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x682d2594: func() error {
			x.PutClazzID(0x682d2594)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetWebAuthorizations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetWebAuthorizations, layer)
	}
}

// Decode <--
func (m *TLAccountResetWebAuthorizations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x682d2594: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAllSecureValues <--
type TLAccountGetAllSecureValues struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetAllSecureValues) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAllSecureValues) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb288bc7d: func() error {
			x.PutClazzID(0xb288bc7d)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAllSecureValues, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAllSecureValues, layer)
	}
}

// Decode <--
func (m *TLAccountGetAllSecureValues) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb288bc7d: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetSecureValue <--
type TLAccountGetSecureValue struct {
	ClazzID uint32             `json:"_id"`
	Types   []*SecureValueType `json:"types"`
}

func (m *TLAccountGetSecureValue) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetSecureValue) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x73665bc2: func() error {
			x.PutClazzID(0x73665bc2)

			_ = iface.EncodeObjectList(x, m.Types, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getSecureValue, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getSecureValue, layer)
	}
}

// Decode <--
func (m *TLAccountGetSecureValue) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x73665bc2: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*SecureValueType, l1)
			for i := 0; i < l1; i++ {
				vv := new(SecureValueType)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Types = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveSecureValue <--
type TLAccountSaveSecureValue struct {
	ClazzID        uint32            `json:"_id"`
	Value          *InputSecureValue `json:"value"`
	SecureSecretId int64             `json:"secure_secret_id"`
}

func (m *TLAccountSaveSecureValue) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveSecureValue) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x899fe31d: func() error {
			x.PutClazzID(0x899fe31d)

			_ = m.Value.Encode(x, layer)
			x.PutInt64(m.SecureSecretId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveSecureValue, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveSecureValue, layer)
	}
}

// Decode <--
func (m *TLAccountSaveSecureValue) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x899fe31d: func() (err error) {

			m1 := &InputSecureValue{}
			_ = m1.Decode(d)
			m.Value = m1

			m.SecureSecretId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDeleteSecureValue <--
type TLAccountDeleteSecureValue struct {
	ClazzID uint32             `json:"_id"`
	Types   []*SecureValueType `json:"types"`
}

func (m *TLAccountDeleteSecureValue) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDeleteSecureValue) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb880bc4b: func() error {
			x.PutClazzID(0xb880bc4b)

			_ = iface.EncodeObjectList(x, m.Types, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_deleteSecureValue, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_deleteSecureValue, layer)
	}
}

// Decode <--
func (m *TLAccountDeleteSecureValue) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb880bc4b: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*SecureValueType, l1)
			for i := 0; i < l1; i++ {
				vv := new(SecureValueType)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Types = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAuthorizationForm <--
type TLAccountGetAuthorizationForm struct {
	ClazzID   uint32 `json:"_id"`
	BotId     int64  `json:"bot_id"`
	Scope     string `json:"scope"`
	PublicKey string `json:"public_key"`
}

func (m *TLAccountGetAuthorizationForm) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAuthorizationForm) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa929597a: func() error {
			x.PutClazzID(0xa929597a)

			x.PutInt64(m.BotId)
			x.PutString(m.Scope)
			x.PutString(m.PublicKey)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAuthorizationForm, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAuthorizationForm, layer)
	}
}

// Decode <--
func (m *TLAccountGetAuthorizationForm) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa929597a: func() (err error) {
			m.BotId, err = d.Int64()
			m.Scope, err = d.String()
			m.PublicKey, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountAcceptAuthorization <--
type TLAccountAcceptAuthorization struct {
	ClazzID     uint32                      `json:"_id"`
	BotId       int64                       `json:"bot_id"`
	Scope       string                      `json:"scope"`
	PublicKey   string                      `json:"public_key"`
	ValueHashes []*SecureValueHash          `json:"value_hashes"`
	Credentials *SecureCredentialsEncrypted `json:"credentials"`
}

func (m *TLAccountAcceptAuthorization) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountAcceptAuthorization) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf3ed4c73: func() error {
			x.PutClazzID(0xf3ed4c73)

			x.PutInt64(m.BotId)
			x.PutString(m.Scope)
			x.PutString(m.PublicKey)

			_ = iface.EncodeObjectList(x, m.ValueHashes, layer)

			_ = m.Credentials.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_acceptAuthorization, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_acceptAuthorization, layer)
	}
}

// Decode <--
func (m *TLAccountAcceptAuthorization) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf3ed4c73: func() (err error) {
			m.BotId, err = d.Int64()
			m.Scope, err = d.String()
			m.PublicKey, err = d.String()
			c4, err2 := d.ClazzID()
			if c4 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
				return err2
			}
			l4, err3 := d.Int()
			v4 := make([]*SecureValueHash, l4)
			for i := 0; i < l4; i++ {
				vv := new(SecureValueHash)
				err3 = vv.Decode(d)
				_ = err3
				v4[i] = vv
			}
			m.ValueHashes = v4

			m5 := &SecureCredentialsEncrypted{}
			_ = m5.Decode(d)
			m.Credentials = m5

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSendVerifyPhoneCode <--
type TLAccountSendVerifyPhoneCode struct {
	ClazzID     uint32        `json:"_id"`
	PhoneNumber string        `json:"phone_number"`
	Settings    *CodeSettings `json:"settings"`
}

func (m *TLAccountSendVerifyPhoneCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSendVerifyPhoneCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa5a356f9: func() error {
			x.PutClazzID(0xa5a356f9)

			x.PutString(m.PhoneNumber)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_sendVerifyPhoneCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_sendVerifyPhoneCode, layer)
	}
}

// Decode <--
func (m *TLAccountSendVerifyPhoneCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa5a356f9: func() (err error) {
			m.PhoneNumber, err = d.String()

			m2 := &CodeSettings{}
			_ = m2.Decode(d)
			m.Settings = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountVerifyPhone <--
type TLAccountVerifyPhone struct {
	ClazzID       uint32 `json:"_id"`
	PhoneNumber   string `json:"phone_number"`
	PhoneCodeHash string `json:"phone_code_hash"`
	PhoneCode     string `json:"phone_code"`
}

func (m *TLAccountVerifyPhone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountVerifyPhone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4dd3a7f6: func() error {
			x.PutClazzID(0x4dd3a7f6)

			x.PutString(m.PhoneNumber)
			x.PutString(m.PhoneCodeHash)
			x.PutString(m.PhoneCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_verifyPhone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_verifyPhone, layer)
	}
}

// Decode <--
func (m *TLAccountVerifyPhone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4dd3a7f6: func() (err error) {
			m.PhoneNumber, err = d.String()
			m.PhoneCodeHash, err = d.String()
			m.PhoneCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSendVerifyEmailCode <--
type TLAccountSendVerifyEmailCode struct {
	ClazzID uint32              `json:"_id"`
	Purpose *EmailVerifyPurpose `json:"purpose"`
	Email   string              `json:"email"`
}

func (m *TLAccountSendVerifyEmailCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSendVerifyEmailCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x98e037bb: func() error {
			x.PutClazzID(0x98e037bb)

			_ = m.Purpose.Encode(x, layer)
			x.PutString(m.Email)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_sendVerifyEmailCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_sendVerifyEmailCode, layer)
	}
}

// Decode <--
func (m *TLAccountSendVerifyEmailCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x98e037bb: func() (err error) {

			m1 := &EmailVerifyPurpose{}
			_ = m1.Decode(d)
			m.Purpose = m1

			m.Email, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountVerifyEmail <--
type TLAccountVerifyEmail struct {
	ClazzID      uint32              `json:"_id"`
	Purpose      *EmailVerifyPurpose `json:"purpose"`
	Verification *EmailVerification  `json:"verification"`
}

func (m *TLAccountVerifyEmail) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountVerifyEmail) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x32da4cf: func() error {
			x.PutClazzID(0x32da4cf)

			_ = m.Purpose.Encode(x, layer)
			_ = m.Verification.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_verifyEmail, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_verifyEmail, layer)
	}
}

// Decode <--
func (m *TLAccountVerifyEmail) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x32da4cf: func() (err error) {

			m1 := &EmailVerifyPurpose{}
			_ = m1.Decode(d)
			m.Purpose = m1

			m2 := &EmailVerification{}
			_ = m2.Decode(d)
			m.Verification = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountInitTakeoutSession <--
type TLAccountInitTakeoutSession struct {
	ClazzID           uint32 `json:"_id"`
	Contacts          bool   `json:"contacts"`
	MessageUsers      bool   `json:"message_users"`
	MessageChats      bool   `json:"message_chats"`
	MessageMegagroups bool   `json:"message_megagroups"`
	MessageChannels   bool   `json:"message_channels"`
	Files             bool   `json:"files"`
	FileMaxSize       *int64 `json:"file_max_size"`
}

func (m *TLAccountInitTakeoutSession) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountInitTakeoutSession) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8ef3eab0: func() error {
			x.PutClazzID(0x8ef3eab0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Contacts == true {
					flags |= 1 << 0
				}
				if m.MessageUsers == true {
					flags |= 1 << 1
				}
				if m.MessageChats == true {
					flags |= 1 << 2
				}
				if m.MessageMegagroups == true {
					flags |= 1 << 3
				}
				if m.MessageChannels == true {
					flags |= 1 << 4
				}
				if m.Files == true {
					flags |= 1 << 5
				}
				if m.FileMaxSize != nil {
					flags |= 1 << 5
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.FileMaxSize != nil {
				x.PutInt64(*m.FileMaxSize)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_initTakeoutSession, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_initTakeoutSession, layer)
	}
}

// Decode <--
func (m *TLAccountInitTakeoutSession) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8ef3eab0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Contacts = true
			}
			if (flags & (1 << 1)) != 0 {
				m.MessageUsers = true
			}
			if (flags & (1 << 2)) != 0 {
				m.MessageChats = true
			}
			if (flags & (1 << 3)) != 0 {
				m.MessageMegagroups = true
			}
			if (flags & (1 << 4)) != 0 {
				m.MessageChannels = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Files = true
			}
			if (flags & (1 << 5)) != 0 {
				m.FileMaxSize = new(int64)
				*m.FileMaxSize, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountFinishTakeoutSession <--
type TLAccountFinishTakeoutSession struct {
	ClazzID uint32 `json:"_id"`
	Success bool   `json:"success"`
}

func (m *TLAccountFinishTakeoutSession) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountFinishTakeoutSession) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1d2652ee: func() error {
			x.PutClazzID(0x1d2652ee)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Success == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_finishTakeoutSession, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_finishTakeoutSession, layer)
	}
}

// Decode <--
func (m *TLAccountFinishTakeoutSession) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1d2652ee: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Success = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountConfirmPasswordEmail <--
type TLAccountConfirmPasswordEmail struct {
	ClazzID uint32 `json:"_id"`
	Code    string `json:"code"`
}

func (m *TLAccountConfirmPasswordEmail) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountConfirmPasswordEmail) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8fdf1920: func() error {
			x.PutClazzID(0x8fdf1920)

			x.PutString(m.Code)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_confirmPasswordEmail, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_confirmPasswordEmail, layer)
	}
}

// Decode <--
func (m *TLAccountConfirmPasswordEmail) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8fdf1920: func() (err error) {
			m.Code, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResendPasswordEmail <--
type TLAccountResendPasswordEmail struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountResendPasswordEmail) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResendPasswordEmail) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7a7f2a15: func() error {
			x.PutClazzID(0x7a7f2a15)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resendPasswordEmail, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resendPasswordEmail, layer)
	}
}

// Decode <--
func (m *TLAccountResendPasswordEmail) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7a7f2a15: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountCancelPasswordEmail <--
type TLAccountCancelPasswordEmail struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountCancelPasswordEmail) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountCancelPasswordEmail) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc1cbd5b6: func() error {
			x.PutClazzID(0xc1cbd5b6)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_cancelPasswordEmail, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_cancelPasswordEmail, layer)
	}
}

// Decode <--
func (m *TLAccountCancelPasswordEmail) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc1cbd5b6: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetContactSignUpNotification <--
type TLAccountGetContactSignUpNotification struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetContactSignUpNotification) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetContactSignUpNotification) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9f07c728: func() error {
			x.PutClazzID(0x9f07c728)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getContactSignUpNotification, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getContactSignUpNotification, layer)
	}
}

// Decode <--
func (m *TLAccountGetContactSignUpNotification) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9f07c728: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetContactSignUpNotification <--
type TLAccountSetContactSignUpNotification struct {
	ClazzID uint32 `json:"_id"`
	Silent  *Bool  `json:"silent"`
}

func (m *TLAccountSetContactSignUpNotification) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetContactSignUpNotification) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcff43f61: func() error {
			x.PutClazzID(0xcff43f61)

			_ = m.Silent.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setContactSignUpNotification, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setContactSignUpNotification, layer)
	}
}

// Decode <--
func (m *TLAccountSetContactSignUpNotification) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcff43f61: func() (err error) {

			m1 := &Bool{}
			_ = m1.Decode(d)
			m.Silent = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetNotifyExceptions <--
type TLAccountGetNotifyExceptions struct {
	ClazzID        uint32           `json:"_id"`
	CompareSound   bool             `json:"compare_sound"`
	CompareStories bool             `json:"compare_stories"`
	Peer           *InputNotifyPeer `json:"peer"`
}

func (m *TLAccountGetNotifyExceptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetNotifyExceptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x53577479: func() error {
			x.PutClazzID(0x53577479)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.CompareSound == true {
					flags |= 1 << 1
				}
				if m.CompareStories == true {
					flags |= 1 << 2
				}
				if m.Peer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getNotifyExceptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getNotifyExceptions, layer)
	}
}

// Decode <--
func (m *TLAccountGetNotifyExceptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x53577479: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.CompareSound = true
			}
			if (flags & (1 << 2)) != 0 {
				m.CompareStories = true
			}
			if (flags & (1 << 0)) != 0 {
				m4 := &InputNotifyPeer{}
				_ = m4.Decode(d)
				m.Peer = m4
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetWallPaper <--
type TLAccountGetWallPaper struct {
	ClazzID   uint32          `json:"_id"`
	Wallpaper *InputWallPaper `json:"wallpaper"`
}

func (m *TLAccountGetWallPaper) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetWallPaper) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfc8ddbea: func() error {
			x.PutClazzID(0xfc8ddbea)

			_ = m.Wallpaper.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getWallPaper, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getWallPaper, layer)
	}
}

// Decode <--
func (m *TLAccountGetWallPaper) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfc8ddbea: func() (err error) {

			m1 := &InputWallPaper{}
			_ = m1.Decode(d)
			m.Wallpaper = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUploadWallPaper <--
type TLAccountUploadWallPaper struct {
	ClazzID  uint32             `json:"_id"`
	ForChat  bool               `json:"for_chat"`
	File     *InputFile         `json:"file"`
	MimeType string             `json:"mime_type"`
	Settings *WallPaperSettings `json:"settings"`
}

func (m *TLAccountUploadWallPaper) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUploadWallPaper) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe39a8f03: func() error {
			x.PutClazzID(0xe39a8f03)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForChat == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.File.Encode(x, layer)
			x.PutString(m.MimeType)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_uploadWallPaper, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_uploadWallPaper, layer)
	}
}

// Decode <--
func (m *TLAccountUploadWallPaper) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe39a8f03: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ForChat = true
			}

			m3 := &InputFile{}
			_ = m3.Decode(d)
			m.File = m3

			m.MimeType, err = d.String()

			m5 := &WallPaperSettings{}
			_ = m5.Decode(d)
			m.Settings = m5

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveWallPaper <--
type TLAccountSaveWallPaper struct {
	ClazzID   uint32             `json:"_id"`
	Wallpaper *InputWallPaper    `json:"wallpaper"`
	Unsave    *Bool              `json:"unsave"`
	Settings  *WallPaperSettings `json:"settings"`
}

func (m *TLAccountSaveWallPaper) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveWallPaper) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6c5a5b37: func() error {
			x.PutClazzID(0x6c5a5b37)

			_ = m.Wallpaper.Encode(x, layer)
			_ = m.Unsave.Encode(x, layer)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveWallPaper, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveWallPaper, layer)
	}
}

// Decode <--
func (m *TLAccountSaveWallPaper) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6c5a5b37: func() (err error) {

			m1 := &InputWallPaper{}
			_ = m1.Decode(d)
			m.Wallpaper = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Unsave = m2

			m3 := &WallPaperSettings{}
			_ = m3.Decode(d)
			m.Settings = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountInstallWallPaper <--
type TLAccountInstallWallPaper struct {
	ClazzID   uint32             `json:"_id"`
	Wallpaper *InputWallPaper    `json:"wallpaper"`
	Settings  *WallPaperSettings `json:"settings"`
}

func (m *TLAccountInstallWallPaper) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountInstallWallPaper) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfeed5769: func() error {
			x.PutClazzID(0xfeed5769)

			_ = m.Wallpaper.Encode(x, layer)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_installWallPaper, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_installWallPaper, layer)
	}
}

// Decode <--
func (m *TLAccountInstallWallPaper) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfeed5769: func() (err error) {

			m1 := &InputWallPaper{}
			_ = m1.Decode(d)
			m.Wallpaper = m1

			m2 := &WallPaperSettings{}
			_ = m2.Decode(d)
			m.Settings = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetWallPapers <--
type TLAccountResetWallPapers struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountResetWallPapers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetWallPapers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbb3b9804: func() error {
			x.PutClazzID(0xbb3b9804)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetWallPapers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetWallPapers, layer)
	}
}

// Decode <--
func (m *TLAccountResetWallPapers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbb3b9804: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAutoDownloadSettings <--
type TLAccountGetAutoDownloadSettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetAutoDownloadSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAutoDownloadSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x56da0b3f: func() error {
			x.PutClazzID(0x56da0b3f)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAutoDownloadSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAutoDownloadSettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetAutoDownloadSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x56da0b3f: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveAutoDownloadSettings <--
type TLAccountSaveAutoDownloadSettings struct {
	ClazzID  uint32                `json:"_id"`
	Low      bool                  `json:"low"`
	High     bool                  `json:"high"`
	Settings *AutoDownloadSettings `json:"settings"`
}

func (m *TLAccountSaveAutoDownloadSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveAutoDownloadSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x76f36233: func() error {
			x.PutClazzID(0x76f36233)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Low == true {
					flags |= 1 << 0
				}
				if m.High == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveAutoDownloadSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveAutoDownloadSettings, layer)
	}
}

// Decode <--
func (m *TLAccountSaveAutoDownloadSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x76f36233: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Low = true
			}
			if (flags & (1 << 1)) != 0 {
				m.High = true
			}

			m4 := &AutoDownloadSettings{}
			_ = m4.Decode(d)
			m.Settings = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUploadTheme <--
type TLAccountUploadTheme struct {
	ClazzID  uint32     `json:"_id"`
	File     *InputFile `json:"file"`
	Thumb    *InputFile `json:"thumb"`
	FileName string     `json:"file_name"`
	MimeType string     `json:"mime_type"`
}

func (m *TLAccountUploadTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUploadTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1c3db333: func() error {
			x.PutClazzID(0x1c3db333)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Thumb != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.File.Encode(x, layer)
			if m.Thumb != nil {
				_ = m.Thumb.Encode(x, layer)
			}

			x.PutString(m.FileName)
			x.PutString(m.MimeType)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_uploadTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_uploadTheme, layer)
	}
}

// Decode <--
func (m *TLAccountUploadTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1c3db333: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputFile{}
			_ = m2.Decode(d)
			m.File = m2

			if (flags & (1 << 0)) != 0 {
				m3 := &InputFile{}
				_ = m3.Decode(d)
				m.Thumb = m3
			}
			m.FileName, err = d.String()
			m.MimeType, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountCreateTheme <--
type TLAccountCreateTheme struct {
	ClazzID  uint32                `json:"_id"`
	Slug     string                `json:"slug"`
	Title    string                `json:"title"`
	Document *InputDocument        `json:"document"`
	Settings []*InputThemeSettings `json:"settings"`
}

func (m *TLAccountCreateTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountCreateTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x652e4400: func() error {
			x.PutClazzID(0x652e4400)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Document != nil {
					flags |= 1 << 2
				}
				if m.Settings != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Slug)
			x.PutString(m.Title)
			if m.Document != nil {
				_ = m.Document.Encode(x, layer)
			}

			if m.Settings != nil {
				_ = iface.EncodeObjectList(x, m.Settings, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_createTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_createTheme, layer)
	}
}

// Decode <--
func (m *TLAccountCreateTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x652e4400: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Slug, err = d.String()
			m.Title, err = d.String()
			if (flags & (1 << 2)) != 0 {
				m4 := &InputDocument{}
				_ = m4.Decode(d)
				m.Document = m4
			}
			if (flags & (1 << 3)) != 0 {
				c5, err2 := d.ClazzID()
				if c5 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
					return err2
				}
				l5, err3 := d.Int()
				v5 := make([]*InputThemeSettings, l5)
				for i := 0; i < l5; i++ {
					vv := new(InputThemeSettings)
					err3 = vv.Decode(d)
					_ = err3
					v5[i] = vv
				}
				m.Settings = v5
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateTheme <--
type TLAccountUpdateTheme struct {
	ClazzID  uint32                `json:"_id"`
	Format   string                `json:"format"`
	Theme    *InputTheme           `json:"theme"`
	Slug     *string               `json:"slug"`
	Title    *string               `json:"title"`
	Document *InputDocument        `json:"document"`
	Settings []*InputThemeSettings `json:"settings"`
}

func (m *TLAccountUpdateTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2bf40ccc: func() error {
			x.PutClazzID(0x2bf40ccc)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Slug != nil {
					flags |= 1 << 0
				}
				if m.Title != nil {
					flags |= 1 << 1
				}
				if m.Document != nil {
					flags |= 1 << 2
				}
				if m.Settings != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Format)
			_ = m.Theme.Encode(x, layer)
			if m.Slug != nil {
				x.PutString(*m.Slug)
			}

			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.Document != nil {
				_ = m.Document.Encode(x, layer)
			}

			if m.Settings != nil {
				_ = iface.EncodeObjectList(x, m.Settings, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateTheme, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2bf40ccc: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Format, err = d.String()

			m3 := &InputTheme{}
			_ = m3.Decode(d)
			m.Theme = m3

			if (flags & (1 << 0)) != 0 {
				m.Slug = new(string)
				*m.Slug, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m6 := &InputDocument{}
				_ = m6.Decode(d)
				m.Document = m6
			}
			if (flags & (1 << 3)) != 0 {
				c7, err2 := d.ClazzID()
				if c7 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 7, c7)
					return err2
				}
				l7, err3 := d.Int()
				v7 := make([]*InputThemeSettings, l7)
				for i := 0; i < l7; i++ {
					vv := new(InputThemeSettings)
					err3 = vv.Decode(d)
					_ = err3
					v7[i] = vv
				}
				m.Settings = v7
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveTheme <--
type TLAccountSaveTheme struct {
	ClazzID uint32      `json:"_id"`
	Theme   *InputTheme `json:"theme"`
	Unsave  *Bool       `json:"unsave"`
}

func (m *TLAccountSaveTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf257106c: func() error {
			x.PutClazzID(0xf257106c)

			_ = m.Theme.Encode(x, layer)
			_ = m.Unsave.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveTheme, layer)
	}
}

// Decode <--
func (m *TLAccountSaveTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf257106c: func() (err error) {

			m1 := &InputTheme{}
			_ = m1.Decode(d)
			m.Theme = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Unsave = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountInstallTheme <--
type TLAccountInstallTheme struct {
	ClazzID   uint32      `json:"_id"`
	Dark      bool        `json:"dark"`
	Theme     *InputTheme `json:"theme"`
	Format    *string     `json:"format"`
	BaseTheme *BaseTheme  `json:"base_theme"`
}

func (m *TLAccountInstallTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountInstallTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc727bb3b: func() error {
			x.PutClazzID(0xc727bb3b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}
				if m.Theme != nil {
					flags |= 1 << 1
				}
				if m.Format != nil {
					flags |= 1 << 2
				}
				if m.BaseTheme != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Theme != nil {
				_ = m.Theme.Encode(x, layer)
			}

			if m.Format != nil {
				x.PutString(*m.Format)
			}

			if m.BaseTheme != nil {
				_ = m.BaseTheme.Encode(x, layer)
			}

			return nil
		},
		0x7ae43737: func() error {
			x.PutClazzID(0x7ae43737)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}
				if m.Format != nil {
					flags |= 1 << 1
				}
				if m.Theme != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Format != nil {
				x.PutString(*m.Format)
			}

			if m.Theme != nil {
				_ = m.Theme.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_installTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_installTheme, layer)
	}
}

// Decode <--
func (m *TLAccountInstallTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc727bb3b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}
			if (flags & (1 << 1)) != 0 {
				m3 := &InputTheme{}
				_ = m3.Decode(d)
				m.Theme = m3
			}
			if (flags & (1 << 2)) != 0 {
				m.Format = new(string)
				*m.Format, err = d.String()
			}

			if (flags & (1 << 3)) != 0 {
				m5 := &BaseTheme{}
				_ = m5.Decode(d)
				m.BaseTheme = m5
			}

			return nil
		},
		0x7ae43737: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Format = new(string)
				*m.Format, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m4 := &InputTheme{}
				_ = m4.Decode(d)
				m.Theme = m4
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetTheme <--
type TLAccountGetTheme struct {
	ClazzID uint32      `json:"_id"`
	Format  string      `json:"format"`
	Theme   *InputTheme `json:"theme"`
}

func (m *TLAccountGetTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3a5869ec: func() error {
			x.PutClazzID(0x3a5869ec)

			x.PutString(m.Format)
			_ = m.Theme.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getTheme, layer)
	}
}

// Decode <--
func (m *TLAccountGetTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3a5869ec: func() (err error) {
			m.Format, err = d.String()

			m2 := &InputTheme{}
			_ = m2.Decode(d)
			m.Theme = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetThemes <--
type TLAccountGetThemes struct {
	ClazzID uint32 `json:"_id"`
	Format  string `json:"format"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetThemes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetThemes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7206e458: func() error {
			x.PutClazzID(0x7206e458)

			x.PutString(m.Format)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getThemes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getThemes, layer)
	}
}

// Decode <--
func (m *TLAccountGetThemes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7206e458: func() (err error) {
			m.Format, err = d.String()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetContentSettings <--
type TLAccountSetContentSettings struct {
	ClazzID          uint32 `json:"_id"`
	SensitiveEnabled bool   `json:"sensitive_enabled"`
}

func (m *TLAccountSetContentSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetContentSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb574b16b: func() error {
			x.PutClazzID(0xb574b16b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SensitiveEnabled == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setContentSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setContentSettings, layer)
	}
}

// Decode <--
func (m *TLAccountSetContentSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb574b16b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.SensitiveEnabled = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetContentSettings <--
type TLAccountGetContentSettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetContentSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetContentSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8b9b4dae: func() error {
			x.PutClazzID(0x8b9b4dae)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getContentSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getContentSettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetContentSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8b9b4dae: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetMultiWallPapers <--
type TLAccountGetMultiWallPapers struct {
	ClazzID    uint32            `json:"_id"`
	Wallpapers []*InputWallPaper `json:"wallpapers"`
}

func (m *TLAccountGetMultiWallPapers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetMultiWallPapers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x65ad71dc: func() error {
			x.PutClazzID(0x65ad71dc)

			_ = iface.EncodeObjectList(x, m.Wallpapers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getMultiWallPapers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getMultiWallPapers, layer)
	}
}

// Decode <--
func (m *TLAccountGetMultiWallPapers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x65ad71dc: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputWallPaper, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputWallPaper)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Wallpapers = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetGlobalPrivacySettings <--
type TLAccountGetGlobalPrivacySettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetGlobalPrivacySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetGlobalPrivacySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xeb2b4cf6: func() error {
			x.PutClazzID(0xeb2b4cf6)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getGlobalPrivacySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getGlobalPrivacySettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetGlobalPrivacySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xeb2b4cf6: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetGlobalPrivacySettings <--
type TLAccountSetGlobalPrivacySettings struct {
	ClazzID  uint32                 `json:"_id"`
	Settings *GlobalPrivacySettings `json:"settings"`
}

func (m *TLAccountSetGlobalPrivacySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetGlobalPrivacySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1edaaac2: func() error {
			x.PutClazzID(0x1edaaac2)

			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setGlobalPrivacySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setGlobalPrivacySettings, layer)
	}
}

// Decode <--
func (m *TLAccountSetGlobalPrivacySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1edaaac2: func() (err error) {

			m1 := &GlobalPrivacySettings{}
			_ = m1.Decode(d)
			m.Settings = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountReportProfilePhoto <--
type TLAccountReportProfilePhoto struct {
	ClazzID uint32        `json:"_id"`
	Peer    *InputPeer    `json:"peer"`
	PhotoId *InputPhoto   `json:"photo_id"`
	Reason  *ReportReason `json:"reason"`
	Message string        `json:"message"`
}

func (m *TLAccountReportProfilePhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountReportProfilePhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfa8cc6f5: func() error {
			x.PutClazzID(0xfa8cc6f5)

			_ = m.Peer.Encode(x, layer)
			_ = m.PhotoId.Encode(x, layer)
			_ = m.Reason.Encode(x, layer)
			x.PutString(m.Message)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_reportProfilePhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_reportProfilePhoto, layer)
	}
}

// Decode <--
func (m *TLAccountReportProfilePhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfa8cc6f5: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputPhoto{}
			_ = m2.Decode(d)
			m.PhotoId = m2

			m3 := &ReportReason{}
			_ = m3.Decode(d)
			m.Reason = m3

			m.Message, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResetPassword <--
type TLAccountResetPassword struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountResetPassword) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResetPassword) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9308ce1b: func() error {
			x.PutClazzID(0x9308ce1b)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resetPassword, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resetPassword, layer)
	}
}

// Decode <--
func (m *TLAccountResetPassword) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9308ce1b: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDeclinePasswordReset <--
type TLAccountDeclinePasswordReset struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountDeclinePasswordReset) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDeclinePasswordReset) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4c9409f6: func() error {
			x.PutClazzID(0x4c9409f6)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_declinePasswordReset, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_declinePasswordReset, layer)
	}
}

// Decode <--
func (m *TLAccountDeclinePasswordReset) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4c9409f6: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetChatThemes <--
type TLAccountGetChatThemes struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetChatThemes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetChatThemes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd638de89: func() error {
			x.PutClazzID(0xd638de89)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getChatThemes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getChatThemes, layer)
	}
}

// Decode <--
func (m *TLAccountGetChatThemes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd638de89: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetAuthorizationTTL <--
type TLAccountSetAuthorizationTTL struct {
	ClazzID              uint32 `json:"_id"`
	AuthorizationTtlDays int32  `json:"authorization_ttl_days"`
}

func (m *TLAccountSetAuthorizationTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetAuthorizationTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbf899aa0: func() error {
			x.PutClazzID(0xbf899aa0)

			x.PutInt32(m.AuthorizationTtlDays)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setAuthorizationTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setAuthorizationTTL, layer)
	}
}

// Decode <--
func (m *TLAccountSetAuthorizationTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbf899aa0: func() (err error) {
			m.AuthorizationTtlDays, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountChangeAuthorizationSettings <--
type TLAccountChangeAuthorizationSettings struct {
	ClazzID                   uint32 `json:"_id"`
	Confirmed                 bool   `json:"confirmed"`
	Hash                      int64  `json:"hash"`
	EncryptedRequestsDisabled *Bool  `json:"encrypted_requests_disabled"`
	CallRequestsDisabled      *Bool  `json:"call_requests_disabled"`
}

func (m *TLAccountChangeAuthorizationSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountChangeAuthorizationSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x40f48462: func() error {
			x.PutClazzID(0x40f48462)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Confirmed == true {
					flags |= 1 << 3
				}

				if m.EncryptedRequestsDisabled != nil {
					flags |= 1 << 0
				}
				if m.CallRequestsDisabled != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.Hash)
			if m.EncryptedRequestsDisabled != nil {
				_ = m.EncryptedRequestsDisabled.Encode(x, layer)
			}

			if m.CallRequestsDisabled != nil {
				_ = m.CallRequestsDisabled.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_changeAuthorizationSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_changeAuthorizationSettings, layer)
	}
}

// Decode <--
func (m *TLAccountChangeAuthorizationSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x40f48462: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 3)) != 0 {
				m.Confirmed = true
			}
			m.Hash, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m4 := &Bool{}
				_ = m4.Decode(d)
				m.EncryptedRequestsDisabled = m4
			}
			if (flags & (1 << 1)) != 0 {
				m5 := &Bool{}
				_ = m5.Decode(d)
				m.CallRequestsDisabled = m5
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetSavedRingtones <--
type TLAccountGetSavedRingtones struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetSavedRingtones) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetSavedRingtones) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe1902288: func() error {
			x.PutClazzID(0xe1902288)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getSavedRingtones, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getSavedRingtones, layer)
	}
}

// Decode <--
func (m *TLAccountGetSavedRingtones) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe1902288: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveRingtone <--
type TLAccountSaveRingtone struct {
	ClazzID uint32         `json:"_id"`
	Id      *InputDocument `json:"id"`
	Unsave  *Bool          `json:"unsave"`
}

func (m *TLAccountSaveRingtone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveRingtone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3dea5b03: func() error {
			x.PutClazzID(0x3dea5b03)

			_ = m.Id.Encode(x, layer)
			_ = m.Unsave.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveRingtone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveRingtone, layer)
	}
}

// Decode <--
func (m *TLAccountSaveRingtone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3dea5b03: func() (err error) {

			m1 := &InputDocument{}
			_ = m1.Decode(d)
			m.Id = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Unsave = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUploadRingtone <--
type TLAccountUploadRingtone struct {
	ClazzID  uint32     `json:"_id"`
	File     *InputFile `json:"file"`
	FileName string     `json:"file_name"`
	MimeType string     `json:"mime_type"`
}

func (m *TLAccountUploadRingtone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUploadRingtone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x831a83a2: func() error {
			x.PutClazzID(0x831a83a2)

			_ = m.File.Encode(x, layer)
			x.PutString(m.FileName)
			x.PutString(m.MimeType)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_uploadRingtone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_uploadRingtone, layer)
	}
}

// Decode <--
func (m *TLAccountUploadRingtone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x831a83a2: func() (err error) {

			m1 := &InputFile{}
			_ = m1.Decode(d)
			m.File = m1

			m.FileName, err = d.String()
			m.MimeType, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateEmojiStatus <--
type TLAccountUpdateEmojiStatus struct {
	ClazzID     uint32       `json:"_id"`
	EmojiStatus *EmojiStatus `json:"emoji_status"`
}

func (m *TLAccountUpdateEmojiStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateEmojiStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfbd3de6b: func() error {
			x.PutClazzID(0xfbd3de6b)

			_ = m.EmojiStatus.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateEmojiStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateEmojiStatus, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateEmojiStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfbd3de6b: func() (err error) {

			m1 := &EmojiStatus{}
			_ = m1.Decode(d)
			m.EmojiStatus = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetDefaultEmojiStatuses <--
type TLAccountGetDefaultEmojiStatuses struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetDefaultEmojiStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetDefaultEmojiStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd6753386: func() error {
			x.PutClazzID(0xd6753386)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getDefaultEmojiStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getDefaultEmojiStatuses, layer)
	}
}

// Decode <--
func (m *TLAccountGetDefaultEmojiStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd6753386: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetRecentEmojiStatuses <--
type TLAccountGetRecentEmojiStatuses struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetRecentEmojiStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetRecentEmojiStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf578105: func() error {
			x.PutClazzID(0xf578105)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getRecentEmojiStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getRecentEmojiStatuses, layer)
	}
}

// Decode <--
func (m *TLAccountGetRecentEmojiStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf578105: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountClearRecentEmojiStatuses <--
type TLAccountClearRecentEmojiStatuses struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountClearRecentEmojiStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountClearRecentEmojiStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x18201aae: func() error {
			x.PutClazzID(0x18201aae)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_clearRecentEmojiStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_clearRecentEmojiStatuses, layer)
	}
}

// Decode <--
func (m *TLAccountClearRecentEmojiStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x18201aae: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountReorderUsernames <--
type TLAccountReorderUsernames struct {
	ClazzID uint32   `json:"_id"`
	Order   []string `json:"order"`
}

func (m *TLAccountReorderUsernames) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountReorderUsernames) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xef500eab: func() error {
			x.PutClazzID(0xef500eab)

			iface.EncodeStringList(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_reorderUsernames, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_reorderUsernames, layer)
	}
}

// Decode <--
func (m *TLAccountReorderUsernames) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xef500eab: func() (err error) {

			m.Order, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountToggleUsername <--
type TLAccountToggleUsername struct {
	ClazzID  uint32 `json:"_id"`
	Username string `json:"username"`
	Active   *Bool  `json:"active"`
}

func (m *TLAccountToggleUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountToggleUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x58d6b376: func() error {
			x.PutClazzID(0x58d6b376)

			x.PutString(m.Username)
			_ = m.Active.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_toggleUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_toggleUsername, layer)
	}
}

// Decode <--
func (m *TLAccountToggleUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x58d6b376: func() (err error) {
			m.Username, err = d.String()

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Active = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetDefaultProfilePhotoEmojis <--
type TLAccountGetDefaultProfilePhotoEmojis struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetDefaultProfilePhotoEmojis) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetDefaultProfilePhotoEmojis) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe2750328: func() error {
			x.PutClazzID(0xe2750328)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getDefaultProfilePhotoEmojis, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getDefaultProfilePhotoEmojis, layer)
	}
}

// Decode <--
func (m *TLAccountGetDefaultProfilePhotoEmojis) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe2750328: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetDefaultGroupPhotoEmojis <--
type TLAccountGetDefaultGroupPhotoEmojis struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetDefaultGroupPhotoEmojis) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetDefaultGroupPhotoEmojis) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x915860ae: func() error {
			x.PutClazzID(0x915860ae)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getDefaultGroupPhotoEmojis, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getDefaultGroupPhotoEmojis, layer)
	}
}

// Decode <--
func (m *TLAccountGetDefaultGroupPhotoEmojis) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x915860ae: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetAutoSaveSettings <--
type TLAccountGetAutoSaveSettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetAutoSaveSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetAutoSaveSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xadcbbcda: func() error {
			x.PutClazzID(0xadcbbcda)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getAutoSaveSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getAutoSaveSettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetAutoSaveSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xadcbbcda: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSaveAutoSaveSettings <--
type TLAccountSaveAutoSaveSettings struct {
	ClazzID    uint32            `json:"_id"`
	Users      bool              `json:"users"`
	Chats      bool              `json:"chats"`
	Broadcasts bool              `json:"broadcasts"`
	Peer       *InputPeer        `json:"peer"`
	Settings   *AutoSaveSettings `json:"settings"`
}

func (m *TLAccountSaveAutoSaveSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSaveAutoSaveSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd69b8361: func() error {
			x.PutClazzID(0xd69b8361)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Users == true {
					flags |= 1 << 0
				}
				if m.Chats == true {
					flags |= 1 << 1
				}
				if m.Broadcasts == true {
					flags |= 1 << 2
				}
				if m.Peer != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_saveAutoSaveSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_saveAutoSaveSettings, layer)
	}
}

// Decode <--
func (m *TLAccountSaveAutoSaveSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd69b8361: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Users = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Chats = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Broadcasts = true
			}
			if (flags & (1 << 3)) != 0 {
				m5 := &InputPeer{}
				_ = m5.Decode(d)
				m.Peer = m5
			}

			m6 := &AutoSaveSettings{}
			_ = m6.Decode(d)
			m.Settings = m6

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDeleteAutoSaveExceptions <--
type TLAccountDeleteAutoSaveExceptions struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountDeleteAutoSaveExceptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDeleteAutoSaveExceptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x53bc0020: func() error {
			x.PutClazzID(0x53bc0020)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_deleteAutoSaveExceptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_deleteAutoSaveExceptions, layer)
	}
}

// Decode <--
func (m *TLAccountDeleteAutoSaveExceptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x53bc0020: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountInvalidateSignInCodes <--
type TLAccountInvalidateSignInCodes struct {
	ClazzID uint32   `json:"_id"`
	Codes   []string `json:"codes"`
}

func (m *TLAccountInvalidateSignInCodes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountInvalidateSignInCodes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xca8ae8ba: func() error {
			x.PutClazzID(0xca8ae8ba)

			iface.EncodeStringList(x, m.Codes)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_invalidateSignInCodes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_invalidateSignInCodes, layer)
	}
}

// Decode <--
func (m *TLAccountInvalidateSignInCodes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xca8ae8ba: func() (err error) {

			m.Codes, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateColor <--
type TLAccountUpdateColor struct {
	ClazzID           uint32 `json:"_id"`
	ForProfile        bool   `json:"for_profile"`
	Color             *int32 `json:"color"`
	BackgroundEmojiId *int64 `json:"background_emoji_id"`
}

func (m *TLAccountUpdateColor) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateColor) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7cefa15d: func() error {
			x.PutClazzID(0x7cefa15d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForProfile == true {
					flags |= 1 << 1
				}
				if m.Color != nil {
					flags |= 1 << 2
				}
				if m.BackgroundEmojiId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Color != nil {
				x.PutInt32(*m.Color)
			}

			if m.BackgroundEmojiId != nil {
				x.PutInt64(*m.BackgroundEmojiId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateColor, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateColor, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateColor) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7cefa15d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.ForProfile = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Color = new(int32)
				*m.Color, err = d.Int32()
			}
			if (flags & (1 << 0)) != 0 {
				m.BackgroundEmojiId = new(int64)
				*m.BackgroundEmojiId, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetDefaultBackgroundEmojis <--
type TLAccountGetDefaultBackgroundEmojis struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetDefaultBackgroundEmojis) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetDefaultBackgroundEmojis) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa60ab9ce: func() error {
			x.PutClazzID(0xa60ab9ce)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getDefaultBackgroundEmojis, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getDefaultBackgroundEmojis, layer)
	}
}

// Decode <--
func (m *TLAccountGetDefaultBackgroundEmojis) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa60ab9ce: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetChannelDefaultEmojiStatuses <--
type TLAccountGetChannelDefaultEmojiStatuses struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetChannelDefaultEmojiStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetChannelDefaultEmojiStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7727a7d5: func() error {
			x.PutClazzID(0x7727a7d5)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getChannelDefaultEmojiStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getChannelDefaultEmojiStatuses, layer)
	}
}

// Decode <--
func (m *TLAccountGetChannelDefaultEmojiStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7727a7d5: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetChannelRestrictedStatusEmojis <--
type TLAccountGetChannelRestrictedStatusEmojis struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetChannelRestrictedStatusEmojis) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetChannelRestrictedStatusEmojis) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x35a9e0d5: func() error {
			x.PutClazzID(0x35a9e0d5)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getChannelRestrictedStatusEmojis, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getChannelRestrictedStatusEmojis, layer)
	}
}

// Decode <--
func (m *TLAccountGetChannelRestrictedStatusEmojis) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x35a9e0d5: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBusinessWorkHours <--
type TLAccountUpdateBusinessWorkHours struct {
	ClazzID           uint32             `json:"_id"`
	BusinessWorkHours *BusinessWorkHours `json:"business_work_hours"`
}

func (m *TLAccountUpdateBusinessWorkHours) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBusinessWorkHours) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4b00e066: func() error {
			x.PutClazzID(0x4b00e066)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.BusinessWorkHours != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.BusinessWorkHours != nil {
				_ = m.BusinessWorkHours.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBusinessWorkHours, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBusinessWorkHours, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBusinessWorkHours) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4b00e066: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &BusinessWorkHours{}
				_ = m2.Decode(d)
				m.BusinessWorkHours = m2
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBusinessLocation <--
type TLAccountUpdateBusinessLocation struct {
	ClazzID  uint32         `json:"_id"`
	GeoPoint *InputGeoPoint `json:"geo_point"`
	Address  *string        `json:"address"`
}

func (m *TLAccountUpdateBusinessLocation) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBusinessLocation) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9e6b131a: func() error {
			x.PutClazzID(0x9e6b131a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.GeoPoint != nil {
					flags |= 1 << 1
				}
				if m.Address != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.GeoPoint != nil {
				_ = m.GeoPoint.Encode(x, layer)
			}

			if m.Address != nil {
				x.PutString(*m.Address)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBusinessLocation, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBusinessLocation, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBusinessLocation) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9e6b131a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m2 := &InputGeoPoint{}
				_ = m2.Decode(d)
				m.GeoPoint = m2
			}
			if (flags & (1 << 0)) != 0 {
				m.Address = new(string)
				*m.Address, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBusinessGreetingMessage <--
type TLAccountUpdateBusinessGreetingMessage struct {
	ClazzID uint32                        `json:"_id"`
	Message *InputBusinessGreetingMessage `json:"message"`
}

func (m *TLAccountUpdateBusinessGreetingMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBusinessGreetingMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x66cdafc4: func() error {
			x.PutClazzID(0x66cdafc4)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Message != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Message != nil {
				_ = m.Message.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBusinessGreetingMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBusinessGreetingMessage, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBusinessGreetingMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x66cdafc4: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &InputBusinessGreetingMessage{}
				_ = m2.Decode(d)
				m.Message = m2
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBusinessAwayMessage <--
type TLAccountUpdateBusinessAwayMessage struct {
	ClazzID uint32                    `json:"_id"`
	Message *InputBusinessAwayMessage `json:"message"`
}

func (m *TLAccountUpdateBusinessAwayMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBusinessAwayMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa26a7fa5: func() error {
			x.PutClazzID(0xa26a7fa5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Message != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Message != nil {
				_ = m.Message.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBusinessAwayMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBusinessAwayMessage, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBusinessAwayMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa26a7fa5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &InputBusinessAwayMessage{}
				_ = m2.Decode(d)
				m.Message = m2
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateConnectedBot <--
type TLAccountUpdateConnectedBot struct {
	ClazzID    uint32                      `json:"_id"`
	Deleted    bool                        `json:"deleted"`
	Rights     *BusinessBotRights          `json:"rights"`
	Bot        *InputUser                  `json:"bot"`
	Recipients *InputBusinessBotRecipients `json:"recipients"`
	CanReply   bool                        `json:"can_reply"`
}

func (m *TLAccountUpdateConnectedBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateConnectedBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x66a08c7e: func() error {
			x.PutClazzID(0x66a08c7e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Deleted == true {
					flags |= 1 << 1
				}
				if m.Rights != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Rights != nil {
				_ = m.Rights.Encode(x, layer)
			}

			_ = m.Bot.Encode(x, layer)
			_ = m.Recipients.Encode(x, layer)

			return nil
		},
		0x43d8521d: func() error {
			x.PutClazzID(0x43d8521d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.CanReply == true {
					flags |= 1 << 0
				}
				if m.Deleted == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Bot.Encode(x, layer)
			_ = m.Recipients.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateConnectedBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateConnectedBot, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateConnectedBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x66a08c7e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Deleted = true
			}
			if (flags & (1 << 0)) != 0 {
				m3 := &BusinessBotRights{}
				_ = m3.Decode(d)
				m.Rights = m3
			}

			m4 := &InputUser{}
			_ = m4.Decode(d)
			m.Bot = m4

			m5 := &InputBusinessBotRecipients{}
			_ = m5.Decode(d)
			m.Recipients = m5

			return nil
		},
		0x43d8521d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.CanReply = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Deleted = true
			}

			m4 := &InputUser{}
			_ = m4.Decode(d)
			m.Bot = m4

			m5 := &InputBusinessBotRecipients{}
			_ = m5.Decode(d)
			m.Recipients = m5

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetConnectedBots <--
type TLAccountGetConnectedBots struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetConnectedBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetConnectedBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4ea4c80f: func() error {
			x.PutClazzID(0x4ea4c80f)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getConnectedBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getConnectedBots, layer)
	}
}

// Decode <--
func (m *TLAccountGetConnectedBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4ea4c80f: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetBotBusinessConnection <--
type TLAccountGetBotBusinessConnection struct {
	ClazzID      uint32 `json:"_id"`
	ConnectionId string `json:"connection_id"`
}

func (m *TLAccountGetBotBusinessConnection) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetBotBusinessConnection) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x76a86270: func() error {
			x.PutClazzID(0x76a86270)

			x.PutString(m.ConnectionId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getBotBusinessConnection, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getBotBusinessConnection, layer)
	}
}

// Decode <--
func (m *TLAccountGetBotBusinessConnection) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x76a86270: func() (err error) {
			m.ConnectionId, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBusinessIntro <--
type TLAccountUpdateBusinessIntro struct {
	ClazzID uint32              `json:"_id"`
	Intro   *InputBusinessIntro `json:"intro"`
}

func (m *TLAccountUpdateBusinessIntro) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBusinessIntro) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa614d034: func() error {
			x.PutClazzID(0xa614d034)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Intro != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Intro != nil {
				_ = m.Intro.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBusinessIntro, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBusinessIntro, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBusinessIntro) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa614d034: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &InputBusinessIntro{}
				_ = m2.Decode(d)
				m.Intro = m2
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountToggleConnectedBotPaused <--
type TLAccountToggleConnectedBotPaused struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Paused  *Bool      `json:"paused"`
}

func (m *TLAccountToggleConnectedBotPaused) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountToggleConnectedBotPaused) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x646e1097: func() error {
			x.PutClazzID(0x646e1097)

			_ = m.Peer.Encode(x, layer)
			_ = m.Paused.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_toggleConnectedBotPaused, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_toggleConnectedBotPaused, layer)
	}
}

// Decode <--
func (m *TLAccountToggleConnectedBotPaused) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x646e1097: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Paused = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDisablePeerConnectedBot <--
type TLAccountDisablePeerConnectedBot struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLAccountDisablePeerConnectedBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDisablePeerConnectedBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5e437ed9: func() error {
			x.PutClazzID(0x5e437ed9)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_disablePeerConnectedBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_disablePeerConnectedBot, layer)
	}
}

// Decode <--
func (m *TLAccountDisablePeerConnectedBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5e437ed9: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateBirthday <--
type TLAccountUpdateBirthday struct {
	ClazzID  uint32    `json:"_id"`
	Birthday *Birthday `json:"birthday"`
}

func (m *TLAccountUpdateBirthday) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateBirthday) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcc6e0c11: func() error {
			x.PutClazzID(0xcc6e0c11)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Birthday != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Birthday != nil {
				_ = m.Birthday.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateBirthday, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateBirthday, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateBirthday) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcc6e0c11: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &Birthday{}
				_ = m2.Decode(d)
				m.Birthday = m2
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountCreateBusinessChatLink <--
type TLAccountCreateBusinessChatLink struct {
	ClazzID uint32                 `json:"_id"`
	Link    *InputBusinessChatLink `json:"link"`
}

func (m *TLAccountCreateBusinessChatLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountCreateBusinessChatLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8851e68e: func() error {
			x.PutClazzID(0x8851e68e)

			_ = m.Link.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_createBusinessChatLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_createBusinessChatLink, layer)
	}
}

// Decode <--
func (m *TLAccountCreateBusinessChatLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8851e68e: func() (err error) {

			m1 := &InputBusinessChatLink{}
			_ = m1.Decode(d)
			m.Link = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountEditBusinessChatLink <--
type TLAccountEditBusinessChatLink struct {
	ClazzID uint32                 `json:"_id"`
	Slug    string                 `json:"slug"`
	Link    *InputBusinessChatLink `json:"link"`
}

func (m *TLAccountEditBusinessChatLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountEditBusinessChatLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8c3410af: func() error {
			x.PutClazzID(0x8c3410af)

			x.PutString(m.Slug)
			_ = m.Link.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_editBusinessChatLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_editBusinessChatLink, layer)
	}
}

// Decode <--
func (m *TLAccountEditBusinessChatLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8c3410af: func() (err error) {
			m.Slug, err = d.String()

			m2 := &InputBusinessChatLink{}
			_ = m2.Decode(d)
			m.Link = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountDeleteBusinessChatLink <--
type TLAccountDeleteBusinessChatLink struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLAccountDeleteBusinessChatLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountDeleteBusinessChatLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x60073674: func() error {
			x.PutClazzID(0x60073674)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_deleteBusinessChatLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_deleteBusinessChatLink, layer)
	}
}

// Decode <--
func (m *TLAccountDeleteBusinessChatLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x60073674: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetBusinessChatLinks <--
type TLAccountGetBusinessChatLinks struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetBusinessChatLinks) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetBusinessChatLinks) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6f70dde1: func() error {
			x.PutClazzID(0x6f70dde1)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getBusinessChatLinks, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getBusinessChatLinks, layer)
	}
}

// Decode <--
func (m *TLAccountGetBusinessChatLinks) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6f70dde1: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountResolveBusinessChatLink <--
type TLAccountResolveBusinessChatLink struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLAccountResolveBusinessChatLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountResolveBusinessChatLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5492e5ee: func() error {
			x.PutClazzID(0x5492e5ee)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_resolveBusinessChatLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_resolveBusinessChatLink, layer)
	}
}

// Decode <--
func (m *TLAccountResolveBusinessChatLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5492e5ee: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdatePersonalChannel <--
type TLAccountUpdatePersonalChannel struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
}

func (m *TLAccountUpdatePersonalChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdatePersonalChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd94305e0: func() error {
			x.PutClazzID(0xd94305e0)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updatePersonalChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updatePersonalChannel, layer)
	}
}

// Decode <--
func (m *TLAccountUpdatePersonalChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd94305e0: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountToggleSponsoredMessages <--
type TLAccountToggleSponsoredMessages struct {
	ClazzID uint32 `json:"_id"`
	Enabled *Bool  `json:"enabled"`
}

func (m *TLAccountToggleSponsoredMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountToggleSponsoredMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb9d9a38d: func() error {
			x.PutClazzID(0xb9d9a38d)

			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_toggleSponsoredMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_toggleSponsoredMessages, layer)
	}
}

// Decode <--
func (m *TLAccountToggleSponsoredMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb9d9a38d: func() (err error) {

			m1 := &Bool{}
			_ = m1.Decode(d)
			m.Enabled = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetReactionsNotifySettings <--
type TLAccountGetReactionsNotifySettings struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLAccountGetReactionsNotifySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetReactionsNotifySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6dd654c: func() error {
			x.PutClazzID(0x6dd654c)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getReactionsNotifySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getReactionsNotifySettings, layer)
	}
}

// Decode <--
func (m *TLAccountGetReactionsNotifySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6dd654c: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountSetReactionsNotifySettings <--
type TLAccountSetReactionsNotifySettings struct {
	ClazzID  uint32                   `json:"_id"`
	Settings *ReactionsNotifySettings `json:"settings"`
}

func (m *TLAccountSetReactionsNotifySettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountSetReactionsNotifySettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x316ce548: func() error {
			x.PutClazzID(0x316ce548)

			_ = m.Settings.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_setReactionsNotifySettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_setReactionsNotifySettings, layer)
	}
}

// Decode <--
func (m *TLAccountSetReactionsNotifySettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x316ce548: func() (err error) {

			m1 := &ReactionsNotifySettings{}
			_ = m1.Decode(d)
			m.Settings = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetCollectibleEmojiStatuses <--
type TLAccountGetCollectibleEmojiStatuses struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLAccountGetCollectibleEmojiStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetCollectibleEmojiStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2e7b4543: func() error {
			x.PutClazzID(0x2e7b4543)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getCollectibleEmojiStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getCollectibleEmojiStatuses, layer)
	}
}

// Decode <--
func (m *TLAccountGetCollectibleEmojiStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2e7b4543: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountAddNoPaidMessagesException <--
type TLAccountAddNoPaidMessagesException struct {
	ClazzID       uint32     `json:"_id"`
	RefundCharged bool       `json:"refund_charged"`
	UserId        *InputUser `json:"user_id"`
}

func (m *TLAccountAddNoPaidMessagesException) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountAddNoPaidMessagesException) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6f688aa7: func() error {
			x.PutClazzID(0x6f688aa7)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.RefundCharged == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_addNoPaidMessagesException, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_addNoPaidMessagesException, layer)
	}
}

// Decode <--
func (m *TLAccountAddNoPaidMessagesException) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6f688aa7: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.RefundCharged = true
			}

			m3 := &InputUser{}
			_ = m3.Decode(d)
			m.UserId = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountGetPaidMessagesRevenue <--
type TLAccountGetPaidMessagesRevenue struct {
	ClazzID uint32     `json:"_id"`
	UserId  *InputUser `json:"user_id"`
}

func (m *TLAccountGetPaidMessagesRevenue) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountGetPaidMessagesRevenue) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf1266f38: func() error {
			x.PutClazzID(0xf1266f38)

			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_getPaidMessagesRevenue, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_getPaidMessagesRevenue, layer)
	}
}

// Decode <--
func (m *TLAccountGetPaidMessagesRevenue) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf1266f38: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.UserId = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetUsers <--
type TLUsersGetUsers struct {
	ClazzID uint32       `json:"_id"`
	Id      []*InputUser `json:"id"`
}

func (m *TLUsersGetUsers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetUsers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd91a548: func() error {
			x.PutClazzID(0xd91a548)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getUsers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getUsers, layer)
	}
}

// Decode <--
func (m *TLUsersGetUsers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd91a548: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputUser, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputUser)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetFullUser <--
type TLUsersGetFullUser struct {
	ClazzID uint32     `json:"_id"`
	Id      *InputUser `json:"id"`
}

func (m *TLUsersGetFullUser) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetFullUser) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb60f5918: func() error {
			x.PutClazzID(0xb60f5918)

			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getFullUser, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getFullUser, layer)
	}
}

// Decode <--
func (m *TLUsersGetFullUser) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb60f5918: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Id = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersSetSecureValueErrors <--
type TLUsersSetSecureValueErrors struct {
	ClazzID uint32              `json:"_id"`
	Id      *InputUser          `json:"id"`
	Errors  []*SecureValueError `json:"errors"`
}

func (m *TLUsersSetSecureValueErrors) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersSetSecureValueErrors) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x90c894b5: func() error {
			x.PutClazzID(0x90c894b5)

			_ = m.Id.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Errors, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_setSecureValueErrors, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_setSecureValueErrors, layer)
	}
}

// Decode <--
func (m *TLUsersSetSecureValueErrors) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x90c894b5: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Id = m1

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*SecureValueError, l2)
			for i := 0; i < l2; i++ {
				vv := new(SecureValueError)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Errors = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetRequirementsToContact <--
type TLUsersGetRequirementsToContact struct {
	ClazzID uint32       `json:"_id"`
	Id      []*InputUser `json:"id"`
}

func (m *TLUsersGetRequirementsToContact) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetRequirementsToContact) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd89a83a3: func() error {
			x.PutClazzID(0xd89a83a3)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getRequirementsToContact, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getRequirementsToContact, layer)
	}
}

// Decode <--
func (m *TLUsersGetRequirementsToContact) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd89a83a3: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputUser, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputUser)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetContactIDs <--
type TLContactsGetContactIDs struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLContactsGetContactIDs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetContactIDs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7adc669d: func() error {
			x.PutClazzID(0x7adc669d)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getContactIDs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getContactIDs, layer)
	}
}

// Decode <--
func (m *TLContactsGetContactIDs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7adc669d: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetStatuses <--
type TLContactsGetStatuses struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLContactsGetStatuses) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetStatuses) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc4a353ee: func() error {
			x.PutClazzID(0xc4a353ee)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getStatuses, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getStatuses, layer)
	}
}

// Decode <--
func (m *TLContactsGetStatuses) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc4a353ee: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetContacts <--
type TLContactsGetContacts struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLContactsGetContacts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetContacts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5dd69e12: func() error {
			x.PutClazzID(0x5dd69e12)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getContacts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getContacts, layer)
	}
}

// Decode <--
func (m *TLContactsGetContacts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5dd69e12: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsImportContacts <--
type TLContactsImportContacts struct {
	ClazzID  uint32          `json:"_id"`
	Contacts []*InputContact `json:"contacts"`
}

func (m *TLContactsImportContacts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsImportContacts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2c800be5: func() error {
			x.PutClazzID(0x2c800be5)

			_ = iface.EncodeObjectList(x, m.Contacts, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_importContacts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_importContacts, layer)
	}
}

// Decode <--
func (m *TLContactsImportContacts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2c800be5: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputContact, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputContact)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Contacts = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsDeleteContacts <--
type TLContactsDeleteContacts struct {
	ClazzID uint32       `json:"_id"`
	Id      []*InputUser `json:"id"`
}

func (m *TLContactsDeleteContacts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsDeleteContacts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x96a0e00: func() error {
			x.PutClazzID(0x96a0e00)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_deleteContacts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_deleteContacts, layer)
	}
}

// Decode <--
func (m *TLContactsDeleteContacts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x96a0e00: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputUser, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputUser)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsDeleteByPhones <--
type TLContactsDeleteByPhones struct {
	ClazzID uint32   `json:"_id"`
	Phones  []string `json:"phones"`
}

func (m *TLContactsDeleteByPhones) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsDeleteByPhones) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1013fd9e: func() error {
			x.PutClazzID(0x1013fd9e)

			iface.EncodeStringList(x, m.Phones)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_deleteByPhones, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_deleteByPhones, layer)
	}
}

// Decode <--
func (m *TLContactsDeleteByPhones) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1013fd9e: func() (err error) {

			m.Phones, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsBlock <--
type TLContactsBlock struct {
	ClazzID       uint32     `json:"_id"`
	MyStoriesFrom bool       `json:"my_stories_from"`
	Id            *InputPeer `json:"id"`
}

func (m *TLContactsBlock) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsBlock) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2e2e8734: func() error {
			x.PutClazzID(0x2e2e8734)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MyStoriesFrom == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_block, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_block, layer)
	}
}

// Decode <--
func (m *TLContactsBlock) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2e2e8734: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.MyStoriesFrom = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Id = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsUnblock <--
type TLContactsUnblock struct {
	ClazzID       uint32     `json:"_id"`
	MyStoriesFrom bool       `json:"my_stories_from"`
	Id            *InputPeer `json:"id"`
}

func (m *TLContactsUnblock) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsUnblock) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb550d328: func() error {
			x.PutClazzID(0xb550d328)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MyStoriesFrom == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_unblock, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_unblock, layer)
	}
}

// Decode <--
func (m *TLContactsUnblock) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb550d328: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.MyStoriesFrom = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Id = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetBlocked <--
type TLContactsGetBlocked struct {
	ClazzID       uint32 `json:"_id"`
	MyStoriesFrom bool   `json:"my_stories_from"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (m *TLContactsGetBlocked) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetBlocked) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9a868f80: func() error {
			x.PutClazzID(0x9a868f80)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MyStoriesFrom == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getBlocked, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getBlocked, layer)
	}
}

// Decode <--
func (m *TLContactsGetBlocked) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9a868f80: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.MyStoriesFrom = true
			}
			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsSearch <--
type TLContactsSearch struct {
	ClazzID uint32 `json:"_id"`
	Q       string `json:"q"`
	Limit   int32  `json:"limit"`
}

func (m *TLContactsSearch) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsSearch) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x11f812d8: func() error {
			x.PutClazzID(0x11f812d8)

			x.PutString(m.Q)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_search, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_search, layer)
	}
}

// Decode <--
func (m *TLContactsSearch) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x11f812d8: func() (err error) {
			m.Q, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsResolveUsername <--
type TLContactsResolveUsername struct {
	ClazzID  uint32  `json:"_id"`
	Username string  `json:"username"`
	Referer  *string `json:"referer"`
}

func (m *TLContactsResolveUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsResolveUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x725afbbc: func() error {
			x.PutClazzID(0x725afbbc)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Referer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Username)
			if m.Referer != nil {
				x.PutString(*m.Referer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_resolveUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_resolveUsername, layer)
	}
}

// Decode <--
func (m *TLContactsResolveUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x725afbbc: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Username, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.Referer = new(string)
				*m.Referer, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetTopPeers <--
type TLContactsGetTopPeers struct {
	ClazzID        uint32 `json:"_id"`
	Correspondents bool   `json:"correspondents"`
	BotsPm         bool   `json:"bots_pm"`
	BotsInline     bool   `json:"bots_inline"`
	PhoneCalls     bool   `json:"phone_calls"`
	ForwardUsers   bool   `json:"forward_users"`
	ForwardChats   bool   `json:"forward_chats"`
	Groups         bool   `json:"groups"`
	Channels       bool   `json:"channels"`
	BotsApp        bool   `json:"bots_app"`
	Offset         int32  `json:"offset"`
	Limit          int32  `json:"limit"`
	Hash           int64  `json:"hash"`
}

func (m *TLContactsGetTopPeers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetTopPeers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x973478b6: func() error {
			x.PutClazzID(0x973478b6)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Correspondents == true {
					flags |= 1 << 0
				}
				if m.BotsPm == true {
					flags |= 1 << 1
				}
				if m.BotsInline == true {
					flags |= 1 << 2
				}
				if m.PhoneCalls == true {
					flags |= 1 << 3
				}
				if m.ForwardUsers == true {
					flags |= 1 << 4
				}
				if m.ForwardChats == true {
					flags |= 1 << 5
				}
				if m.Groups == true {
					flags |= 1 << 10
				}
				if m.Channels == true {
					flags |= 1 << 15
				}
				if m.BotsApp == true {
					flags |= 1 << 16
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getTopPeers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getTopPeers, layer)
	}
}

// Decode <--
func (m *TLContactsGetTopPeers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x973478b6: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Correspondents = true
			}
			if (flags & (1 << 1)) != 0 {
				m.BotsPm = true
			}
			if (flags & (1 << 2)) != 0 {
				m.BotsInline = true
			}
			if (flags & (1 << 3)) != 0 {
				m.PhoneCalls = true
			}
			if (flags & (1 << 4)) != 0 {
				m.ForwardUsers = true
			}
			if (flags & (1 << 5)) != 0 {
				m.ForwardChats = true
			}
			if (flags & (1 << 10)) != 0 {
				m.Groups = true
			}
			if (flags & (1 << 15)) != 0 {
				m.Channels = true
			}
			if (flags & (1 << 16)) != 0 {
				m.BotsApp = true
			}
			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsResetTopPeerRating <--
type TLContactsResetTopPeerRating struct {
	ClazzID  uint32           `json:"_id"`
	Category *TopPeerCategory `json:"category"`
	Peer     *InputPeer       `json:"peer"`
}

func (m *TLContactsResetTopPeerRating) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsResetTopPeerRating) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1ae373ac: func() error {
			x.PutClazzID(0x1ae373ac)

			_ = m.Category.Encode(x, layer)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_resetTopPeerRating, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_resetTopPeerRating, layer)
	}
}

// Decode <--
func (m *TLContactsResetTopPeerRating) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1ae373ac: func() (err error) {

			m1 := &TopPeerCategory{}
			_ = m1.Decode(d)
			m.Category = m1

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsResetSaved <--
type TLContactsResetSaved struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLContactsResetSaved) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsResetSaved) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x879537f1: func() error {
			x.PutClazzID(0x879537f1)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_resetSaved, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_resetSaved, layer)
	}
}

// Decode <--
func (m *TLContactsResetSaved) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x879537f1: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetSaved <--
type TLContactsGetSaved struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLContactsGetSaved) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetSaved) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x82f1e39f: func() error {
			x.PutClazzID(0x82f1e39f)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getSaved, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getSaved, layer)
	}
}

// Decode <--
func (m *TLContactsGetSaved) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x82f1e39f: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsToggleTopPeers <--
type TLContactsToggleTopPeers struct {
	ClazzID uint32 `json:"_id"`
	Enabled *Bool  `json:"enabled"`
}

func (m *TLContactsToggleTopPeers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsToggleTopPeers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8514bdda: func() error {
			x.PutClazzID(0x8514bdda)

			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_toggleTopPeers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_toggleTopPeers, layer)
	}
}

// Decode <--
func (m *TLContactsToggleTopPeers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8514bdda: func() (err error) {

			m1 := &Bool{}
			_ = m1.Decode(d)
			m.Enabled = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsAddContact <--
type TLContactsAddContact struct {
	ClazzID                  uint32     `json:"_id"`
	AddPhonePrivacyException bool       `json:"add_phone_privacy_exception"`
	Id                       *InputUser `json:"id"`
	FirstName                string     `json:"first_name"`
	LastName                 string     `json:"last_name"`
	Phone                    string     `json:"phone"`
}

func (m *TLContactsAddContact) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsAddContact) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe8f463d0: func() error {
			x.PutClazzID(0xe8f463d0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.AddPhonePrivacyException == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)
			x.PutString(m.FirstName)
			x.PutString(m.LastName)
			x.PutString(m.Phone)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_addContact, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_addContact, layer)
	}
}

// Decode <--
func (m *TLContactsAddContact) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe8f463d0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.AddPhonePrivacyException = true
			}

			m3 := &InputUser{}
			_ = m3.Decode(d)
			m.Id = m3

			m.FirstName, err = d.String()
			m.LastName, err = d.String()
			m.Phone, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsAcceptContact <--
type TLContactsAcceptContact struct {
	ClazzID uint32     `json:"_id"`
	Id      *InputUser `json:"id"`
}

func (m *TLContactsAcceptContact) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsAcceptContact) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf831a20f: func() error {
			x.PutClazzID(0xf831a20f)

			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_acceptContact, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_acceptContact, layer)
	}
}

// Decode <--
func (m *TLContactsAcceptContact) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf831a20f: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Id = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetLocated <--
type TLContactsGetLocated struct {
	ClazzID     uint32         `json:"_id"`
	Background  bool           `json:"background"`
	GeoPoint    *InputGeoPoint `json:"geo_point"`
	SelfExpires *int32         `json:"self_expires"`
}

func (m *TLContactsGetLocated) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetLocated) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd348bc44: func() error {
			x.PutClazzID(0xd348bc44)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Background == true {
					flags |= 1 << 1
				}

				if m.SelfExpires != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.GeoPoint.Encode(x, layer)
			if m.SelfExpires != nil {
				x.PutInt32(*m.SelfExpires)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getLocated, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getLocated, layer)
	}
}

// Decode <--
func (m *TLContactsGetLocated) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd348bc44: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Background = true
			}

			m3 := &InputGeoPoint{}
			_ = m3.Decode(d)
			m.GeoPoint = m3

			if (flags & (1 << 0)) != 0 {
				m.SelfExpires = new(int32)
				*m.SelfExpires, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsBlockFromReplies <--
type TLContactsBlockFromReplies struct {
	ClazzID       uint32 `json:"_id"`
	DeleteMessage bool   `json:"delete_message"`
	DeleteHistory bool   `json:"delete_history"`
	ReportSpam    bool   `json:"report_spam"`
	MsgId         int32  `json:"msg_id"`
}

func (m *TLContactsBlockFromReplies) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsBlockFromReplies) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x29a8962c: func() error {
			x.PutClazzID(0x29a8962c)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.DeleteMessage == true {
					flags |= 1 << 0
				}
				if m.DeleteHistory == true {
					flags |= 1 << 1
				}
				if m.ReportSpam == true {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_blockFromReplies, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_blockFromReplies, layer)
	}
}

// Decode <--
func (m *TLContactsBlockFromReplies) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x29a8962c: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.DeleteMessage = true
			}
			if (flags & (1 << 1)) != 0 {
				m.DeleteHistory = true
			}
			if (flags & (1 << 2)) != 0 {
				m.ReportSpam = true
			}
			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsResolvePhone <--
type TLContactsResolvePhone struct {
	ClazzID uint32 `json:"_id"`
	Phone   string `json:"phone"`
}

func (m *TLContactsResolvePhone) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsResolvePhone) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8af94344: func() error {
			x.PutClazzID(0x8af94344)

			x.PutString(m.Phone)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_resolvePhone, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_resolvePhone, layer)
	}
}

// Decode <--
func (m *TLContactsResolvePhone) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8af94344: func() (err error) {
			m.Phone, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsExportContactToken <--
type TLContactsExportContactToken struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLContactsExportContactToken) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsExportContactToken) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf8654027: func() error {
			x.PutClazzID(0xf8654027)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_exportContactToken, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_exportContactToken, layer)
	}
}

// Decode <--
func (m *TLContactsExportContactToken) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf8654027: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsImportContactToken <--
type TLContactsImportContactToken struct {
	ClazzID uint32 `json:"_id"`
	Token   string `json:"token"`
}

func (m *TLContactsImportContactToken) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsImportContactToken) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x13005788: func() error {
			x.PutClazzID(0x13005788)

			x.PutString(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_importContactToken, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_importContactToken, layer)
	}
}

// Decode <--
func (m *TLContactsImportContactToken) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x13005788: func() (err error) {
			m.Token, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsEditCloseFriends <--
type TLContactsEditCloseFriends struct {
	ClazzID uint32  `json:"_id"`
	Id      []int64 `json:"id"`
}

func (m *TLContactsEditCloseFriends) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsEditCloseFriends) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xba6705f0: func() error {
			x.PutClazzID(0xba6705f0)

			iface.EncodeInt64List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_editCloseFriends, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_editCloseFriends, layer)
	}
}

// Decode <--
func (m *TLContactsEditCloseFriends) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xba6705f0: func() (err error) {

			m.Id, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsSetBlocked <--
type TLContactsSetBlocked struct {
	ClazzID       uint32       `json:"_id"`
	MyStoriesFrom bool         `json:"my_stories_from"`
	Id            []*InputPeer `json:"id"`
	Limit         int32        `json:"limit"`
}

func (m *TLContactsSetBlocked) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsSetBlocked) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x94c65c76: func() error {
			x.PutClazzID(0x94c65c76)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MyStoriesFrom == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_setBlocked, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_setBlocked, layer)
	}
}

// Decode <--
func (m *TLContactsSetBlocked) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x94c65c76: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.MyStoriesFrom = true
			}
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			v3 := make([]*InputPeer, l3)
			for i := 0; i < l3; i++ {
				vv := new(InputPeer)
				err3 = vv.Decode(d)
				_ = err3
				v3[i] = vv
			}
			m.Id = v3

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetBirthdays <--
type TLContactsGetBirthdays struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLContactsGetBirthdays) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetBirthdays) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdaeda864: func() error {
			x.PutClazzID(0xdaeda864)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getBirthdays, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getBirthdays, layer)
	}
}

// Decode <--
func (m *TLContactsGetBirthdays) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdaeda864: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLContactsGetSponsoredPeers <--
type TLContactsGetSponsoredPeers struct {
	ClazzID uint32 `json:"_id"`
	Q       string `json:"q"`
}

func (m *TLContactsGetSponsoredPeers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLContactsGetSponsoredPeers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb6c8c393: func() error {
			x.PutClazzID(0xb6c8c393)

			x.PutString(m.Q)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_contacts_getSponsoredPeers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_contacts_getSponsoredPeers, layer)
	}
}

// Decode <--
func (m *TLContactsGetSponsoredPeers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb6c8c393: func() (err error) {
			m.Q, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessages <--
type TLMessagesGetMessages struct {
	ClazzID               uint32          `json:"_id"`
	Id_VECTORINPUTMESSAGE []*InputMessage `json:"id_VECTORINPUTMESSAGE"`
	Id_VECTORINT32        []int32         `json:"id_VECTORINT32"`
}

func (m *TLMessagesGetMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x63c66506: func() error {
			x.PutClazzID(0x63c66506)

			_ = iface.EncodeObjectList(x, m.Id_VECTORINPUTMESSAGE, layer)

			return nil
		},
		0x4222fa74: func() error {
			x.PutClazzID(0x4222fa74)

			iface.EncodeInt32List(x, m.Id_VECTORINT32)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x63c66506: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputMessage, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputMessage)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Id_VECTORINPUTMESSAGE = v1

			return nil
		},
		0x4222fa74: func() (err error) {

			m.Id_VECTORINT32, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDialogs <--
type TLMessagesGetDialogs struct {
	ClazzID       uint32     `json:"_id"`
	ExcludePinned bool       `json:"exclude_pinned"`
	FolderId      *int32     `json:"folder_id"`
	OffsetDate    int32      `json:"offset_date"`
	OffsetId      int32      `json:"offset_id"`
	OffsetPeer    *InputPeer `json:"offset_peer"`
	Limit         int32      `json:"limit"`
	Hash          int64      `json:"hash"`
}

func (m *TLMessagesGetDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa0f4cb4f: func() error {
			x.PutClazzID(0xa0f4cb4f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ExcludePinned == true {
					flags |= 1 << 0
				}
				if m.FolderId != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.FolderId != nil {
				x.PutInt32(*m.FolderId)
			}

			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.OffsetId)
			_ = m.OffsetPeer.Encode(x, layer)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa0f4cb4f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ExcludePinned = true
			}
			if (flags & (1 << 1)) != 0 {
				m.FolderId = new(int32)
				*m.FolderId, err = d.Int32()
			}
			m.OffsetDate, err = d.Int32()
			m.OffsetId, err = d.Int32()

			m6 := &InputPeer{}
			_ = m6.Decode(d)
			m.OffsetPeer = m6

			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetHistory <--
type TLMessagesGetHistory struct {
	ClazzID    uint32     `json:"_id"`
	Peer       *InputPeer `json:"peer"`
	OffsetId   int32      `json:"offset_id"`
	OffsetDate int32      `json:"offset_date"`
	AddOffset  int32      `json:"add_offset"`
	Limit      int32      `json:"limit"`
	MaxId      int32      `json:"max_id"`
	MinId      int32      `json:"min_id"`
	Hash       int64      `json:"hash"`
}

func (m *TLMessagesGetHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4423e6c5: func() error {
			x.PutClazzID(0x4423e6c5)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesGetHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4423e6c5: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.OffsetId, err = d.Int32()
			m.OffsetDate, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearch <--
type TLMessagesSearch struct {
	ClazzID       uint32          `json:"_id"`
	Peer          *InputPeer      `json:"peer"`
	Q             string          `json:"q"`
	FromId        *InputPeer      `json:"from_id"`
	SavedPeerId   *InputPeer      `json:"saved_peer_id"`
	SavedReaction []*Reaction     `json:"saved_reaction"`
	TopMsgId      *int32          `json:"top_msg_id"`
	Filter        *MessagesFilter `json:"filter"`
	MinDate       int32           `json:"min_date"`
	MaxDate       int32           `json:"max_date"`
	OffsetId      int32           `json:"offset_id"`
	AddOffset     int32           `json:"add_offset"`
	Limit         int32           `json:"limit"`
	MaxId         int32           `json:"max_id"`
	MinId         int32           `json:"min_id"`
	Hash          int64           `json:"hash"`
}

func (m *TLMessagesSearch) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearch) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x29ee847a: func() error {
			x.PutClazzID(0x29ee847a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FromId != nil {
					flags |= 1 << 0
				}
				if m.SavedPeerId != nil {
					flags |= 1 << 2
				}
				if m.SavedReaction != nil {
					flags |= 1 << 3
				}
				if m.TopMsgId != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Q)
			if m.FromId != nil {
				_ = m.FromId.Encode(x, layer)
			}

			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			if m.SavedReaction != nil {
				_ = iface.EncodeObjectList(x, m.SavedReaction, layer)
			}
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.MinDate)
			x.PutInt32(m.MaxDate)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_search, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_search, layer)
	}
}

// Decode <--
func (m *TLMessagesSearch) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x29ee847a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			m.Q, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m4 := &InputPeer{}
				_ = m4.Decode(d)
				m.FromId = m4
			}
			if (flags & (1 << 2)) != 0 {
				m5 := &InputPeer{}
				_ = m5.Decode(d)
				m.SavedPeerId = m5
			}
			if (flags & (1 << 3)) != 0 {
				c6, err2 := d.ClazzID()
				if c6 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 6, c6)
					return err2
				}
				l6, err3 := d.Int()
				v6 := make([]*Reaction, l6)
				for i := 0; i < l6; i++ {
					vv := new(Reaction)
					err3 = vv.Decode(d)
					_ = err3
					v6[i] = vv
				}
				m.SavedReaction = v6
			}
			if (flags & (1 << 1)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}

			m8 := &MessagesFilter{}
			_ = m8.Decode(d)
			m.Filter = m8

			m.MinDate, err = d.Int32()
			m.MaxDate, err = d.Int32()
			m.OffsetId, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadHistory <--
type TLMessagesReadHistory struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MaxId   int32      `json:"max_id"`
}

func (m *TLMessagesReadHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe306d3a: func() error {
			x.PutClazzID(0xe306d3a)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesReadHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe306d3a: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteHistory <--
type TLMessagesDeleteHistory struct {
	ClazzID   uint32     `json:"_id"`
	JustClear bool       `json:"just_clear"`
	Revoke    bool       `json:"revoke"`
	Peer      *InputPeer `json:"peer"`
	MaxId     int32      `json:"max_id"`
	MinDate   *int32     `json:"min_date"`
	MaxDate   *int32     `json:"max_date"`
}

func (m *TLMessagesDeleteHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb08f922a: func() error {
			x.PutClazzID(0xb08f922a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.JustClear == true {
					flags |= 1 << 0
				}
				if m.Revoke == true {
					flags |= 1 << 1
				}

				if m.MinDate != nil {
					flags |= 1 << 2
				}
				if m.MaxDate != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxId)
			if m.MinDate != nil {
				x.PutInt32(*m.MinDate)
			}

			if m.MaxDate != nil {
				x.PutInt32(*m.MaxDate)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb08f922a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.JustClear = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Revoke = true
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			m.MaxId, err = d.Int32()
			if (flags & (1 << 2)) != 0 {
				m.MinDate = new(int32)
				*m.MinDate, err = d.Int32()
			}
			if (flags & (1 << 3)) != 0 {
				m.MaxDate = new(int32)
				*m.MaxDate, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteMessages <--
type TLMessagesDeleteMessages struct {
	ClazzID uint32  `json:"_id"`
	Revoke  bool    `json:"revoke"`
	Id      []int32 `json:"id"`
}

func (m *TLMessagesDeleteMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe58e95d2: func() error {
			x.PutClazzID(0xe58e95d2)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Revoke == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe58e95d2: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Revoke = true
			}

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReceivedMessages <--
type TLMessagesReceivedMessages struct {
	ClazzID uint32 `json:"_id"`
	MaxId   int32  `json:"max_id"`
}

func (m *TLMessagesReceivedMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReceivedMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5a954c0: func() error {
			x.PutClazzID(0x5a954c0)

			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_receivedMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_receivedMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesReceivedMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5a954c0: func() (err error) {
			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetTyping <--
type TLMessagesSetTyping struct {
	ClazzID  uint32             `json:"_id"`
	Peer     *InputPeer         `json:"peer"`
	TopMsgId *int32             `json:"top_msg_id"`
	Action   *SendMessageAction `json:"action"`
}

func (m *TLMessagesSetTyping) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetTyping) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x58943ee2: func() error {
			x.PutClazzID(0x58943ee2)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			_ = m.Action.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setTyping, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setTyping, layer)
	}
}

// Decode <--
func (m *TLMessagesSetTyping) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x58943ee2: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}

			m4 := &SendMessageAction{}
			_ = m4.Decode(d)
			m.Action = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendMessage <--
type TLMessagesSendMessage struct {
	ClazzID                uint32                   `json:"_id"`
	NoWebpage              bool                     `json:"no_webpage"`
	Silent                 bool                     `json:"silent"`
	Background             bool                     `json:"background"`
	ClearDraft             bool                     `json:"clear_draft"`
	Noforwards             bool                     `json:"noforwards"`
	UpdateStickersetsOrder bool                     `json:"update_stickersets_order"`
	InvertMedia            bool                     `json:"invert_media"`
	AllowPaidFloodskip     bool                     `json:"allow_paid_floodskip"`
	Peer                   *InputPeer               `json:"peer"`
	ReplyTo                *InputReplyTo            `json:"reply_to"`
	Message                string                   `json:"message"`
	RandomId               int64                    `json:"random_id"`
	ReplyMarkup            *ReplyMarkup             `json:"reply_markup"`
	Entities               []*MessageEntity         `json:"entities"`
	ScheduleDate           *int32                   `json:"schedule_date"`
	SendAs                 *InputPeer               `json:"send_as"`
	QuickReplyShortcut     *InputQuickReplyShortcut `json:"quick_reply_shortcut"`
	Effect                 *int64                   `json:"effect"`
	AllowPaidStars         *int64                   `json:"allow_paid_stars"`
}

func (m *TLMessagesSendMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfbf2340a: func() error {
			x.PutClazzID(0xfbf2340a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoWebpage == true {
					flags |= 1 << 1
				}
				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.UpdateStickersetsOrder == true {
					flags |= 1 << 15
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ReplyMarkup != nil {
					flags |= 1 << 2
				}
				if m.Entities != nil {
					flags |= 1 << 3
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.Effect != nil {
					flags |= 1 << 18
				}
				if m.AllowPaidStars != nil {
					flags |= 1 << 21
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			x.PutString(m.Message)
			x.PutInt64(m.RandomId)
			if m.ReplyMarkup != nil {
				_ = m.ReplyMarkup.Encode(x, layer)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			return nil
		},
		0x983f9745: func() error {
			x.PutClazzID(0x983f9745)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoWebpage == true {
					flags |= 1 << 1
				}
				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.UpdateStickersetsOrder == true {
					flags |= 1 << 15
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ReplyMarkup != nil {
					flags |= 1 << 2
				}
				if m.Entities != nil {
					flags |= 1 << 3
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.Effect != nil {
					flags |= 1 << 18
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			x.PutString(m.Message)
			x.PutInt64(m.RandomId)
			if m.ReplyMarkup != nil {
				_ = m.ReplyMarkup.Encode(x, layer)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesSendMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfbf2340a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.NoWebpage = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 15)) != 0 {
				m.UpdateStickersetsOrder = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			m10 := &InputPeer{}
			_ = m10.Decode(d)
			m.Peer = m10

			if (flags & (1 << 0)) != 0 {
				m11 := &InputReplyTo{}
				_ = m11.Decode(d)
				m.ReplyTo = m11
			}
			m.Message, err = d.String()
			m.RandomId, err = d.Int64()
			if (flags & (1 << 2)) != 0 {
				m14 := &ReplyMarkup{}
				_ = m14.Decode(d)
				m.ReplyMarkup = m14
			}
			if (flags & (1 << 3)) != 0 {
				c15, err2 := d.ClazzID()
				if c15 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 15, c15)
					return err2
				}
				l15, err3 := d.Int()
				v15 := make([]*MessageEntity, l15)
				for i := 0; i < l15; i++ {
					vv := new(MessageEntity)
					err3 = vv.Decode(d)
					_ = err3
					v15[i] = vv
				}
				m.Entities = v15
			}
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				m17 := &InputPeer{}
				_ = m17.Decode(d)
				m.SendAs = m17
			}
			if (flags & (1 << 17)) != 0 {
				m18 := &InputQuickReplyShortcut{}
				_ = m18.Decode(d)
				m.QuickReplyShortcut = m18
			}
			if (flags & (1 << 18)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			if (flags & (1 << 21)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			return nil
		},
		0x983f9745: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.NoWebpage = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 15)) != 0 {
				m.UpdateStickersetsOrder = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			m10 := &InputPeer{}
			_ = m10.Decode(d)
			m.Peer = m10

			if (flags & (1 << 0)) != 0 {
				m11 := &InputReplyTo{}
				_ = m11.Decode(d)
				m.ReplyTo = m11
			}
			m.Message, err = d.String()
			m.RandomId, err = d.Int64()
			if (flags & (1 << 2)) != 0 {
				m14 := &ReplyMarkup{}
				_ = m14.Decode(d)
				m.ReplyMarkup = m14
			}
			if (flags & (1 << 3)) != 0 {
				c15, err2 := d.ClazzID()
				if c15 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 15, c15)
					return err2
				}
				l15, err3 := d.Int()
				v15 := make([]*MessageEntity, l15)
				for i := 0; i < l15; i++ {
					vv := new(MessageEntity)
					err3 = vv.Decode(d)
					_ = err3
					v15[i] = vv
				}
				m.Entities = v15
			}
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				m17 := &InputPeer{}
				_ = m17.Decode(d)
				m.SendAs = m17
			}
			if (flags & (1 << 17)) != 0 {
				m18 := &InputQuickReplyShortcut{}
				_ = m18.Decode(d)
				m.QuickReplyShortcut = m18
			}
			if (flags & (1 << 18)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendMedia <--
type TLMessagesSendMedia struct {
	ClazzID                uint32                   `json:"_id"`
	Silent                 bool                     `json:"silent"`
	Background             bool                     `json:"background"`
	ClearDraft             bool                     `json:"clear_draft"`
	Noforwards             bool                     `json:"noforwards"`
	UpdateStickersetsOrder bool                     `json:"update_stickersets_order"`
	InvertMedia            bool                     `json:"invert_media"`
	AllowPaidFloodskip     bool                     `json:"allow_paid_floodskip"`
	Peer                   *InputPeer               `json:"peer"`
	ReplyTo                *InputReplyTo            `json:"reply_to"`
	Media                  *InputMedia              `json:"media"`
	Message                string                   `json:"message"`
	RandomId               int64                    `json:"random_id"`
	ReplyMarkup            *ReplyMarkup             `json:"reply_markup"`
	Entities               []*MessageEntity         `json:"entities"`
	ScheduleDate           *int32                   `json:"schedule_date"`
	SendAs                 *InputPeer               `json:"send_as"`
	QuickReplyShortcut     *InputQuickReplyShortcut `json:"quick_reply_shortcut"`
	Effect                 *int64                   `json:"effect"`
	AllowPaidStars         *int64                   `json:"allow_paid_stars"`
}

func (m *TLMessagesSendMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa550cd78: func() error {
			x.PutClazzID(0xa550cd78)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.UpdateStickersetsOrder == true {
					flags |= 1 << 15
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ReplyMarkup != nil {
					flags |= 1 << 2
				}
				if m.Entities != nil {
					flags |= 1 << 3
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.Effect != nil {
					flags |= 1 << 18
				}
				if m.AllowPaidStars != nil {
					flags |= 1 << 21
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			_ = m.Media.Encode(x, layer)
			x.PutString(m.Message)
			x.PutInt64(m.RandomId)
			if m.ReplyMarkup != nil {
				_ = m.ReplyMarkup.Encode(x, layer)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			return nil
		},
		0x7852834e: func() error {
			x.PutClazzID(0x7852834e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.UpdateStickersetsOrder == true {
					flags |= 1 << 15
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ReplyMarkup != nil {
					flags |= 1 << 2
				}
				if m.Entities != nil {
					flags |= 1 << 3
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.Effect != nil {
					flags |= 1 << 18
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			_ = m.Media.Encode(x, layer)
			x.PutString(m.Message)
			x.PutInt64(m.RandomId)
			if m.ReplyMarkup != nil {
				_ = m.ReplyMarkup.Encode(x, layer)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesSendMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa550cd78: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 15)) != 0 {
				m.UpdateStickersetsOrder = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			m9 := &InputPeer{}
			_ = m9.Decode(d)
			m.Peer = m9

			if (flags & (1 << 0)) != 0 {
				m10 := &InputReplyTo{}
				_ = m10.Decode(d)
				m.ReplyTo = m10
			}

			m11 := &InputMedia{}
			_ = m11.Decode(d)
			m.Media = m11

			m.Message, err = d.String()
			m.RandomId, err = d.Int64()
			if (flags & (1 << 2)) != 0 {
				m14 := &ReplyMarkup{}
				_ = m14.Decode(d)
				m.ReplyMarkup = m14
			}
			if (flags & (1 << 3)) != 0 {
				c15, err2 := d.ClazzID()
				if c15 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 15, c15)
					return err2
				}
				l15, err3 := d.Int()
				v15 := make([]*MessageEntity, l15)
				for i := 0; i < l15; i++ {
					vv := new(MessageEntity)
					err3 = vv.Decode(d)
					_ = err3
					v15[i] = vv
				}
				m.Entities = v15
			}
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				m17 := &InputPeer{}
				_ = m17.Decode(d)
				m.SendAs = m17
			}
			if (flags & (1 << 17)) != 0 {
				m18 := &InputQuickReplyShortcut{}
				_ = m18.Decode(d)
				m.QuickReplyShortcut = m18
			}
			if (flags & (1 << 18)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			if (flags & (1 << 21)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			return nil
		},
		0x7852834e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 15)) != 0 {
				m.UpdateStickersetsOrder = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			m9 := &InputPeer{}
			_ = m9.Decode(d)
			m.Peer = m9

			if (flags & (1 << 0)) != 0 {
				m10 := &InputReplyTo{}
				_ = m10.Decode(d)
				m.ReplyTo = m10
			}

			m11 := &InputMedia{}
			_ = m11.Decode(d)
			m.Media = m11

			m.Message, err = d.String()
			m.RandomId, err = d.Int64()
			if (flags & (1 << 2)) != 0 {
				m14 := &ReplyMarkup{}
				_ = m14.Decode(d)
				m.ReplyMarkup = m14
			}
			if (flags & (1 << 3)) != 0 {
				c15, err2 := d.ClazzID()
				if c15 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 15, c15)
					return err2
				}
				l15, err3 := d.Int()
				v15 := make([]*MessageEntity, l15)
				for i := 0; i < l15; i++ {
					vv := new(MessageEntity)
					err3 = vv.Decode(d)
					_ = err3
					v15[i] = vv
				}
				m.Entities = v15
			}
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				m17 := &InputPeer{}
				_ = m17.Decode(d)
				m.SendAs = m17
			}
			if (flags & (1 << 17)) != 0 {
				m18 := &InputQuickReplyShortcut{}
				_ = m18.Decode(d)
				m.QuickReplyShortcut = m18
			}
			if (flags & (1 << 18)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesForwardMessages <--
type TLMessagesForwardMessages struct {
	ClazzID            uint32                   `json:"_id"`
	Silent             bool                     `json:"silent"`
	Background         bool                     `json:"background"`
	WithMyScore        bool                     `json:"with_my_score"`
	DropAuthor         bool                     `json:"drop_author"`
	DropMediaCaptions  bool                     `json:"drop_media_captions"`
	Noforwards         bool                     `json:"noforwards"`
	AllowPaidFloodskip bool                     `json:"allow_paid_floodskip"`
	FromPeer           *InputPeer               `json:"from_peer"`
	Id                 []int32                  `json:"id"`
	RandomId           []int64                  `json:"random_id"`
	ToPeer             *InputPeer               `json:"to_peer"`
	TopMsgId           *int32                   `json:"top_msg_id"`
	ScheduleDate       *int32                   `json:"schedule_date"`
	SendAs             *InputPeer               `json:"send_as"`
	QuickReplyShortcut *InputQuickReplyShortcut `json:"quick_reply_shortcut"`
	VideoTimestamp     *int32                   `json:"video_timestamp"`
	AllowPaidStars     *int64                   `json:"allow_paid_stars"`
}

func (m *TLMessagesForwardMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesForwardMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbb9fa475: func() error {
			x.PutClazzID(0xbb9fa475)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.WithMyScore == true {
					flags |= 1 << 8
				}
				if m.DropAuthor == true {
					flags |= 1 << 11
				}
				if m.DropMediaCaptions == true {
					flags |= 1 << 12
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.TopMsgId != nil {
					flags |= 1 << 9
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.VideoTimestamp != nil {
					flags |= 1 << 20
				}
				if m.AllowPaidStars != nil {
					flags |= 1 << 21
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.FromPeer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			iface.EncodeInt64List(x, m.RandomId)

			_ = m.ToPeer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.VideoTimestamp != nil {
				x.PutInt32(*m.VideoTimestamp)
			}

			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			return nil
		},
		0x6d74da08: func() error {
			x.PutClazzID(0x6d74da08)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.WithMyScore == true {
					flags |= 1 << 8
				}
				if m.DropAuthor == true {
					flags |= 1 << 11
				}
				if m.DropMediaCaptions == true {
					flags |= 1 << 12
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.TopMsgId != nil {
					flags |= 1 << 9
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.VideoTimestamp != nil {
					flags |= 1 << 20
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.FromPeer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			iface.EncodeInt64List(x, m.RandomId)

			_ = m.ToPeer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.VideoTimestamp != nil {
				x.PutInt32(*m.VideoTimestamp)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_forwardMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_forwardMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesForwardMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbb9fa475: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 8)) != 0 {
				m.WithMyScore = true
			}
			if (flags & (1 << 11)) != 0 {
				m.DropAuthor = true
			}
			if (flags & (1 << 12)) != 0 {
				m.DropMediaCaptions = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			m9 := &InputPeer{}
			_ = m9.Decode(d)
			m.FromPeer = m9

			m.Id, err = iface.DecodeInt32List(d)

			m.RandomId, err = iface.DecodeInt64List(d)

			m12 := &InputPeer{}
			_ = m12.Decode(d)
			m.ToPeer = m12

			if (flags & (1 << 9)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				m15 := &InputPeer{}
				_ = m15.Decode(d)
				m.SendAs = m15
			}
			if (flags & (1 << 17)) != 0 {
				m16 := &InputQuickReplyShortcut{}
				_ = m16.Decode(d)
				m.QuickReplyShortcut = m16
			}
			if (flags & (1 << 20)) != 0 {
				m.VideoTimestamp = new(int32)
				*m.VideoTimestamp, err = d.Int32()
			}
			if (flags & (1 << 21)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			return nil
		},
		0x6d74da08: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 8)) != 0 {
				m.WithMyScore = true
			}
			if (flags & (1 << 11)) != 0 {
				m.DropAuthor = true
			}
			if (flags & (1 << 12)) != 0 {
				m.DropMediaCaptions = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			m9 := &InputPeer{}
			_ = m9.Decode(d)
			m.FromPeer = m9

			m.Id, err = iface.DecodeInt32List(d)

			m.RandomId, err = iface.DecodeInt64List(d)

			m12 := &InputPeer{}
			_ = m12.Decode(d)
			m.ToPeer = m12

			if (flags & (1 << 9)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				m15 := &InputPeer{}
				_ = m15.Decode(d)
				m.SendAs = m15
			}
			if (flags & (1 << 17)) != 0 {
				m16 := &InputQuickReplyShortcut{}
				_ = m16.Decode(d)
				m.QuickReplyShortcut = m16
			}
			if (flags & (1 << 20)) != 0 {
				m.VideoTimestamp = new(int32)
				*m.VideoTimestamp, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReportSpam <--
type TLMessagesReportSpam struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLMessagesReportSpam) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReportSpam) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcf1592db: func() error {
			x.PutClazzID(0xcf1592db)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reportSpam, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reportSpam, layer)
	}
}

// Decode <--
func (m *TLMessagesReportSpam) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcf1592db: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPeerSettings <--
type TLMessagesGetPeerSettings struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLMessagesGetPeerSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPeerSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xefd9a6a2: func() error {
			x.PutClazzID(0xefd9a6a2)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPeerSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPeerSettings, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPeerSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xefd9a6a2: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReport <--
type TLMessagesReport struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
	Option  []byte     `json:"option"`
	Message string     `json:"message"`
}

func (m *TLMessagesReport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfc78af9b: func() error {
			x.PutClazzID(0xfc78af9b)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			x.PutBytes(m.Option)
			x.PutString(m.Message)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_report, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_report, layer)
	}
}

// Decode <--
func (m *TLMessagesReport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfc78af9b: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			m.Option, err = d.Bytes()
			m.Message, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetChats <--
type TLMessagesGetChats struct {
	ClazzID uint32  `json:"_id"`
	Id      []int64 `json:"id"`
}

func (m *TLMessagesGetChats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetChats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x49e9528f: func() error {
			x.PutClazzID(0x49e9528f)

			iface.EncodeInt64List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getChats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getChats, layer)
	}
}

// Decode <--
func (m *TLMessagesGetChats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x49e9528f: func() (err error) {

			m.Id, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetFullChat <--
type TLMessagesGetFullChat struct {
	ClazzID uint32 `json:"_id"`
	ChatId  int64  `json:"chat_id"`
}

func (m *TLMessagesGetFullChat) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetFullChat) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaeb00b34: func() error {
			x.PutClazzID(0xaeb00b34)

			x.PutInt64(m.ChatId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getFullChat, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getFullChat, layer)
	}
}

// Decode <--
func (m *TLMessagesGetFullChat) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaeb00b34: func() (err error) {
			m.ChatId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditChatTitle <--
type TLMessagesEditChatTitle struct {
	ClazzID uint32 `json:"_id"`
	ChatId  int64  `json:"chat_id"`
	Title   string `json:"title"`
}

func (m *TLMessagesEditChatTitle) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditChatTitle) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x73783ffd: func() error {
			x.PutClazzID(0x73783ffd)

			x.PutInt64(m.ChatId)
			x.PutString(m.Title)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editChatTitle, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editChatTitle, layer)
	}
}

// Decode <--
func (m *TLMessagesEditChatTitle) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x73783ffd: func() (err error) {
			m.ChatId, err = d.Int64()
			m.Title, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditChatPhoto <--
type TLMessagesEditChatPhoto struct {
	ClazzID uint32          `json:"_id"`
	ChatId  int64           `json:"chat_id"`
	Photo   *InputChatPhoto `json:"photo"`
}

func (m *TLMessagesEditChatPhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditChatPhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x35ddd674: func() error {
			x.PutClazzID(0x35ddd674)

			x.PutInt64(m.ChatId)
			_ = m.Photo.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editChatPhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editChatPhoto, layer)
	}
}

// Decode <--
func (m *TLMessagesEditChatPhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x35ddd674: func() (err error) {
			m.ChatId, err = d.Int64()

			m2 := &InputChatPhoto{}
			_ = m2.Decode(d)
			m.Photo = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesAddChatUser <--
type TLMessagesAddChatUser struct {
	ClazzID  uint32     `json:"_id"`
	ChatId   int64      `json:"chat_id"`
	UserId   *InputUser `json:"user_id"`
	FwdLimit int32      `json:"fwd_limit"`
}

func (m *TLMessagesAddChatUser) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesAddChatUser) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcbc6d107: func() error {
			x.PutClazzID(0xcbc6d107)

			x.PutInt64(m.ChatId)
			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.FwdLimit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_addChatUser, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_addChatUser, layer)
	}
}

// Decode <--
func (m *TLMessagesAddChatUser) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcbc6d107: func() (err error) {
			m.ChatId, err = d.Int64()

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.UserId = m2

			m.FwdLimit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteChatUser <--
type TLMessagesDeleteChatUser struct {
	ClazzID       uint32     `json:"_id"`
	RevokeHistory bool       `json:"revoke_history"`
	ChatId        int64      `json:"chat_id"`
	UserId        *InputUser `json:"user_id"`
}

func (m *TLMessagesDeleteChatUser) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteChatUser) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa2185cab: func() error {
			x.PutClazzID(0xa2185cab)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.RevokeHistory == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.ChatId)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteChatUser, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteChatUser, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteChatUser) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa2185cab: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.RevokeHistory = true
			}
			m.ChatId, err = d.Int64()

			m4 := &InputUser{}
			_ = m4.Decode(d)
			m.UserId = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCreateChat <--
type TLMessagesCreateChat struct {
	ClazzID   uint32       `json:"_id"`
	Users     []*InputUser `json:"users"`
	Title     string       `json:"title"`
	TtlPeriod *int32       `json:"ttl_period"`
}

func (m *TLMessagesCreateChat) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCreateChat) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x92ceddd4: func() error {
			x.PutClazzID(0x92ceddd4)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TtlPeriod != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			_ = iface.EncodeObjectList(x, m.Users, layer)

			x.PutString(m.Title)
			if m.TtlPeriod != nil {
				x.PutInt32(*m.TtlPeriod)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_createChat, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_createChat, layer)
	}
}

// Decode <--
func (m *TLMessagesCreateChat) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x92ceddd4: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputUser, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputUser)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Users = v2

			m.Title, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.TtlPeriod = new(int32)
				*m.TtlPeriod, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDhConfig <--
type TLMessagesGetDhConfig struct {
	ClazzID      uint32 `json:"_id"`
	Version      int32  `json:"version"`
	RandomLength int32  `json:"random_length"`
}

func (m *TLMessagesGetDhConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDhConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x26cf8950: func() error {
			x.PutClazzID(0x26cf8950)

			x.PutInt32(m.Version)
			x.PutInt32(m.RandomLength)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDhConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDhConfig, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDhConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x26cf8950: func() (err error) {
			m.Version, err = d.Int32()
			m.RandomLength, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestEncryption <--
type TLMessagesRequestEncryption struct {
	ClazzID  uint32     `json:"_id"`
	UserId   *InputUser `json:"user_id"`
	RandomId int32      `json:"random_id"`
	GA       []byte     `json:"g_a"`
}

func (m *TLMessagesRequestEncryption) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestEncryption) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf64daf43: func() error {
			x.PutClazzID(0xf64daf43)

			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.RandomId)
			x.PutBytes(m.GA)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestEncryption, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestEncryption, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestEncryption) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf64daf43: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.UserId = m1

			m.RandomId, err = d.Int32()
			m.GA, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesAcceptEncryption <--
type TLMessagesAcceptEncryption struct {
	ClazzID        uint32              `json:"_id"`
	Peer           *InputEncryptedChat `json:"peer"`
	GB             []byte              `json:"g_b"`
	KeyFingerprint int64               `json:"key_fingerprint"`
}

func (m *TLMessagesAcceptEncryption) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesAcceptEncryption) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3dbc0415: func() error {
			x.PutClazzID(0x3dbc0415)

			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.GB)
			x.PutInt64(m.KeyFingerprint)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_acceptEncryption, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_acceptEncryption, layer)
	}
}

// Decode <--
func (m *TLMessagesAcceptEncryption) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3dbc0415: func() (err error) {

			m1 := &InputEncryptedChat{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.GB, err = d.Bytes()
			m.KeyFingerprint, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDiscardEncryption <--
type TLMessagesDiscardEncryption struct {
	ClazzID       uint32 `json:"_id"`
	DeleteHistory bool   `json:"delete_history"`
	ChatId        int32  `json:"chat_id"`
}

func (m *TLMessagesDiscardEncryption) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDiscardEncryption) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf393aea0: func() error {
			x.PutClazzID(0xf393aea0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.DeleteHistory == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.ChatId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_discardEncryption, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_discardEncryption, layer)
	}
}

// Decode <--
func (m *TLMessagesDiscardEncryption) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf393aea0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.DeleteHistory = true
			}
			m.ChatId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetEncryptedTyping <--
type TLMessagesSetEncryptedTyping struct {
	ClazzID uint32              `json:"_id"`
	Peer    *InputEncryptedChat `json:"peer"`
	Typing  *Bool               `json:"typing"`
}

func (m *TLMessagesSetEncryptedTyping) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetEncryptedTyping) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x791451ed: func() error {
			x.PutClazzID(0x791451ed)

			_ = m.Peer.Encode(x, layer)
			_ = m.Typing.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setEncryptedTyping, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setEncryptedTyping, layer)
	}
}

// Decode <--
func (m *TLMessagesSetEncryptedTyping) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x791451ed: func() (err error) {

			m1 := &InputEncryptedChat{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Typing = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadEncryptedHistory <--
type TLMessagesReadEncryptedHistory struct {
	ClazzID uint32              `json:"_id"`
	Peer    *InputEncryptedChat `json:"peer"`
	MaxDate int32               `json:"max_date"`
}

func (m *TLMessagesReadEncryptedHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadEncryptedHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7f4b690a: func() error {
			x.PutClazzID(0x7f4b690a)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxDate)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readEncryptedHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readEncryptedHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesReadEncryptedHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7f4b690a: func() (err error) {

			m1 := &InputEncryptedChat{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MaxDate, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendEncrypted <--
type TLMessagesSendEncrypted struct {
	ClazzID  uint32              `json:"_id"`
	Silent   bool                `json:"silent"`
	Peer     *InputEncryptedChat `json:"peer"`
	RandomId int64               `json:"random_id"`
	Data     []byte              `json:"data"`
}

func (m *TLMessagesSendEncrypted) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendEncrypted) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x44fa7a15: func() error {
			x.PutClazzID(0x44fa7a15)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.RandomId)
			x.PutBytes(m.Data)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendEncrypted, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendEncrypted, layer)
	}
}

// Decode <--
func (m *TLMessagesSendEncrypted) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x44fa7a15: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Silent = true
			}

			m3 := &InputEncryptedChat{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.RandomId, err = d.Int64()
			m.Data, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendEncryptedFile <--
type TLMessagesSendEncryptedFile struct {
	ClazzID  uint32              `json:"_id"`
	Silent   bool                `json:"silent"`
	Peer     *InputEncryptedChat `json:"peer"`
	RandomId int64               `json:"random_id"`
	Data     []byte              `json:"data"`
	File     *InputEncryptedFile `json:"file"`
}

func (m *TLMessagesSendEncryptedFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendEncryptedFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5559481d: func() error {
			x.PutClazzID(0x5559481d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.RandomId)
			x.PutBytes(m.Data)
			_ = m.File.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendEncryptedFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendEncryptedFile, layer)
	}
}

// Decode <--
func (m *TLMessagesSendEncryptedFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5559481d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Silent = true
			}

			m3 := &InputEncryptedChat{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.RandomId, err = d.Int64()
			m.Data, err = d.Bytes()

			m6 := &InputEncryptedFile{}
			_ = m6.Decode(d)
			m.File = m6

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendEncryptedService <--
type TLMessagesSendEncryptedService struct {
	ClazzID  uint32              `json:"_id"`
	Peer     *InputEncryptedChat `json:"peer"`
	RandomId int64               `json:"random_id"`
	Data     []byte              `json:"data"`
}

func (m *TLMessagesSendEncryptedService) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendEncryptedService) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x32d439a4: func() error {
			x.PutClazzID(0x32d439a4)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.RandomId)
			x.PutBytes(m.Data)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendEncryptedService, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendEncryptedService, layer)
	}
}

// Decode <--
func (m *TLMessagesSendEncryptedService) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x32d439a4: func() (err error) {

			m1 := &InputEncryptedChat{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.RandomId, err = d.Int64()
			m.Data, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReceivedQueue <--
type TLMessagesReceivedQueue struct {
	ClazzID uint32 `json:"_id"`
	MaxQts  int32  `json:"max_qts"`
}

func (m *TLMessagesReceivedQueue) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReceivedQueue) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x55a5bb66: func() error {
			x.PutClazzID(0x55a5bb66)

			x.PutInt32(m.MaxQts)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_receivedQueue, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_receivedQueue, layer)
	}
}

// Decode <--
func (m *TLMessagesReceivedQueue) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x55a5bb66: func() (err error) {
			m.MaxQts, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReportEncryptedSpam <--
type TLMessagesReportEncryptedSpam struct {
	ClazzID uint32              `json:"_id"`
	Peer    *InputEncryptedChat `json:"peer"`
}

func (m *TLMessagesReportEncryptedSpam) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReportEncryptedSpam) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4b0c8c0f: func() error {
			x.PutClazzID(0x4b0c8c0f)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reportEncryptedSpam, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reportEncryptedSpam, layer)
	}
}

// Decode <--
func (m *TLMessagesReportEncryptedSpam) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4b0c8c0f: func() (err error) {

			m1 := &InputEncryptedChat{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadMessageContents <--
type TLMessagesReadMessageContents struct {
	ClazzID uint32  `json:"_id"`
	Id      []int32 `json:"id"`
}

func (m *TLMessagesReadMessageContents) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadMessageContents) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x36a73f77: func() error {
			x.PutClazzID(0x36a73f77)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readMessageContents, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readMessageContents, layer)
	}
}

// Decode <--
func (m *TLMessagesReadMessageContents) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x36a73f77: func() (err error) {

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetStickers <--
type TLMessagesGetStickers struct {
	ClazzID  uint32 `json:"_id"`
	Emoticon string `json:"emoticon"`
	Hash     int64  `json:"hash"`
}

func (m *TLMessagesGetStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd5a5d3a1: func() error {
			x.PutClazzID(0xd5a5d3a1)

			x.PutString(m.Emoticon)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd5a5d3a1: func() (err error) {
			m.Emoticon, err = d.String()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAllStickers <--
type TLMessagesGetAllStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetAllStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAllStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb8a0a1a8: func() error {
			x.PutClazzID(0xb8a0a1a8)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAllStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAllStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAllStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb8a0a1a8: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetWebPagePreview <--
type TLMessagesGetWebPagePreview struct {
	ClazzID  uint32           `json:"_id"`
	Message  string           `json:"message"`
	Entities []*MessageEntity `json:"entities"`
}

func (m *TLMessagesGetWebPagePreview) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetWebPagePreview) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x570d6f6f: func() error {
			x.PutClazzID(0x570d6f6f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Entities != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Message)
			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getWebPagePreview, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getWebPagePreview, layer)
	}
}

// Decode <--
func (m *TLMessagesGetWebPagePreview) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x570d6f6f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Message, err = d.String()
			if (flags & (1 << 3)) != 0 {
				c3, err2 := d.ClazzID()
				if c3 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
					return err2
				}
				l3, err3 := d.Int()
				v3 := make([]*MessageEntity, l3)
				for i := 0; i < l3; i++ {
					vv := new(MessageEntity)
					err3 = vv.Decode(d)
					_ = err3
					v3[i] = vv
				}
				m.Entities = v3
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesExportChatInvite <--
type TLMessagesExportChatInvite struct {
	ClazzID               uint32                    `json:"_id"`
	LegacyRevokePermanent bool                      `json:"legacy_revoke_permanent"`
	RequestNeeded         bool                      `json:"request_needed"`
	Peer                  *InputPeer                `json:"peer"`
	ExpireDate            *int32                    `json:"expire_date"`
	UsageLimit            *int32                    `json:"usage_limit"`
	Title                 *string                   `json:"title"`
	SubscriptionPricing   *StarsSubscriptionPricing `json:"subscription_pricing"`
}

func (m *TLMessagesExportChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesExportChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa455de90: func() error {
			x.PutClazzID(0xa455de90)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.LegacyRevokePermanent == true {
					flags |= 1 << 2
				}
				if m.RequestNeeded == true {
					flags |= 1 << 3
				}

				if m.ExpireDate != nil {
					flags |= 1 << 0
				}
				if m.UsageLimit != nil {
					flags |= 1 << 1
				}
				if m.Title != nil {
					flags |= 1 << 4
				}
				if m.SubscriptionPricing != nil {
					flags |= 1 << 5
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ExpireDate != nil {
				x.PutInt32(*m.ExpireDate)
			}

			if m.UsageLimit != nil {
				x.PutInt32(*m.UsageLimit)
			}

			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.SubscriptionPricing != nil {
				_ = m.SubscriptionPricing.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_exportChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_exportChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesExportChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa455de90: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m.LegacyRevokePermanent = true
			}
			if (flags & (1 << 3)) != 0 {
				m.RequestNeeded = true
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			if (flags & (1 << 0)) != 0 {
				m.ExpireDate = new(int32)
				*m.ExpireDate, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m.UsageLimit = new(int32)
				*m.UsageLimit, err = d.Int32()
			}
			if (flags & (1 << 4)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 5)) != 0 {
				m8 := &StarsSubscriptionPricing{}
				_ = m8.Decode(d)
				m.SubscriptionPricing = m8
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCheckChatInvite <--
type TLMessagesCheckChatInvite struct {
	ClazzID uint32 `json:"_id"`
	Hash    string `json:"hash"`
}

func (m *TLMessagesCheckChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCheckChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3eadb1bb: func() error {
			x.PutClazzID(0x3eadb1bb)

			x.PutString(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_checkChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_checkChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesCheckChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3eadb1bb: func() (err error) {
			m.Hash, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesImportChatInvite <--
type TLMessagesImportChatInvite struct {
	ClazzID uint32 `json:"_id"`
	Hash    string `json:"hash"`
}

func (m *TLMessagesImportChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesImportChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6c50051c: func() error {
			x.PutClazzID(0x6c50051c)

			x.PutString(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_importChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_importChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesImportChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6c50051c: func() (err error) {
			m.Hash, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetStickerSet <--
type TLMessagesGetStickerSet struct {
	ClazzID    uint32           `json:"_id"`
	Stickerset *InputStickerSet `json:"stickerset"`
	Hash       int32            `json:"hash"`
}

func (m *TLMessagesGetStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc8a0ec74: func() error {
			x.PutClazzID(0xc8a0ec74)

			_ = m.Stickerset.Encode(x, layer)
			x.PutInt32(m.Hash)

			return nil
		},
		0x2619a90e: func() error {
			x.PutClazzID(0x2619a90e)

			_ = m.Stickerset.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getStickerSet, layer)
	}
}

// Decode <--
func (m *TLMessagesGetStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc8a0ec74: func() (err error) {

			m1 := &InputStickerSet{}
			_ = m1.Decode(d)
			m.Stickerset = m1

			m.Hash, err = d.Int32()

			return nil
		},
		0x2619a90e: func() (err error) {

			m1 := &InputStickerSet{}
			_ = m1.Decode(d)
			m.Stickerset = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesInstallStickerSet <--
type TLMessagesInstallStickerSet struct {
	ClazzID    uint32           `json:"_id"`
	Stickerset *InputStickerSet `json:"stickerset"`
	Archived   *Bool            `json:"archived"`
}

func (m *TLMessagesInstallStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesInstallStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc78fe460: func() error {
			x.PutClazzID(0xc78fe460)

			_ = m.Stickerset.Encode(x, layer)
			_ = m.Archived.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_installStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_installStickerSet, layer)
	}
}

// Decode <--
func (m *TLMessagesInstallStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc78fe460: func() (err error) {

			m1 := &InputStickerSet{}
			_ = m1.Decode(d)
			m.Stickerset = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Archived = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUninstallStickerSet <--
type TLMessagesUninstallStickerSet struct {
	ClazzID    uint32           `json:"_id"`
	Stickerset *InputStickerSet `json:"stickerset"`
}

func (m *TLMessagesUninstallStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUninstallStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf96e55de: func() error {
			x.PutClazzID(0xf96e55de)

			_ = m.Stickerset.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_uninstallStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_uninstallStickerSet, layer)
	}
}

// Decode <--
func (m *TLMessagesUninstallStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf96e55de: func() (err error) {

			m1 := &InputStickerSet{}
			_ = m1.Decode(d)
			m.Stickerset = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesStartBot <--
type TLMessagesStartBot struct {
	ClazzID    uint32     `json:"_id"`
	Bot        *InputUser `json:"bot"`
	Peer       *InputPeer `json:"peer"`
	RandomId   int64      `json:"random_id"`
	StartParam string     `json:"start_param"`
}

func (m *TLMessagesStartBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesStartBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe6df7378: func() error {
			x.PutClazzID(0xe6df7378)

			_ = m.Bot.Encode(x, layer)
			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.RandomId)
			x.PutString(m.StartParam)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_startBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_startBot, layer)
	}
}

// Decode <--
func (m *TLMessagesStartBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe6df7378: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			m.RandomId, err = d.Int64()
			m.StartParam, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessagesViews <--
type TLMessagesGetMessagesViews struct {
	ClazzID   uint32     `json:"_id"`
	Peer      *InputPeer `json:"peer"`
	Id        []int32    `json:"id"`
	Increment *Bool      `json:"increment"`
}

func (m *TLMessagesGetMessagesViews) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessagesViews) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5784d3e1: func() error {
			x.PutClazzID(0x5784d3e1)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			_ = m.Increment.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessagesViews, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessagesViews, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessagesViews) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5784d3e1: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			m3 := &Bool{}
			_ = m3.Decode(d)
			m.Increment = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditChatAdmin <--
type TLMessagesEditChatAdmin struct {
	ClazzID uint32     `json:"_id"`
	ChatId  int64      `json:"chat_id"`
	UserId  *InputUser `json:"user_id"`
	IsAdmin *Bool      `json:"is_admin"`
}

func (m *TLMessagesEditChatAdmin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditChatAdmin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa85bd1c2: func() error {
			x.PutClazzID(0xa85bd1c2)

			x.PutInt64(m.ChatId)
			_ = m.UserId.Encode(x, layer)
			_ = m.IsAdmin.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editChatAdmin, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editChatAdmin, layer)
	}
}

// Decode <--
func (m *TLMessagesEditChatAdmin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa85bd1c2: func() (err error) {
			m.ChatId, err = d.Int64()

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.UserId = m2

			m3 := &Bool{}
			_ = m3.Decode(d)
			m.IsAdmin = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesMigrateChat <--
type TLMessagesMigrateChat struct {
	ClazzID uint32 `json:"_id"`
	ChatId  int64  `json:"chat_id"`
}

func (m *TLMessagesMigrateChat) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesMigrateChat) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa2875319: func() error {
			x.PutClazzID(0xa2875319)

			x.PutInt64(m.ChatId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_migrateChat, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_migrateChat, layer)
	}
}

// Decode <--
func (m *TLMessagesMigrateChat) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa2875319: func() (err error) {
			m.ChatId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchGlobal <--
type TLMessagesSearchGlobal struct {
	ClazzID        uint32          `json:"_id"`
	BroadcastsOnly bool            `json:"broadcasts_only"`
	GroupsOnly     bool            `json:"groups_only"`
	UsersOnly      bool            `json:"users_only"`
	FolderId       *int32          `json:"folder_id"`
	Q              string          `json:"q"`
	Filter         *MessagesFilter `json:"filter"`
	MinDate        int32           `json:"min_date"`
	MaxDate        int32           `json:"max_date"`
	OffsetRate     int32           `json:"offset_rate"`
	OffsetPeer     *InputPeer      `json:"offset_peer"`
	OffsetId       int32           `json:"offset_id"`
	Limit          int32           `json:"limit"`
}

func (m *TLMessagesSearchGlobal) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchGlobal) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4bc6589a: func() error {
			x.PutClazzID(0x4bc6589a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.BroadcastsOnly == true {
					flags |= 1 << 1
				}
				if m.GroupsOnly == true {
					flags |= 1 << 2
				}
				if m.UsersOnly == true {
					flags |= 1 << 3
				}
				if m.FolderId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.FolderId != nil {
				x.PutInt32(*m.FolderId)
			}

			x.PutString(m.Q)
			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.MinDate)
			x.PutInt32(m.MaxDate)
			x.PutInt32(m.OffsetRate)
			_ = m.OffsetPeer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchGlobal, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchGlobal, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchGlobal) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4bc6589a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.BroadcastsOnly = true
			}
			if (flags & (1 << 2)) != 0 {
				m.GroupsOnly = true
			}
			if (flags & (1 << 3)) != 0 {
				m.UsersOnly = true
			}
			if (flags & (1 << 0)) != 0 {
				m.FolderId = new(int32)
				*m.FolderId, err = d.Int32()
			}
			m.Q, err = d.String()

			m7 := &MessagesFilter{}
			_ = m7.Decode(d)
			m.Filter = m7

			m.MinDate, err = d.Int32()
			m.MaxDate, err = d.Int32()
			m.OffsetRate, err = d.Int32()

			m11 := &InputPeer{}
			_ = m11.Decode(d)
			m.OffsetPeer = m11

			m.OffsetId, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReorderStickerSets <--
type TLMessagesReorderStickerSets struct {
	ClazzID uint32  `json:"_id"`
	Masks   bool    `json:"masks"`
	Emojis  bool    `json:"emojis"`
	Order   []int64 `json:"order"`
}

func (m *TLMessagesReorderStickerSets) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReorderStickerSets) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x78337739: func() error {
			x.PutClazzID(0x78337739)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Masks == true {
					flags |= 1 << 0
				}
				if m.Emojis == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			iface.EncodeInt64List(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reorderStickerSets, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reorderStickerSets, layer)
	}
}

// Decode <--
func (m *TLMessagesReorderStickerSets) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x78337739: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Masks = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Emojis = true
			}

			m.Order, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDocumentByHash <--
type TLMessagesGetDocumentByHash struct {
	ClazzID  uint32 `json:"_id"`
	Sha256   []byte `json:"sha256"`
	Size2    int64  `json:"size2"`
	MimeType string `json:"mime_type"`
}

func (m *TLMessagesGetDocumentByHash) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDocumentByHash) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb1f2061f: func() error {
			x.PutClazzID(0xb1f2061f)

			x.PutBytes(m.Sha256)
			x.PutInt64(m.Size2)
			x.PutString(m.MimeType)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDocumentByHash, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDocumentByHash, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDocumentByHash) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb1f2061f: func() (err error) {
			m.Sha256, err = d.Bytes()
			m.Size2, err = d.Int64()
			m.MimeType, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSavedGifs <--
type TLMessagesGetSavedGifs struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetSavedGifs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSavedGifs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5cf09635: func() error {
			x.PutClazzID(0x5cf09635)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSavedGifs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSavedGifs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSavedGifs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5cf09635: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSaveGif <--
type TLMessagesSaveGif struct {
	ClazzID uint32         `json:"_id"`
	Id      *InputDocument `json:"id"`
	Unsave  *Bool          `json:"unsave"`
}

func (m *TLMessagesSaveGif) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSaveGif) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x327a30cb: func() error {
			x.PutClazzID(0x327a30cb)

			_ = m.Id.Encode(x, layer)
			_ = m.Unsave.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_saveGif, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_saveGif, layer)
	}
}

// Decode <--
func (m *TLMessagesSaveGif) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x327a30cb: func() (err error) {

			m1 := &InputDocument{}
			_ = m1.Decode(d)
			m.Id = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Unsave = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetInlineBotResults <--
type TLMessagesGetInlineBotResults struct {
	ClazzID  uint32         `json:"_id"`
	Bot      *InputUser     `json:"bot"`
	Peer     *InputPeer     `json:"peer"`
	GeoPoint *InputGeoPoint `json:"geo_point"`
	Query    string         `json:"query"`
	Offset   string         `json:"offset"`
}

func (m *TLMessagesGetInlineBotResults) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetInlineBotResults) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x514e999d: func() error {
			x.PutClazzID(0x514e999d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.GeoPoint != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Bot.Encode(x, layer)
			_ = m.Peer.Encode(x, layer)
			if m.GeoPoint != nil {
				_ = m.GeoPoint.Encode(x, layer)
			}

			x.PutString(m.Query)
			x.PutString(m.Offset)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getInlineBotResults, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getInlineBotResults, layer)
	}
}

// Decode <--
func (m *TLMessagesGetInlineBotResults) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x514e999d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.Bot = m2

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			if (flags & (1 << 0)) != 0 {
				m4 := &InputGeoPoint{}
				_ = m4.Decode(d)
				m.GeoPoint = m4
			}
			m.Query, err = d.String()
			m.Offset, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetInlineBotResults <--
type TLMessagesSetInlineBotResults struct {
	ClazzID       uint32                  `json:"_id"`
	Gallery       bool                    `json:"gallery"`
	Private       bool                    `json:"private"`
	QueryId       int64                   `json:"query_id"`
	Results       []*InputBotInlineResult `json:"results"`
	CacheTime     int32                   `json:"cache_time"`
	NextOffset    *string                 `json:"next_offset"`
	SwitchPm      *InlineBotSwitchPM      `json:"switch_pm"`
	SwitchWebview *InlineBotWebView       `json:"switch_webview"`
}

func (m *TLMessagesSetInlineBotResults) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetInlineBotResults) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbb12a419: func() error {
			x.PutClazzID(0xbb12a419)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Gallery == true {
					flags |= 1 << 0
				}
				if m.Private == true {
					flags |= 1 << 1
				}

				if m.NextOffset != nil {
					flags |= 1 << 2
				}
				if m.SwitchPm != nil {
					flags |= 1 << 3
				}
				if m.SwitchWebview != nil {
					flags |= 1 << 4
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.QueryId)

			_ = iface.EncodeObjectList(x, m.Results, layer)

			x.PutInt32(m.CacheTime)
			if m.NextOffset != nil {
				x.PutString(*m.NextOffset)
			}

			if m.SwitchPm != nil {
				_ = m.SwitchPm.Encode(x, layer)
			}

			if m.SwitchWebview != nil {
				_ = m.SwitchWebview.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setInlineBotResults, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setInlineBotResults, layer)
	}
}

// Decode <--
func (m *TLMessagesSetInlineBotResults) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbb12a419: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Gallery = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Private = true
			}
			m.QueryId, err = d.Int64()
			c5, err2 := d.ClazzID()
			if c5 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
				return err2
			}
			l5, err3 := d.Int()
			v5 := make([]*InputBotInlineResult, l5)
			for i := 0; i < l5; i++ {
				vv := new(InputBotInlineResult)
				err3 = vv.Decode(d)
				_ = err3
				v5[i] = vv
			}
			m.Results = v5

			m.CacheTime, err = d.Int32()
			if (flags & (1 << 2)) != 0 {
				m.NextOffset = new(string)
				*m.NextOffset, err = d.String()
			}

			if (flags & (1 << 3)) != 0 {
				m8 := &InlineBotSwitchPM{}
				_ = m8.Decode(d)
				m.SwitchPm = m8
			}
			if (flags & (1 << 4)) != 0 {
				m9 := &InlineBotWebView{}
				_ = m9.Decode(d)
				m.SwitchWebview = m9
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendInlineBotResult <--
type TLMessagesSendInlineBotResult struct {
	ClazzID            uint32                   `json:"_id"`
	Silent             bool                     `json:"silent"`
	Background         bool                     `json:"background"`
	ClearDraft         bool                     `json:"clear_draft"`
	HideVia            bool                     `json:"hide_via"`
	Peer               *InputPeer               `json:"peer"`
	ReplyTo            *InputReplyTo            `json:"reply_to"`
	RandomId           int64                    `json:"random_id"`
	QueryId            int64                    `json:"query_id"`
	Id                 string                   `json:"id"`
	ScheduleDate       *int32                   `json:"schedule_date"`
	SendAs             *InputPeer               `json:"send_as"`
	QuickReplyShortcut *InputQuickReplyShortcut `json:"quick_reply_shortcut"`
	AllowPaidStars     *int64                   `json:"allow_paid_stars"`
}

func (m *TLMessagesSendInlineBotResult) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendInlineBotResult) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc0cf7646: func() error {
			x.PutClazzID(0xc0cf7646)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.HideVia == true {
					flags |= 1 << 11
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.AllowPaidStars != nil {
					flags |= 1 << 21
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			x.PutInt64(m.RandomId)
			x.PutInt64(m.QueryId)
			x.PutString(m.Id)
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			return nil
		},
		0x3ebee86a: func() error {
			x.PutClazzID(0x3ebee86a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.HideVia == true {
					flags |= 1 << 11
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			x.PutInt64(m.RandomId)
			x.PutInt64(m.QueryId)
			x.PutString(m.Id)
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendInlineBotResult, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendInlineBotResult, layer)
	}
}

// Decode <--
func (m *TLMessagesSendInlineBotResult) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc0cf7646: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 11)) != 0 {
				m.HideVia = true
			}

			m6 := &InputPeer{}
			_ = m6.Decode(d)
			m.Peer = m6

			if (flags & (1 << 0)) != 0 {
				m7 := &InputReplyTo{}
				_ = m7.Decode(d)
				m.ReplyTo = m7
			}
			m.RandomId, err = d.Int64()
			m.QueryId, err = d.Int64()
			m.Id, err = d.String()
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				m12 := &InputPeer{}
				_ = m12.Decode(d)
				m.SendAs = m12
			}
			if (flags & (1 << 17)) != 0 {
				m13 := &InputQuickReplyShortcut{}
				_ = m13.Decode(d)
				m.QuickReplyShortcut = m13
			}
			if (flags & (1 << 21)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			return nil
		},
		0x3ebee86a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 11)) != 0 {
				m.HideVia = true
			}

			m6 := &InputPeer{}
			_ = m6.Decode(d)
			m.Peer = m6

			if (flags & (1 << 0)) != 0 {
				m7 := &InputReplyTo{}
				_ = m7.Decode(d)
				m.ReplyTo = m7
			}
			m.RandomId, err = d.Int64()
			m.QueryId, err = d.Int64()
			m.Id, err = d.String()
			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				m12 := &InputPeer{}
				_ = m12.Decode(d)
				m.SendAs = m12
			}
			if (flags & (1 << 17)) != 0 {
				m13 := &InputQuickReplyShortcut{}
				_ = m13.Decode(d)
				m.QuickReplyShortcut = m13
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessageEditData <--
type TLMessagesGetMessageEditData struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      int32      `json:"id"`
}

func (m *TLMessagesGetMessageEditData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessageEditData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfda68d36: func() error {
			x.PutClazzID(0xfda68d36)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessageEditData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessageEditData, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessageEditData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfda68d36: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditMessage <--
type TLMessagesEditMessage struct {
	ClazzID              uint32           `json:"_id"`
	NoWebpage            bool             `json:"no_webpage"`
	InvertMedia          bool             `json:"invert_media"`
	Peer                 *InputPeer       `json:"peer"`
	Id                   int32            `json:"id"`
	Message              *string          `json:"message"`
	Media                *InputMedia      `json:"media"`
	ReplyMarkup          *ReplyMarkup     `json:"reply_markup"`
	Entities             []*MessageEntity `json:"entities"`
	ScheduleDate         *int32           `json:"schedule_date"`
	QuickReplyShortcutId *int32           `json:"quick_reply_shortcut_id"`
}

func (m *TLMessagesEditMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdfd14005: func() error {
			x.PutClazzID(0xdfd14005)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoWebpage == true {
					flags |= 1 << 1
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}

				if m.Message != nil {
					flags |= 1 << 11
				}
				if m.Media != nil {
					flags |= 1 << 14
				}
				if m.ReplyMarkup != nil {
					flags |= 1 << 2
				}
				if m.Entities != nil {
					flags |= 1 << 3
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 15
				}
				if m.QuickReplyShortcutId != nil {
					flags |= 1 << 17
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			if m.Message != nil {
				x.PutString(*m.Message)
			}

			if m.Media != nil {
				_ = m.Media.Encode(x, layer)
			}

			if m.ReplyMarkup != nil {
				_ = m.ReplyMarkup.Encode(x, layer)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.QuickReplyShortcutId != nil {
				x.PutInt32(*m.QuickReplyShortcutId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesEditMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdfd14005: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.NoWebpage = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			m.Id, err = d.Int32()
			if (flags & (1 << 11)) != 0 {
				m.Message = new(string)
				*m.Message, err = d.String()
			}

			if (flags & (1 << 14)) != 0 {
				m7 := &InputMedia{}
				_ = m7.Decode(d)
				m.Media = m7
			}
			if (flags & (1 << 2)) != 0 {
				m8 := &ReplyMarkup{}
				_ = m8.Decode(d)
				m.ReplyMarkup = m8
			}
			if (flags & (1 << 3)) != 0 {
				c9, err2 := d.ClazzID()
				if c9 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 9, c9)
					return err2
				}
				l9, err3 := d.Int()
				v9 := make([]*MessageEntity, l9)
				for i := 0; i < l9; i++ {
					vv := new(MessageEntity)
					err3 = vv.Decode(d)
					_ = err3
					v9[i] = vv
				}
				m.Entities = v9
			}
			if (flags & (1 << 15)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 17)) != 0 {
				m.QuickReplyShortcutId = new(int32)
				*m.QuickReplyShortcutId, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditInlineBotMessage <--
type TLMessagesEditInlineBotMessage struct {
	ClazzID     uint32                   `json:"_id"`
	NoWebpage   bool                     `json:"no_webpage"`
	InvertMedia bool                     `json:"invert_media"`
	Id          *InputBotInlineMessageID `json:"id"`
	Message     *string                  `json:"message"`
	Media       *InputMedia              `json:"media"`
	ReplyMarkup *ReplyMarkup             `json:"reply_markup"`
	Entities    []*MessageEntity         `json:"entities"`
}

func (m *TLMessagesEditInlineBotMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditInlineBotMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x83557dba: func() error {
			x.PutClazzID(0x83557dba)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoWebpage == true {
					flags |= 1 << 1
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}

				if m.Message != nil {
					flags |= 1 << 11
				}
				if m.Media != nil {
					flags |= 1 << 14
				}
				if m.ReplyMarkup != nil {
					flags |= 1 << 2
				}
				if m.Entities != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)
			if m.Message != nil {
				x.PutString(*m.Message)
			}

			if m.Media != nil {
				_ = m.Media.Encode(x, layer)
			}

			if m.ReplyMarkup != nil {
				_ = m.ReplyMarkup.Encode(x, layer)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editInlineBotMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editInlineBotMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesEditInlineBotMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x83557dba: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.NoWebpage = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}

			m4 := &InputBotInlineMessageID{}
			_ = m4.Decode(d)
			m.Id = m4

			if (flags & (1 << 11)) != 0 {
				m.Message = new(string)
				*m.Message, err = d.String()
			}

			if (flags & (1 << 14)) != 0 {
				m6 := &InputMedia{}
				_ = m6.Decode(d)
				m.Media = m6
			}
			if (flags & (1 << 2)) != 0 {
				m7 := &ReplyMarkup{}
				_ = m7.Decode(d)
				m.ReplyMarkup = m7
			}
			if (flags & (1 << 3)) != 0 {
				c8, err2 := d.ClazzID()
				if c8 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 8, c8)
					return err2
				}
				l8, err3 := d.Int()
				v8 := make([]*MessageEntity, l8)
				for i := 0; i < l8; i++ {
					vv := new(MessageEntity)
					err3 = vv.Decode(d)
					_ = err3
					v8[i] = vv
				}
				m.Entities = v8
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetBotCallbackAnswer <--
type TLMessagesGetBotCallbackAnswer struct {
	ClazzID  uint32                 `json:"_id"`
	Game     bool                   `json:"game"`
	Peer     *InputPeer             `json:"peer"`
	MsgId    int32                  `json:"msg_id"`
	Data     []byte                 `json:"data"`
	Password *InputCheckPasswordSRP `json:"password"`
}

func (m *TLMessagesGetBotCallbackAnswer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetBotCallbackAnswer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9342ca07: func() error {
			x.PutClazzID(0x9342ca07)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Game == true {
					flags |= 1 << 1
				}

				if m.Data != nil {
					flags |= 1 << 0
				}
				if m.Password != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			if m.Data != nil {
				x.PutBytes(m.Data)
			}

			if m.Password != nil {
				_ = m.Password.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getBotCallbackAnswer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getBotCallbackAnswer, layer)
	}
}

// Decode <--
func (m *TLMessagesGetBotCallbackAnswer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9342ca07: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Game = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.MsgId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Data, err = d.Bytes()
			}

			if (flags & (1 << 2)) != 0 {
				m6 := &InputCheckPasswordSRP{}
				_ = m6.Decode(d)
				m.Password = m6
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetBotCallbackAnswer <--
type TLMessagesSetBotCallbackAnswer struct {
	ClazzID   uint32  `json:"_id"`
	Alert     bool    `json:"alert"`
	QueryId   int64   `json:"query_id"`
	Message   *string `json:"message"`
	Url       *string `json:"url"`
	CacheTime int32   `json:"cache_time"`
}

func (m *TLMessagesSetBotCallbackAnswer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetBotCallbackAnswer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd58f130a: func() error {
			x.PutClazzID(0xd58f130a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Alert == true {
					flags |= 1 << 1
				}

				if m.Message != nil {
					flags |= 1 << 0
				}
				if m.Url != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.QueryId)
			if m.Message != nil {
				x.PutString(*m.Message)
			}

			if m.Url != nil {
				x.PutString(*m.Url)
			}

			x.PutInt32(m.CacheTime)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setBotCallbackAnswer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setBotCallbackAnswer, layer)
	}
}

// Decode <--
func (m *TLMessagesSetBotCallbackAnswer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd58f130a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Alert = true
			}
			m.QueryId, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m.Message = new(string)
				*m.Message, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.Url = new(string)
				*m.Url, err = d.String()
			}

			m.CacheTime, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPeerDialogs <--
type TLMessagesGetPeerDialogs struct {
	ClazzID uint32             `json:"_id"`
	Peers   []*InputDialogPeer `json:"peers"`
}

func (m *TLMessagesGetPeerDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPeerDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe470bcfd: func() error {
			x.PutClazzID(0xe470bcfd)

			_ = iface.EncodeObjectList(x, m.Peers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPeerDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPeerDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPeerDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe470bcfd: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputDialogPeer, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputDialogPeer)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Peers = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSaveDraft <--
type TLMessagesSaveDraft struct {
	ClazzID     uint32           `json:"_id"`
	NoWebpage   bool             `json:"no_webpage"`
	InvertMedia bool             `json:"invert_media"`
	ReplyTo     *InputReplyTo    `json:"reply_to"`
	Peer        *InputPeer       `json:"peer"`
	Message     string           `json:"message"`
	Entities    []*MessageEntity `json:"entities"`
	Media       *InputMedia      `json:"media"`
	Effect      *int64           `json:"effect"`
}

func (m *TLMessagesSaveDraft) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSaveDraft) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd372c5ce: func() error {
			x.PutClazzID(0xd372c5ce)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.NoWebpage == true {
					flags |= 1 << 1
				}
				if m.InvertMedia == true {
					flags |= 1 << 6
				}
				if m.ReplyTo != nil {
					flags |= 1 << 4
				}

				if m.Entities != nil {
					flags |= 1 << 3
				}
				if m.Media != nil {
					flags |= 1 << 5
				}
				if m.Effect != nil {
					flags |= 1 << 7
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Message)
			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.Media != nil {
				_ = m.Media.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_saveDraft, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_saveDraft, layer)
	}
}

// Decode <--
func (m *TLMessagesSaveDraft) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd372c5ce: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.NoWebpage = true
			}
			if (flags & (1 << 6)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 4)) != 0 {
				m4 := &InputReplyTo{}
				_ = m4.Decode(d)
				m.ReplyTo = m4
			}

			m5 := &InputPeer{}
			_ = m5.Decode(d)
			m.Peer = m5

			m.Message, err = d.String()
			if (flags & (1 << 3)) != 0 {
				c7, err2 := d.ClazzID()
				if c7 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 7, c7)
					return err2
				}
				l7, err3 := d.Int()
				v7 := make([]*MessageEntity, l7)
				for i := 0; i < l7; i++ {
					vv := new(MessageEntity)
					err3 = vv.Decode(d)
					_ = err3
					v7[i] = vv
				}
				m.Entities = v7
			}
			if (flags & (1 << 5)) != 0 {
				m8 := &InputMedia{}
				_ = m8.Decode(d)
				m.Media = m8
			}
			if (flags & (1 << 7)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAllDrafts <--
type TLMessagesGetAllDrafts struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetAllDrafts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAllDrafts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6a3f8d65: func() error {
			x.PutClazzID(0x6a3f8d65)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAllDrafts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAllDrafts, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAllDrafts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6a3f8d65: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetFeaturedStickers <--
type TLMessagesGetFeaturedStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetFeaturedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetFeaturedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x64780b14: func() error {
			x.PutClazzID(0x64780b14)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getFeaturedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getFeaturedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetFeaturedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x64780b14: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadFeaturedStickers <--
type TLMessagesReadFeaturedStickers struct {
	ClazzID uint32  `json:"_id"`
	Id      []int64 `json:"id"`
}

func (m *TLMessagesReadFeaturedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadFeaturedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5b118126: func() error {
			x.PutClazzID(0x5b118126)

			iface.EncodeInt64List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readFeaturedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readFeaturedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesReadFeaturedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5b118126: func() (err error) {

			m.Id, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetRecentStickers <--
type TLMessagesGetRecentStickers struct {
	ClazzID  uint32 `json:"_id"`
	Attached bool   `json:"attached"`
	Hash     int64  `json:"hash"`
}

func (m *TLMessagesGetRecentStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetRecentStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9da9403b: func() error {
			x.PutClazzID(0x9da9403b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Attached == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getRecentStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getRecentStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetRecentStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9da9403b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Attached = true
			}
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSaveRecentSticker <--
type TLMessagesSaveRecentSticker struct {
	ClazzID  uint32         `json:"_id"`
	Attached bool           `json:"attached"`
	Id       *InputDocument `json:"id"`
	Unsave   *Bool          `json:"unsave"`
}

func (m *TLMessagesSaveRecentSticker) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSaveRecentSticker) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x392718f8: func() error {
			x.PutClazzID(0x392718f8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Attached == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)
			_ = m.Unsave.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_saveRecentSticker, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_saveRecentSticker, layer)
	}
}

// Decode <--
func (m *TLMessagesSaveRecentSticker) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x392718f8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Attached = true
			}

			m3 := &InputDocument{}
			_ = m3.Decode(d)
			m.Id = m3

			m4 := &Bool{}
			_ = m4.Decode(d)
			m.Unsave = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesClearRecentStickers <--
type TLMessagesClearRecentStickers struct {
	ClazzID  uint32 `json:"_id"`
	Attached bool   `json:"attached"`
}

func (m *TLMessagesClearRecentStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesClearRecentStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8999602d: func() error {
			x.PutClazzID(0x8999602d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Attached == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_clearRecentStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_clearRecentStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesClearRecentStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8999602d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Attached = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetArchivedStickers <--
type TLMessagesGetArchivedStickers struct {
	ClazzID  uint32 `json:"_id"`
	Masks    bool   `json:"masks"`
	Emojis   bool   `json:"emojis"`
	OffsetId int64  `json:"offset_id"`
	Limit    int32  `json:"limit"`
}

func (m *TLMessagesGetArchivedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetArchivedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x57f17692: func() error {
			x.PutClazzID(0x57f17692)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Masks == true {
					flags |= 1 << 0
				}
				if m.Emojis == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getArchivedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getArchivedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetArchivedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x57f17692: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Masks = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Emojis = true
			}
			m.OffsetId, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMaskStickers <--
type TLMessagesGetMaskStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetMaskStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMaskStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x640f82b8: func() error {
			x.PutClazzID(0x640f82b8)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMaskStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMaskStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMaskStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x640f82b8: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAttachedStickers <--
type TLMessagesGetAttachedStickers struct {
	ClazzID uint32               `json:"_id"`
	Media   *InputStickeredMedia `json:"media"`
}

func (m *TLMessagesGetAttachedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAttachedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcc5b67cc: func() error {
			x.PutClazzID(0xcc5b67cc)

			_ = m.Media.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAttachedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAttachedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAttachedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcc5b67cc: func() (err error) {

			m1 := &InputStickeredMedia{}
			_ = m1.Decode(d)
			m.Media = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetGameScore <--
type TLMessagesSetGameScore struct {
	ClazzID     uint32     `json:"_id"`
	EditMessage bool       `json:"edit_message"`
	Force       bool       `json:"force"`
	Peer        *InputPeer `json:"peer"`
	Id          int32      `json:"id"`
	UserId      *InputUser `json:"user_id"`
	Score       int32      `json:"score"`
}

func (m *TLMessagesSetGameScore) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetGameScore) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8ef8ecc0: func() error {
			x.PutClazzID(0x8ef8ecc0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.EditMessage == true {
					flags |= 1 << 0
				}
				if m.Force == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.Score)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setGameScore, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setGameScore, layer)
	}
}

// Decode <--
func (m *TLMessagesSetGameScore) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8ef8ecc0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.EditMessage = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Force = true
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			m.Id, err = d.Int32()

			m6 := &InputUser{}
			_ = m6.Decode(d)
			m.UserId = m6

			m.Score, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetInlineGameScore <--
type TLMessagesSetInlineGameScore struct {
	ClazzID     uint32                   `json:"_id"`
	EditMessage bool                     `json:"edit_message"`
	Force       bool                     `json:"force"`
	Id          *InputBotInlineMessageID `json:"id"`
	UserId      *InputUser               `json:"user_id"`
	Score       int32                    `json:"score"`
}

func (m *TLMessagesSetInlineGameScore) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetInlineGameScore) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x15ad9f64: func() error {
			x.PutClazzID(0x15ad9f64)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.EditMessage == true {
					flags |= 1 << 0
				}
				if m.Force == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Id.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.Score)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setInlineGameScore, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setInlineGameScore, layer)
	}
}

// Decode <--
func (m *TLMessagesSetInlineGameScore) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x15ad9f64: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.EditMessage = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Force = true
			}

			m4 := &InputBotInlineMessageID{}
			_ = m4.Decode(d)
			m.Id = m4

			m5 := &InputUser{}
			_ = m5.Decode(d)
			m.UserId = m5

			m.Score, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetGameHighScores <--
type TLMessagesGetGameHighScores struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      int32      `json:"id"`
	UserId  *InputUser `json:"user_id"`
}

func (m *TLMessagesGetGameHighScores) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetGameHighScores) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe822649d: func() error {
			x.PutClazzID(0xe822649d)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getGameHighScores, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getGameHighScores, layer)
	}
}

// Decode <--
func (m *TLMessagesGetGameHighScores) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe822649d: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = d.Int32()

			m3 := &InputUser{}
			_ = m3.Decode(d)
			m.UserId = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetInlineGameHighScores <--
type TLMessagesGetInlineGameHighScores struct {
	ClazzID uint32                   `json:"_id"`
	Id      *InputBotInlineMessageID `json:"id"`
	UserId  *InputUser               `json:"user_id"`
}

func (m *TLMessagesGetInlineGameHighScores) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetInlineGameHighScores) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf635e1b: func() error {
			x.PutClazzID(0xf635e1b)

			_ = m.Id.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getInlineGameHighScores, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getInlineGameHighScores, layer)
	}
}

// Decode <--
func (m *TLMessagesGetInlineGameHighScores) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf635e1b: func() (err error) {

			m1 := &InputBotInlineMessageID{}
			_ = m1.Decode(d)
			m.Id = m1

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.UserId = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetCommonChats <--
type TLMessagesGetCommonChats struct {
	ClazzID uint32     `json:"_id"`
	UserId  *InputUser `json:"user_id"`
	MaxId   int64      `json:"max_id"`
	Limit   int32      `json:"limit"`
}

func (m *TLMessagesGetCommonChats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetCommonChats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe40ca104: func() error {
			x.PutClazzID(0xe40ca104)

			_ = m.UserId.Encode(x, layer)
			x.PutInt64(m.MaxId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getCommonChats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getCommonChats, layer)
	}
}

// Decode <--
func (m *TLMessagesGetCommonChats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe40ca104: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.UserId = m1

			m.MaxId, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetWebPage <--
type TLMessagesGetWebPage struct {
	ClazzID uint32 `json:"_id"`
	Url     string `json:"url"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetWebPage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetWebPage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8d9692a3: func() error {
			x.PutClazzID(0x8d9692a3)

			x.PutString(m.Url)
			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getWebPage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getWebPage, layer)
	}
}

// Decode <--
func (m *TLMessagesGetWebPage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8d9692a3: func() (err error) {
			m.Url, err = d.String()
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleDialogPin <--
type TLMessagesToggleDialogPin struct {
	ClazzID uint32           `json:"_id"`
	Pinned  bool             `json:"pinned"`
	Peer    *InputDialogPeer `json:"peer"`
}

func (m *TLMessagesToggleDialogPin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleDialogPin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa731e257: func() error {
			x.PutClazzID(0xa731e257)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Pinned == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleDialogPin, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleDialogPin, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleDialogPin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa731e257: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Pinned = true
			}

			m3 := &InputDialogPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReorderPinnedDialogs <--
type TLMessagesReorderPinnedDialogs struct {
	ClazzID  uint32             `json:"_id"`
	Force    bool               `json:"force"`
	FolderId int32              `json:"folder_id"`
	Order    []*InputDialogPeer `json:"order"`
}

func (m *TLMessagesReorderPinnedDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReorderPinnedDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3b1adf37: func() error {
			x.PutClazzID(0x3b1adf37)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Force == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.FolderId)

			_ = iface.EncodeObjectList(x, m.Order, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reorderPinnedDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reorderPinnedDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesReorderPinnedDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3b1adf37: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Force = true
			}
			m.FolderId, err = d.Int32()
			c4, err2 := d.ClazzID()
			if c4 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
				return err2
			}
			l4, err3 := d.Int()
			v4 := make([]*InputDialogPeer, l4)
			for i := 0; i < l4; i++ {
				vv := new(InputDialogPeer)
				err3 = vv.Decode(d)
				_ = err3
				v4[i] = vv
			}
			m.Order = v4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPinnedDialogs <--
type TLMessagesGetPinnedDialogs struct {
	ClazzID  uint32 `json:"_id"`
	FolderId int32  `json:"folder_id"`
}

func (m *TLMessagesGetPinnedDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPinnedDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd6b94df2: func() error {
			x.PutClazzID(0xd6b94df2)

			x.PutInt32(m.FolderId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPinnedDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPinnedDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPinnedDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd6b94df2: func() (err error) {
			m.FolderId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetBotShippingResults <--
type TLMessagesSetBotShippingResults struct {
	ClazzID         uint32            `json:"_id"`
	QueryId         int64             `json:"query_id"`
	Error           *string           `json:"error"`
	ShippingOptions []*ShippingOption `json:"shipping_options"`
}

func (m *TLMessagesSetBotShippingResults) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetBotShippingResults) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe5f672fa: func() error {
			x.PutClazzID(0xe5f672fa)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Error != nil {
					flags |= 1 << 0
				}
				if m.ShippingOptions != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.QueryId)
			if m.Error != nil {
				x.PutString(*m.Error)
			}

			if m.ShippingOptions != nil {
				_ = iface.EncodeObjectList(x, m.ShippingOptions, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setBotShippingResults, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setBotShippingResults, layer)
	}
}

// Decode <--
func (m *TLMessagesSetBotShippingResults) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe5f672fa: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.QueryId, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m.Error = new(string)
				*m.Error, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				c4, err2 := d.ClazzID()
				if c4 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
					return err2
				}
				l4, err3 := d.Int()
				v4 := make([]*ShippingOption, l4)
				for i := 0; i < l4; i++ {
					vv := new(ShippingOption)
					err3 = vv.Decode(d)
					_ = err3
					v4[i] = vv
				}
				m.ShippingOptions = v4
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetBotPrecheckoutResults <--
type TLMessagesSetBotPrecheckoutResults struct {
	ClazzID uint32  `json:"_id"`
	Success bool    `json:"success"`
	QueryId int64   `json:"query_id"`
	Error   *string `json:"error"`
}

func (m *TLMessagesSetBotPrecheckoutResults) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetBotPrecheckoutResults) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9c2dd95: func() error {
			x.PutClazzID(0x9c2dd95)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Success == true {
					flags |= 1 << 1
				}

				if m.Error != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.QueryId)
			if m.Error != nil {
				x.PutString(*m.Error)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setBotPrecheckoutResults, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setBotPrecheckoutResults, layer)
	}
}

// Decode <--
func (m *TLMessagesSetBotPrecheckoutResults) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9c2dd95: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Success = true
			}
			m.QueryId, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m.Error = new(string)
				*m.Error, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUploadMedia <--
type TLMessagesUploadMedia struct {
	ClazzID              uint32      `json:"_id"`
	BusinessConnectionId *string     `json:"business_connection_id"`
	Peer                 *InputPeer  `json:"peer"`
	Media                *InputMedia `json:"media"`
}

func (m *TLMessagesUploadMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUploadMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x14967978: func() error {
			x.PutClazzID(0x14967978)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.BusinessConnectionId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.BusinessConnectionId != nil {
				x.PutString(*m.BusinessConnectionId)
			}

			_ = m.Peer.Encode(x, layer)
			_ = m.Media.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_uploadMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_uploadMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesUploadMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x14967978: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.BusinessConnectionId = new(string)
				*m.BusinessConnectionId, err = d.String()
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m4 := &InputMedia{}
			_ = m4.Decode(d)
			m.Media = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendScreenshotNotification <--
type TLMessagesSendScreenshotNotification struct {
	ClazzID  uint32        `json:"_id"`
	Peer     *InputPeer    `json:"peer"`
	ReplyTo  *InputReplyTo `json:"reply_to"`
	RandomId int64         `json:"random_id"`
}

func (m *TLMessagesSendScreenshotNotification) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendScreenshotNotification) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa1405817: func() error {
			x.PutClazzID(0xa1405817)

			_ = m.Peer.Encode(x, layer)
			_ = m.ReplyTo.Encode(x, layer)
			x.PutInt64(m.RandomId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendScreenshotNotification, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendScreenshotNotification, layer)
	}
}

// Decode <--
func (m *TLMessagesSendScreenshotNotification) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa1405817: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputReplyTo{}
			_ = m2.Decode(d)
			m.ReplyTo = m2

			m.RandomId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetFavedStickers <--
type TLMessagesGetFavedStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetFavedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetFavedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4f1aaa9: func() error {
			x.PutClazzID(0x4f1aaa9)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getFavedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getFavedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetFavedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4f1aaa9: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesFaveSticker <--
type TLMessagesFaveSticker struct {
	ClazzID uint32         `json:"_id"`
	Id      *InputDocument `json:"id"`
	Unfave  *Bool          `json:"unfave"`
}

func (m *TLMessagesFaveSticker) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesFaveSticker) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb9ffc55b: func() error {
			x.PutClazzID(0xb9ffc55b)

			_ = m.Id.Encode(x, layer)
			_ = m.Unfave.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_faveSticker, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_faveSticker, layer)
	}
}

// Decode <--
func (m *TLMessagesFaveSticker) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb9ffc55b: func() (err error) {

			m1 := &InputDocument{}
			_ = m1.Decode(d)
			m.Id = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Unfave = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetUnreadMentions <--
type TLMessagesGetUnreadMentions struct {
	ClazzID   uint32     `json:"_id"`
	Peer      *InputPeer `json:"peer"`
	TopMsgId  *int32     `json:"top_msg_id"`
	OffsetId  int32      `json:"offset_id"`
	AddOffset int32      `json:"add_offset"`
	Limit     int32      `json:"limit"`
	MaxId     int32      `json:"max_id"`
	MinId     int32      `json:"min_id"`
}

func (m *TLMessagesGetUnreadMentions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetUnreadMentions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf107e790: func() error {
			x.PutClazzID(0xf107e790)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			x.PutInt32(m.OffsetId)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getUnreadMentions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getUnreadMentions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetUnreadMentions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf107e790: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			m.OffsetId, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadMentions <--
type TLMessagesReadMentions struct {
	ClazzID  uint32     `json:"_id"`
	Peer     *InputPeer `json:"peer"`
	TopMsgId *int32     `json:"top_msg_id"`
}

func (m *TLMessagesReadMentions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadMentions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x36e5bf4d: func() error {
			x.PutClazzID(0x36e5bf4d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readMentions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readMentions, layer)
	}
}

// Decode <--
func (m *TLMessagesReadMentions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x36e5bf4d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetRecentLocations <--
type TLMessagesGetRecentLocations struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Limit   int32      `json:"limit"`
	Hash    int64      `json:"hash"`
}

func (m *TLMessagesGetRecentLocations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetRecentLocations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x702a40e0: func() error {
			x.PutClazzID(0x702a40e0)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getRecentLocations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getRecentLocations, layer)
	}
}

// Decode <--
func (m *TLMessagesGetRecentLocations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x702a40e0: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendMultiMedia <--
type TLMessagesSendMultiMedia struct {
	ClazzID                uint32                   `json:"_id"`
	Silent                 bool                     `json:"silent"`
	Background             bool                     `json:"background"`
	ClearDraft             bool                     `json:"clear_draft"`
	Noforwards             bool                     `json:"noforwards"`
	UpdateStickersetsOrder bool                     `json:"update_stickersets_order"`
	InvertMedia            bool                     `json:"invert_media"`
	AllowPaidFloodskip     bool                     `json:"allow_paid_floodskip"`
	Peer                   *InputPeer               `json:"peer"`
	ReplyTo                *InputReplyTo            `json:"reply_to"`
	MultiMedia             []*InputSingleMedia      `json:"multi_media"`
	ScheduleDate           *int32                   `json:"schedule_date"`
	SendAs                 *InputPeer               `json:"send_as"`
	QuickReplyShortcut     *InputQuickReplyShortcut `json:"quick_reply_shortcut"`
	Effect                 *int64                   `json:"effect"`
	AllowPaidStars         *int64                   `json:"allow_paid_stars"`
}

func (m *TLMessagesSendMultiMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendMultiMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1bf89d74: func() error {
			x.PutClazzID(0x1bf89d74)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.UpdateStickersetsOrder == true {
					flags |= 1 << 15
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.Effect != nil {
					flags |= 1 << 18
				}
				if m.AllowPaidStars != nil {
					flags |= 1 << 21
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			_ = iface.EncodeObjectList(x, m.MultiMedia, layer)

			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			if m.AllowPaidStars != nil {
				x.PutInt64(*m.AllowPaidStars)
			}

			return nil
		},
		0x37b74355: func() error {
			x.PutClazzID(0x37b74355)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Background == true {
					flags |= 1 << 6
				}
				if m.ClearDraft == true {
					flags |= 1 << 7
				}
				if m.Noforwards == true {
					flags |= 1 << 14
				}
				if m.UpdateStickersetsOrder == true {
					flags |= 1 << 15
				}
				if m.InvertMedia == true {
					flags |= 1 << 16
				}
				if m.AllowPaidFloodskip == true {
					flags |= 1 << 19
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}

				if m.ScheduleDate != nil {
					flags |= 1 << 10
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}
				if m.QuickReplyShortcut != nil {
					flags |= 1 << 17
				}
				if m.Effect != nil {
					flags |= 1 << 18
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			_ = iface.EncodeObjectList(x, m.MultiMedia, layer)

			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			if m.QuickReplyShortcut != nil {
				_ = m.QuickReplyShortcut.Encode(x, layer)
			}

			if m.Effect != nil {
				x.PutInt64(*m.Effect)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendMultiMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendMultiMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesSendMultiMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1bf89d74: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 15)) != 0 {
				m.UpdateStickersetsOrder = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			m9 := &InputPeer{}
			_ = m9.Decode(d)
			m.Peer = m9

			if (flags & (1 << 0)) != 0 {
				m10 := &InputReplyTo{}
				_ = m10.Decode(d)
				m.ReplyTo = m10
			}
			c11, err2 := d.ClazzID()
			if c11 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 11, c11)
				return err2
			}
			l11, err3 := d.Int()
			v11 := make([]*InputSingleMedia, l11)
			for i := 0; i < l11; i++ {
				vv := new(InputSingleMedia)
				err3 = vv.Decode(d)
				_ = err3
				v11[i] = vv
			}
			m.MultiMedia = v11

			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				m13 := &InputPeer{}
				_ = m13.Decode(d)
				m.SendAs = m13
			}
			if (flags & (1 << 17)) != 0 {
				m14 := &InputQuickReplyShortcut{}
				_ = m14.Decode(d)
				m.QuickReplyShortcut = m14
			}
			if (flags & (1 << 18)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			if (flags & (1 << 21)) != 0 {
				m.AllowPaidStars = new(int64)
				*m.AllowPaidStars, err = d.Int64()
			}

			return nil
		},
		0x37b74355: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 6)) != 0 {
				m.Background = true
			}
			if (flags & (1 << 7)) != 0 {
				m.ClearDraft = true
			}
			if (flags & (1 << 14)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 15)) != 0 {
				m.UpdateStickersetsOrder = true
			}
			if (flags & (1 << 16)) != 0 {
				m.InvertMedia = true
			}
			if (flags & (1 << 19)) != 0 {
				m.AllowPaidFloodskip = true
			}

			m9 := &InputPeer{}
			_ = m9.Decode(d)
			m.Peer = m9

			if (flags & (1 << 0)) != 0 {
				m10 := &InputReplyTo{}
				_ = m10.Decode(d)
				m.ReplyTo = m10
			}
			c11, err2 := d.ClazzID()
			if c11 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 11, c11)
				return err2
			}
			l11, err3 := d.Int()
			v11 := make([]*InputSingleMedia, l11)
			for i := 0; i < l11; i++ {
				vv := new(InputSingleMedia)
				err3 = vv.Decode(d)
				_ = err3
				v11[i] = vv
			}
			m.MultiMedia = v11

			if (flags & (1 << 10)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}
			if (flags & (1 << 13)) != 0 {
				m13 := &InputPeer{}
				_ = m13.Decode(d)
				m.SendAs = m13
			}
			if (flags & (1 << 17)) != 0 {
				m14 := &InputQuickReplyShortcut{}
				_ = m14.Decode(d)
				m.QuickReplyShortcut = m14
			}
			if (flags & (1 << 18)) != 0 {
				m.Effect = new(int64)
				*m.Effect, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUploadEncryptedFile <--
type TLMessagesUploadEncryptedFile struct {
	ClazzID uint32              `json:"_id"`
	Peer    *InputEncryptedChat `json:"peer"`
	File    *InputEncryptedFile `json:"file"`
}

func (m *TLMessagesUploadEncryptedFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUploadEncryptedFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5057c497: func() error {
			x.PutClazzID(0x5057c497)

			_ = m.Peer.Encode(x, layer)
			_ = m.File.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_uploadEncryptedFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_uploadEncryptedFile, layer)
	}
}

// Decode <--
func (m *TLMessagesUploadEncryptedFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5057c497: func() (err error) {

			m1 := &InputEncryptedChat{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputEncryptedFile{}
			_ = m2.Decode(d)
			m.File = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchStickerSets <--
type TLMessagesSearchStickerSets struct {
	ClazzID         uint32 `json:"_id"`
	ExcludeFeatured bool   `json:"exclude_featured"`
	Q               string `json:"q"`
	Hash            int64  `json:"hash"`
}

func (m *TLMessagesSearchStickerSets) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchStickerSets) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x35705b8a: func() error {
			x.PutClazzID(0x35705b8a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ExcludeFeatured == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Q)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchStickerSets, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchStickerSets, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchStickerSets) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x35705b8a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ExcludeFeatured = true
			}
			m.Q, err = d.String()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSplitRanges <--
type TLMessagesGetSplitRanges struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetSplitRanges) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSplitRanges) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1cff7e08: func() error {
			x.PutClazzID(0x1cff7e08)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSplitRanges, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSplitRanges, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSplitRanges) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1cff7e08: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesMarkDialogUnread <--
type TLMessagesMarkDialogUnread struct {
	ClazzID uint32           `json:"_id"`
	Unread  bool             `json:"unread"`
	Peer    *InputDialogPeer `json:"peer"`
}

func (m *TLMessagesMarkDialogUnread) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesMarkDialogUnread) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc286d98f: func() error {
			x.PutClazzID(0xc286d98f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Unread == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_markDialogUnread, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_markDialogUnread, layer)
	}
}

// Decode <--
func (m *TLMessagesMarkDialogUnread) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc286d98f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Unread = true
			}

			m3 := &InputDialogPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDialogUnreadMarks <--
type TLMessagesGetDialogUnreadMarks struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetDialogUnreadMarks) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDialogUnreadMarks) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x22e24e22: func() error {
			x.PutClazzID(0x22e24e22)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDialogUnreadMarks, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDialogUnreadMarks, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDialogUnreadMarks) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x22e24e22: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesClearAllDrafts <--
type TLMessagesClearAllDrafts struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesClearAllDrafts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesClearAllDrafts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7e58ee9c: func() error {
			x.PutClazzID(0x7e58ee9c)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_clearAllDrafts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_clearAllDrafts, layer)
	}
}

// Decode <--
func (m *TLMessagesClearAllDrafts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7e58ee9c: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUpdatePinnedMessage <--
type TLMessagesUpdatePinnedMessage struct {
	ClazzID   uint32     `json:"_id"`
	Silent    bool       `json:"silent"`
	Unpin     bool       `json:"unpin"`
	PmOneside bool       `json:"pm_oneside"`
	Peer      *InputPeer `json:"peer"`
	Id        int32      `json:"id"`
}

func (m *TLMessagesUpdatePinnedMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUpdatePinnedMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd2aaf7ec: func() error {
			x.PutClazzID(0xd2aaf7ec)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 0
				}
				if m.Unpin == true {
					flags |= 1 << 1
				}
				if m.PmOneside == true {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_updatePinnedMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_updatePinnedMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesUpdatePinnedMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd2aaf7ec: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Unpin = true
			}
			if (flags & (1 << 2)) != 0 {
				m.PmOneside = true
			}

			m5 := &InputPeer{}
			_ = m5.Decode(d)
			m.Peer = m5

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendVote <--
type TLMessagesSendVote struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MsgId   int32      `json:"msg_id"`
	Options [][]byte   `json:"options"`
}

func (m *TLMessagesSendVote) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendVote) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x10ea6184: func() error {
			x.PutClazzID(0x10ea6184)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			iface.EncodeBytesList(x, m.Options)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendVote, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendVote, layer)
	}
}

// Decode <--
func (m *TLMessagesSendVote) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x10ea6184: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			m.Options, err = iface.DecodeBytesList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPollResults <--
type TLMessagesGetPollResults struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MsgId   int32      `json:"msg_id"`
}

func (m *TLMessagesGetPollResults) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPollResults) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x73bb643b: func() error {
			x.PutClazzID(0x73bb643b)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPollResults, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPollResults, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPollResults) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x73bb643b: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetOnlines <--
type TLMessagesGetOnlines struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLMessagesGetOnlines) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetOnlines) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6e2be050: func() error {
			x.PutClazzID(0x6e2be050)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getOnlines, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getOnlines, layer)
	}
}

// Decode <--
func (m *TLMessagesGetOnlines) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6e2be050: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditChatAbout <--
type TLMessagesEditChatAbout struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	About   string     `json:"about"`
}

func (m *TLMessagesEditChatAbout) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditChatAbout) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdef60797: func() error {
			x.PutClazzID(0xdef60797)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.About)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editChatAbout, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editChatAbout, layer)
	}
}

// Decode <--
func (m *TLMessagesEditChatAbout) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdef60797: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.About, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditChatDefaultBannedRights <--
type TLMessagesEditChatDefaultBannedRights struct {
	ClazzID      uint32            `json:"_id"`
	Peer         *InputPeer        `json:"peer"`
	BannedRights *ChatBannedRights `json:"banned_rights"`
}

func (m *TLMessagesEditChatDefaultBannedRights) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditChatDefaultBannedRights) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa5866b41: func() error {
			x.PutClazzID(0xa5866b41)

			_ = m.Peer.Encode(x, layer)
			_ = m.BannedRights.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editChatDefaultBannedRights, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editChatDefaultBannedRights, layer)
	}
}

// Decode <--
func (m *TLMessagesEditChatDefaultBannedRights) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa5866b41: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &ChatBannedRights{}
			_ = m2.Decode(d)
			m.BannedRights = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiKeywords <--
type TLMessagesGetEmojiKeywords struct {
	ClazzID  uint32 `json:"_id"`
	LangCode string `json:"lang_code"`
}

func (m *TLMessagesGetEmojiKeywords) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiKeywords) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x35a0e062: func() error {
			x.PutClazzID(0x35a0e062)

			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiKeywords, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiKeywords, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiKeywords) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x35a0e062: func() (err error) {
			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiKeywordsDifference <--
type TLMessagesGetEmojiKeywordsDifference struct {
	ClazzID     uint32 `json:"_id"`
	LangCode    string `json:"lang_code"`
	FromVersion int32  `json:"from_version"`
}

func (m *TLMessagesGetEmojiKeywordsDifference) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiKeywordsDifference) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1508b6af: func() error {
			x.PutClazzID(0x1508b6af)

			x.PutString(m.LangCode)
			x.PutInt32(m.FromVersion)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiKeywordsDifference, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiKeywordsDifference, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiKeywordsDifference) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1508b6af: func() (err error) {
			m.LangCode, err = d.String()
			m.FromVersion, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiKeywordsLanguages <--
type TLMessagesGetEmojiKeywordsLanguages struct {
	ClazzID   uint32   `json:"_id"`
	LangCodes []string `json:"lang_codes"`
}

func (m *TLMessagesGetEmojiKeywordsLanguages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiKeywordsLanguages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4e9963b2: func() error {
			x.PutClazzID(0x4e9963b2)

			iface.EncodeStringList(x, m.LangCodes)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiKeywordsLanguages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiKeywordsLanguages, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiKeywordsLanguages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4e9963b2: func() (err error) {

			m.LangCodes, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiURL <--
type TLMessagesGetEmojiURL struct {
	ClazzID  uint32 `json:"_id"`
	LangCode string `json:"lang_code"`
}

func (m *TLMessagesGetEmojiURL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiURL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd5b10c26: func() error {
			x.PutClazzID(0xd5b10c26)

			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiURL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiURL, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiURL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd5b10c26: func() (err error) {
			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSearchCounters <--
type TLMessagesGetSearchCounters struct {
	ClazzID     uint32            `json:"_id"`
	Peer        *InputPeer        `json:"peer"`
	SavedPeerId *InputPeer        `json:"saved_peer_id"`
	TopMsgId    *int32            `json:"top_msg_id"`
	Filters     []*MessagesFilter `json:"filters"`
}

func (m *TLMessagesGetSearchCounters) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSearchCounters) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1bbcf300: func() error {
			x.PutClazzID(0x1bbcf300)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SavedPeerId != nil {
					flags |= 1 << 2
				}
				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			_ = iface.EncodeObjectList(x, m.Filters, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSearchCounters, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSearchCounters, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSearchCounters) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1bbcf300: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			if (flags & (1 << 2)) != 0 {
				m3 := &InputPeer{}
				_ = m3.Decode(d)
				m.SavedPeerId = m3
			}
			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			c5, err2 := d.ClazzID()
			if c5 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
				return err2
			}
			l5, err3 := d.Int()
			v5 := make([]*MessagesFilter, l5)
			for i := 0; i < l5; i++ {
				vv := new(MessagesFilter)
				err3 = vv.Decode(d)
				_ = err3
				v5[i] = vv
			}
			m.Filters = v5

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestUrlAuth <--
type TLMessagesRequestUrlAuth struct {
	ClazzID  uint32     `json:"_id"`
	Peer     *InputPeer `json:"peer"`
	MsgId    *int32     `json:"msg_id"`
	ButtonId *int32     `json:"button_id"`
	Url      *string    `json:"url"`
}

func (m *TLMessagesRequestUrlAuth) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestUrlAuth) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x198fb446: func() error {
			x.PutClazzID(0x198fb446)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Peer != nil {
					flags |= 1 << 1
				}
				if m.MsgId != nil {
					flags |= 1 << 1
				}
				if m.ButtonId != nil {
					flags |= 1 << 1
				}
				if m.Url != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			if m.MsgId != nil {
				x.PutInt32(*m.MsgId)
			}

			if m.ButtonId != nil {
				x.PutInt32(*m.ButtonId)
			}

			if m.Url != nil {
				x.PutString(*m.Url)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestUrlAuth, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestUrlAuth, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestUrlAuth) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x198fb446: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m2 := &InputPeer{}
				_ = m2.Decode(d)
				m.Peer = m2
			}
			if (flags & (1 << 1)) != 0 {
				m.MsgId = new(int32)
				*m.MsgId, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m.ButtonId = new(int32)
				*m.ButtonId, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				m.Url = new(string)
				*m.Url, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesAcceptUrlAuth <--
type TLMessagesAcceptUrlAuth struct {
	ClazzID      uint32     `json:"_id"`
	WriteAllowed bool       `json:"write_allowed"`
	Peer         *InputPeer `json:"peer"`
	MsgId        *int32     `json:"msg_id"`
	ButtonId     *int32     `json:"button_id"`
	Url          *string    `json:"url"`
}

func (m *TLMessagesAcceptUrlAuth) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesAcceptUrlAuth) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb12c7125: func() error {
			x.PutClazzID(0xb12c7125)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.WriteAllowed == true {
					flags |= 1 << 0
				}
				if m.Peer != nil {
					flags |= 1 << 1
				}
				if m.MsgId != nil {
					flags |= 1 << 1
				}
				if m.ButtonId != nil {
					flags |= 1 << 1
				}
				if m.Url != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			if m.MsgId != nil {
				x.PutInt32(*m.MsgId)
			}

			if m.ButtonId != nil {
				x.PutInt32(*m.ButtonId)
			}

			if m.Url != nil {
				x.PutString(*m.Url)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_acceptUrlAuth, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_acceptUrlAuth, layer)
	}
}

// Decode <--
func (m *TLMessagesAcceptUrlAuth) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb12c7125: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.WriteAllowed = true
			}
			if (flags & (1 << 1)) != 0 {
				m3 := &InputPeer{}
				_ = m3.Decode(d)
				m.Peer = m3
			}
			if (flags & (1 << 1)) != 0 {
				m.MsgId = new(int32)
				*m.MsgId, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m.ButtonId = new(int32)
				*m.ButtonId, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				m.Url = new(string)
				*m.Url, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesHidePeerSettingsBar <--
type TLMessagesHidePeerSettingsBar struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLMessagesHidePeerSettingsBar) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesHidePeerSettingsBar) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4facb138: func() error {
			x.PutClazzID(0x4facb138)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_hidePeerSettingsBar, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_hidePeerSettingsBar, layer)
	}
}

// Decode <--
func (m *TLMessagesHidePeerSettingsBar) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4facb138: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetScheduledHistory <--
type TLMessagesGetScheduledHistory struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Hash    int64      `json:"hash"`
}

func (m *TLMessagesGetScheduledHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetScheduledHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf516760b: func() error {
			x.PutClazzID(0xf516760b)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getScheduledHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getScheduledHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesGetScheduledHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf516760b: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetScheduledMessages <--
type TLMessagesGetScheduledMessages struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLMessagesGetScheduledMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetScheduledMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbdbb0464: func() error {
			x.PutClazzID(0xbdbb0464)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getScheduledMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getScheduledMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesGetScheduledMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbdbb0464: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendScheduledMessages <--
type TLMessagesSendScheduledMessages struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLMessagesSendScheduledMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendScheduledMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbd38850a: func() error {
			x.PutClazzID(0xbd38850a)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendScheduledMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendScheduledMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesSendScheduledMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbd38850a: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteScheduledMessages <--
type TLMessagesDeleteScheduledMessages struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLMessagesDeleteScheduledMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteScheduledMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x59ae2b16: func() error {
			x.PutClazzID(0x59ae2b16)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteScheduledMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteScheduledMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteScheduledMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x59ae2b16: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPollVotes <--
type TLMessagesGetPollVotes struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      int32      `json:"id"`
	Option  []byte     `json:"option"`
	Offset  *string    `json:"offset"`
	Limit   int32      `json:"limit"`
}

func (m *TLMessagesGetPollVotes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPollVotes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb86e380e: func() error {
			x.PutClazzID(0xb86e380e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Option != nil {
					flags |= 1 << 0
				}
				if m.Offset != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			if m.Option != nil {
				x.PutBytes(m.Option)
			}

			if m.Offset != nil {
				x.PutString(*m.Offset)
			}

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPollVotes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPollVotes, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPollVotes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb86e380e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			m.Id, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Option, err = d.Bytes()
			}

			if (flags & (1 << 1)) != 0 {
				m.Offset = new(string)
				*m.Offset, err = d.String()
			}

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleStickerSets <--
type TLMessagesToggleStickerSets struct {
	ClazzID     uint32             `json:"_id"`
	Uninstall   bool               `json:"uninstall"`
	Archive     bool               `json:"archive"`
	Unarchive   bool               `json:"unarchive"`
	Stickersets []*InputStickerSet `json:"stickersets"`
}

func (m *TLMessagesToggleStickerSets) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleStickerSets) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb5052fea: func() error {
			x.PutClazzID(0xb5052fea)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Uninstall == true {
					flags |= 1 << 0
				}
				if m.Archive == true {
					flags |= 1 << 1
				}
				if m.Unarchive == true {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			_ = iface.EncodeObjectList(x, m.Stickersets, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleStickerSets, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleStickerSets, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleStickerSets) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb5052fea: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Uninstall = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Archive = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Unarchive = true
			}
			c5, err2 := d.ClazzID()
			if c5 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
				return err2
			}
			l5, err3 := d.Int()
			v5 := make([]*InputStickerSet, l5)
			for i := 0; i < l5; i++ {
				vv := new(InputStickerSet)
				err3 = vv.Decode(d)
				_ = err3
				v5[i] = vv
			}
			m.Stickersets = v5

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDialogFilters <--
type TLMessagesGetDialogFilters struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetDialogFilters) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDialogFilters) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xefd48c89: func() error {
			x.PutClazzID(0xefd48c89)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDialogFilters, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDialogFilters, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDialogFilters) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xefd48c89: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSuggestedDialogFilters <--
type TLMessagesGetSuggestedDialogFilters struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetSuggestedDialogFilters) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSuggestedDialogFilters) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa29cd42c: func() error {
			x.PutClazzID(0xa29cd42c)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSuggestedDialogFilters, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSuggestedDialogFilters, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSuggestedDialogFilters) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa29cd42c: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUpdateDialogFilter <--
type TLMessagesUpdateDialogFilter struct {
	ClazzID uint32        `json:"_id"`
	Id      int32         `json:"id"`
	Filter  *DialogFilter `json:"filter"`
}

func (m *TLMessagesUpdateDialogFilter) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUpdateDialogFilter) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1ad4a04a: func() error {
			x.PutClazzID(0x1ad4a04a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Filter != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.Id)
			if m.Filter != nil {
				_ = m.Filter.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_updateDialogFilter, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_updateDialogFilter, layer)
	}
}

// Decode <--
func (m *TLMessagesUpdateDialogFilter) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1ad4a04a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Id, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m3 := &DialogFilter{}
				_ = m3.Decode(d)
				m.Filter = m3
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUpdateDialogFiltersOrder <--
type TLMessagesUpdateDialogFiltersOrder struct {
	ClazzID uint32  `json:"_id"`
	Order   []int32 `json:"order"`
}

func (m *TLMessagesUpdateDialogFiltersOrder) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUpdateDialogFiltersOrder) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc563c1e4: func() error {
			x.PutClazzID(0xc563c1e4)

			iface.EncodeInt32List(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_updateDialogFiltersOrder, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_updateDialogFiltersOrder, layer)
	}
}

// Decode <--
func (m *TLMessagesUpdateDialogFiltersOrder) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc563c1e4: func() (err error) {

			m.Order, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetOldFeaturedStickers <--
type TLMessagesGetOldFeaturedStickers struct {
	ClazzID uint32 `json:"_id"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetOldFeaturedStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetOldFeaturedStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7ed094a1: func() error {
			x.PutClazzID(0x7ed094a1)

			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getOldFeaturedStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getOldFeaturedStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetOldFeaturedStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7ed094a1: func() (err error) {
			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetReplies <--
type TLMessagesGetReplies struct {
	ClazzID    uint32     `json:"_id"`
	Peer       *InputPeer `json:"peer"`
	MsgId      int32      `json:"msg_id"`
	OffsetId   int32      `json:"offset_id"`
	OffsetDate int32      `json:"offset_date"`
	AddOffset  int32      `json:"add_offset"`
	Limit      int32      `json:"limit"`
	MaxId      int32      `json:"max_id"`
	MinId      int32      `json:"min_id"`
	Hash       int64      `json:"hash"`
}

func (m *TLMessagesGetReplies) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetReplies) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x22ddd30c: func() error {
			x.PutClazzID(0x22ddd30c)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getReplies, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getReplies, layer)
	}
}

// Decode <--
func (m *TLMessagesGetReplies) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x22ddd30c: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()
			m.OffsetId, err = d.Int32()
			m.OffsetDate, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDiscussionMessage <--
type TLMessagesGetDiscussionMessage struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MsgId   int32      `json:"msg_id"`
}

func (m *TLMessagesGetDiscussionMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDiscussionMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x446972fd: func() error {
			x.PutClazzID(0x446972fd)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDiscussionMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDiscussionMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDiscussionMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x446972fd: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadDiscussion <--
type TLMessagesReadDiscussion struct {
	ClazzID   uint32     `json:"_id"`
	Peer      *InputPeer `json:"peer"`
	MsgId     int32      `json:"msg_id"`
	ReadMaxId int32      `json:"read_max_id"`
}

func (m *TLMessagesReadDiscussion) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadDiscussion) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf731a9f4: func() error {
			x.PutClazzID(0xf731a9f4)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutInt32(m.ReadMaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readDiscussion, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readDiscussion, layer)
	}
}

// Decode <--
func (m *TLMessagesReadDiscussion) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf731a9f4: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()
			m.ReadMaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUnpinAllMessages <--
type TLMessagesUnpinAllMessages struct {
	ClazzID  uint32     `json:"_id"`
	Peer     *InputPeer `json:"peer"`
	TopMsgId *int32     `json:"top_msg_id"`
}

func (m *TLMessagesUnpinAllMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUnpinAllMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xee22b9a8: func() error {
			x.PutClazzID(0xee22b9a8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_unpinAllMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_unpinAllMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesUnpinAllMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xee22b9a8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteChat <--
type TLMessagesDeleteChat struct {
	ClazzID uint32 `json:"_id"`
	ChatId  int64  `json:"chat_id"`
}

func (m *TLMessagesDeleteChat) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteChat) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5bd0ee50: func() error {
			x.PutClazzID(0x5bd0ee50)

			x.PutInt64(m.ChatId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteChat, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteChat, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteChat) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5bd0ee50: func() (err error) {
			m.ChatId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeletePhoneCallHistory <--
type TLMessagesDeletePhoneCallHistory struct {
	ClazzID uint32 `json:"_id"`
	Revoke  bool   `json:"revoke"`
}

func (m *TLMessagesDeletePhoneCallHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeletePhoneCallHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf9cbe409: func() error {
			x.PutClazzID(0xf9cbe409)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Revoke == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deletePhoneCallHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deletePhoneCallHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesDeletePhoneCallHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf9cbe409: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Revoke = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCheckHistoryImport <--
type TLMessagesCheckHistoryImport struct {
	ClazzID    uint32 `json:"_id"`
	ImportHead string `json:"import_head"`
}

func (m *TLMessagesCheckHistoryImport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCheckHistoryImport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x43fe19f3: func() error {
			x.PutClazzID(0x43fe19f3)

			x.PutString(m.ImportHead)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_checkHistoryImport, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_checkHistoryImport, layer)
	}
}

// Decode <--
func (m *TLMessagesCheckHistoryImport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x43fe19f3: func() (err error) {
			m.ImportHead, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesInitHistoryImport <--
type TLMessagesInitHistoryImport struct {
	ClazzID    uint32     `json:"_id"`
	Peer       *InputPeer `json:"peer"`
	File       *InputFile `json:"file"`
	MediaCount int32      `json:"media_count"`
}

func (m *TLMessagesInitHistoryImport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesInitHistoryImport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x34090c3b: func() error {
			x.PutClazzID(0x34090c3b)

			_ = m.Peer.Encode(x, layer)
			_ = m.File.Encode(x, layer)
			x.PutInt32(m.MediaCount)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_initHistoryImport, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_initHistoryImport, layer)
	}
}

// Decode <--
func (m *TLMessagesInitHistoryImport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x34090c3b: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputFile{}
			_ = m2.Decode(d)
			m.File = m2

			m.MediaCount, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUploadImportedMedia <--
type TLMessagesUploadImportedMedia struct {
	ClazzID  uint32      `json:"_id"`
	Peer     *InputPeer  `json:"peer"`
	ImportId int64       `json:"import_id"`
	FileName string      `json:"file_name"`
	Media    *InputMedia `json:"media"`
}

func (m *TLMessagesUploadImportedMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUploadImportedMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2a862092: func() error {
			x.PutClazzID(0x2a862092)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.ImportId)
			x.PutString(m.FileName)
			_ = m.Media.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_uploadImportedMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_uploadImportedMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesUploadImportedMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2a862092: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.ImportId, err = d.Int64()
			m.FileName, err = d.String()

			m4 := &InputMedia{}
			_ = m4.Decode(d)
			m.Media = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesStartHistoryImport <--
type TLMessagesStartHistoryImport struct {
	ClazzID  uint32     `json:"_id"`
	Peer     *InputPeer `json:"peer"`
	ImportId int64      `json:"import_id"`
}

func (m *TLMessagesStartHistoryImport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesStartHistoryImport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb43df344: func() error {
			x.PutClazzID(0xb43df344)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.ImportId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_startHistoryImport, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_startHistoryImport, layer)
	}
}

// Decode <--
func (m *TLMessagesStartHistoryImport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb43df344: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.ImportId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetExportedChatInvites <--
type TLMessagesGetExportedChatInvites struct {
	ClazzID    uint32     `json:"_id"`
	Revoked    bool       `json:"revoked"`
	Peer       *InputPeer `json:"peer"`
	AdminId    *InputUser `json:"admin_id"`
	OffsetDate *int32     `json:"offset_date"`
	OffsetLink *string    `json:"offset_link"`
	Limit      int32      `json:"limit"`
}

func (m *TLMessagesGetExportedChatInvites) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetExportedChatInvites) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa2b5a3f6: func() error {
			x.PutClazzID(0xa2b5a3f6)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Revoked == true {
					flags |= 1 << 3
				}

				if m.OffsetDate != nil {
					flags |= 1 << 2
				}
				if m.OffsetLink != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.AdminId.Encode(x, layer)
			if m.OffsetDate != nil {
				x.PutInt32(*m.OffsetDate)
			}

			if m.OffsetLink != nil {
				x.PutString(*m.OffsetLink)
			}

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getExportedChatInvites, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getExportedChatInvites, layer)
	}
}

// Decode <--
func (m *TLMessagesGetExportedChatInvites) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa2b5a3f6: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 3)) != 0 {
				m.Revoked = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m4 := &InputUser{}
			_ = m4.Decode(d)
			m.AdminId = m4

			if (flags & (1 << 2)) != 0 {
				m.OffsetDate = new(int32)
				*m.OffsetDate, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				m.OffsetLink = new(string)
				*m.OffsetLink, err = d.String()
			}

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetExportedChatInvite <--
type TLMessagesGetExportedChatInvite struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Link    string     `json:"link"`
}

func (m *TLMessagesGetExportedChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetExportedChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x73746f5c: func() error {
			x.PutClazzID(0x73746f5c)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Link)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getExportedChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getExportedChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesGetExportedChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x73746f5c: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Link, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditExportedChatInvite <--
type TLMessagesEditExportedChatInvite struct {
	ClazzID       uint32     `json:"_id"`
	Revoked       bool       `json:"revoked"`
	Peer          *InputPeer `json:"peer"`
	Link          string     `json:"link"`
	ExpireDate    *int32     `json:"expire_date"`
	UsageLimit    *int32     `json:"usage_limit"`
	RequestNeeded *Bool      `json:"request_needed"`
	Title         *string    `json:"title"`
}

func (m *TLMessagesEditExportedChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditExportedChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbdca2f75: func() error {
			x.PutClazzID(0xbdca2f75)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Revoked == true {
					flags |= 1 << 2
				}

				if m.ExpireDate != nil {
					flags |= 1 << 0
				}
				if m.UsageLimit != nil {
					flags |= 1 << 1
				}
				if m.RequestNeeded != nil {
					flags |= 1 << 3
				}
				if m.Title != nil {
					flags |= 1 << 4
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Link)
			if m.ExpireDate != nil {
				x.PutInt32(*m.ExpireDate)
			}

			if m.UsageLimit != nil {
				x.PutInt32(*m.UsageLimit)
			}

			if m.RequestNeeded != nil {
				_ = m.RequestNeeded.Encode(x, layer)
			}

			if m.Title != nil {
				x.PutString(*m.Title)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editExportedChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editExportedChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesEditExportedChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbdca2f75: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m.Revoked = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.Link, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.ExpireDate = new(int32)
				*m.ExpireDate, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m.UsageLimit = new(int32)
				*m.UsageLimit, err = d.Int32()
			}
			if (flags & (1 << 3)) != 0 {
				m7 := &Bool{}
				_ = m7.Decode(d)
				m.RequestNeeded = m7
			}
			if (flags & (1 << 4)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteRevokedExportedChatInvites <--
type TLMessagesDeleteRevokedExportedChatInvites struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	AdminId *InputUser `json:"admin_id"`
}

func (m *TLMessagesDeleteRevokedExportedChatInvites) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteRevokedExportedChatInvites) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x56987bd5: func() error {
			x.PutClazzID(0x56987bd5)

			_ = m.Peer.Encode(x, layer)
			_ = m.AdminId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteRevokedExportedChatInvites, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteRevokedExportedChatInvites, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteRevokedExportedChatInvites) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x56987bd5: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.AdminId = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteExportedChatInvite <--
type TLMessagesDeleteExportedChatInvite struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Link    string     `json:"link"`
}

func (m *TLMessagesDeleteExportedChatInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteExportedChatInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd464a42b: func() error {
			x.PutClazzID(0xd464a42b)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Link)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteExportedChatInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteExportedChatInvite, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteExportedChatInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd464a42b: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Link, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAdminsWithInvites <--
type TLMessagesGetAdminsWithInvites struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLMessagesGetAdminsWithInvites) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAdminsWithInvites) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3920e6ef: func() error {
			x.PutClazzID(0x3920e6ef)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAdminsWithInvites, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAdminsWithInvites, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAdminsWithInvites) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3920e6ef: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetChatInviteImporters <--
type TLMessagesGetChatInviteImporters struct {
	ClazzID             uint32     `json:"_id"`
	Requested           bool       `json:"requested"`
	SubscriptionExpired bool       `json:"subscription_expired"`
	Peer                *InputPeer `json:"peer"`
	Link                *string    `json:"link"`
	Q                   *string    `json:"q"`
	OffsetDate          int32      `json:"offset_date"`
	OffsetUser          *InputUser `json:"offset_user"`
	Limit               int32      `json:"limit"`
}

func (m *TLMessagesGetChatInviteImporters) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetChatInviteImporters) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdf04dd4e: func() error {
			x.PutClazzID(0xdf04dd4e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Requested == true {
					flags |= 1 << 0
				}
				if m.SubscriptionExpired == true {
					flags |= 1 << 3
				}

				if m.Link != nil {
					flags |= 1 << 1
				}
				if m.Q != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.Link != nil {
				x.PutString(*m.Link)
			}

			if m.Q != nil {
				x.PutString(*m.Q)
			}

			x.PutInt32(m.OffsetDate)
			_ = m.OffsetUser.Encode(x, layer)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getChatInviteImporters, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getChatInviteImporters, layer)
	}
}

// Decode <--
func (m *TLMessagesGetChatInviteImporters) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdf04dd4e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Requested = true
			}
			if (flags & (1 << 3)) != 0 {
				m.SubscriptionExpired = true
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			if (flags & (1 << 1)) != 0 {
				m.Link = new(string)
				*m.Link, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.Q = new(string)
				*m.Q, err = d.String()
			}

			m.OffsetDate, err = d.Int32()

			m8 := &InputUser{}
			_ = m8.Decode(d)
			m.OffsetUser = m8

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetHistoryTTL <--
type TLMessagesSetHistoryTTL struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Period  int32      `json:"period"`
}

func (m *TLMessagesSetHistoryTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetHistoryTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb80e5fe4: func() error {
			x.PutClazzID(0xb80e5fe4)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Period)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setHistoryTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setHistoryTTL, layer)
	}
}

// Decode <--
func (m *TLMessagesSetHistoryTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb80e5fe4: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Period, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCheckHistoryImportPeer <--
type TLMessagesCheckHistoryImportPeer struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLMessagesCheckHistoryImportPeer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCheckHistoryImportPeer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5dc60f03: func() error {
			x.PutClazzID(0x5dc60f03)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_checkHistoryImportPeer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_checkHistoryImportPeer, layer)
	}
}

// Decode <--
func (m *TLMessagesCheckHistoryImportPeer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5dc60f03: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetChatTheme <--
type TLMessagesSetChatTheme struct {
	ClazzID  uint32     `json:"_id"`
	Peer     *InputPeer `json:"peer"`
	Emoticon string     `json:"emoticon"`
}

func (m *TLMessagesSetChatTheme) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetChatTheme) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe63be13f: func() error {
			x.PutClazzID(0xe63be13f)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Emoticon)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setChatTheme, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setChatTheme, layer)
	}
}

// Decode <--
func (m *TLMessagesSetChatTheme) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe63be13f: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Emoticon, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessageReadParticipants <--
type TLMessagesGetMessageReadParticipants struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MsgId   int32      `json:"msg_id"`
}

func (m *TLMessagesGetMessageReadParticipants) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessageReadParticipants) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x31c1c44f: func() error {
			x.PutClazzID(0x31c1c44f)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessageReadParticipants, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessageReadParticipants, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessageReadParticipants) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x31c1c44f: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSearchResultsCalendar <--
type TLMessagesGetSearchResultsCalendar struct {
	ClazzID     uint32          `json:"_id"`
	Peer        *InputPeer      `json:"peer"`
	SavedPeerId *InputPeer      `json:"saved_peer_id"`
	Filter      *MessagesFilter `json:"filter"`
	OffsetId    int32           `json:"offset_id"`
	OffsetDate  int32           `json:"offset_date"`
}

func (m *TLMessagesGetSearchResultsCalendar) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSearchResultsCalendar) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6aa3f6bd: func() error {
			x.PutClazzID(0x6aa3f6bd)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SavedPeerId != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.OffsetDate)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSearchResultsCalendar, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSearchResultsCalendar, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSearchResultsCalendar) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6aa3f6bd: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			if (flags & (1 << 2)) != 0 {
				m3 := &InputPeer{}
				_ = m3.Decode(d)
				m.SavedPeerId = m3
			}

			m4 := &MessagesFilter{}
			_ = m4.Decode(d)
			m.Filter = m4

			m.OffsetId, err = d.Int32()
			m.OffsetDate, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSearchResultsPositions <--
type TLMessagesGetSearchResultsPositions struct {
	ClazzID     uint32          `json:"_id"`
	Peer        *InputPeer      `json:"peer"`
	SavedPeerId *InputPeer      `json:"saved_peer_id"`
	Filter      *MessagesFilter `json:"filter"`
	OffsetId    int32           `json:"offset_id"`
	Limit       int32           `json:"limit"`
}

func (m *TLMessagesGetSearchResultsPositions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSearchResultsPositions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9c7f2f10: func() error {
			x.PutClazzID(0x9c7f2f10)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SavedPeerId != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.SavedPeerId != nil {
				_ = m.SavedPeerId.Encode(x, layer)
			}

			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSearchResultsPositions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSearchResultsPositions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSearchResultsPositions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9c7f2f10: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			if (flags & (1 << 2)) != 0 {
				m3 := &InputPeer{}
				_ = m3.Decode(d)
				m.SavedPeerId = m3
			}

			m4 := &MessagesFilter{}
			_ = m4.Decode(d)
			m.Filter = m4

			m.OffsetId, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesHideChatJoinRequest <--
type TLMessagesHideChatJoinRequest struct {
	ClazzID  uint32     `json:"_id"`
	Approved bool       `json:"approved"`
	Peer     *InputPeer `json:"peer"`
	UserId   *InputUser `json:"user_id"`
}

func (m *TLMessagesHideChatJoinRequest) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesHideChatJoinRequest) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7fe7e815: func() error {
			x.PutClazzID(0x7fe7e815)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Approved == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_hideChatJoinRequest, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_hideChatJoinRequest, layer)
	}
}

// Decode <--
func (m *TLMessagesHideChatJoinRequest) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7fe7e815: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Approved = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m4 := &InputUser{}
			_ = m4.Decode(d)
			m.UserId = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesHideAllChatJoinRequests <--
type TLMessagesHideAllChatJoinRequests struct {
	ClazzID  uint32     `json:"_id"`
	Approved bool       `json:"approved"`
	Peer     *InputPeer `json:"peer"`
	Link     *string    `json:"link"`
}

func (m *TLMessagesHideAllChatJoinRequests) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesHideAllChatJoinRequests) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe085f4ea: func() error {
			x.PutClazzID(0xe085f4ea)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Approved == true {
					flags |= 1 << 0
				}

				if m.Link != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.Link != nil {
				x.PutString(*m.Link)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_hideAllChatJoinRequests, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_hideAllChatJoinRequests, layer)
	}
}

// Decode <--
func (m *TLMessagesHideAllChatJoinRequests) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe085f4ea: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Approved = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			if (flags & (1 << 1)) != 0 {
				m.Link = new(string)
				*m.Link, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleNoForwards <--
type TLMessagesToggleNoForwards struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Enabled *Bool      `json:"enabled"`
}

func (m *TLMessagesToggleNoForwards) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleNoForwards) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb11eafa2: func() error {
			x.PutClazzID(0xb11eafa2)

			_ = m.Peer.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleNoForwards, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleNoForwards, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleNoForwards) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb11eafa2: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Enabled = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSaveDefaultSendAs <--
type TLMessagesSaveDefaultSendAs struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	SendAs  *InputPeer `json:"send_as"`
}

func (m *TLMessagesSaveDefaultSendAs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSaveDefaultSendAs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xccfddf96: func() error {
			x.PutClazzID(0xccfddf96)

			_ = m.Peer.Encode(x, layer)
			_ = m.SendAs.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_saveDefaultSendAs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_saveDefaultSendAs, layer)
	}
}

// Decode <--
func (m *TLMessagesSaveDefaultSendAs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xccfddf96: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.SendAs = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendReaction <--
type TLMessagesSendReaction struct {
	ClazzID     uint32      `json:"_id"`
	Big         bool        `json:"big"`
	AddToRecent bool        `json:"add_to_recent"`
	Peer        *InputPeer  `json:"peer"`
	MsgId       int32       `json:"msg_id"`
	Reaction    []*Reaction `json:"reaction"`
}

func (m *TLMessagesSendReaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendReaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd30d78d4: func() error {
			x.PutClazzID(0xd30d78d4)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Big == true {
					flags |= 1 << 1
				}
				if m.AddToRecent == true {
					flags |= 1 << 2
				}

				if m.Reaction != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			if m.Reaction != nil {
				_ = iface.EncodeObjectList(x, m.Reaction, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendReaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendReaction, layer)
	}
}

// Decode <--
func (m *TLMessagesSendReaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd30d78d4: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Big = true
			}
			if (flags & (1 << 2)) != 0 {
				m.AddToRecent = true
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			m.MsgId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				c6, err2 := d.ClazzID()
				if c6 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 6, c6)
					return err2
				}
				l6, err3 := d.Int()
				v6 := make([]*Reaction, l6)
				for i := 0; i < l6; i++ {
					vv := new(Reaction)
					err3 = vv.Decode(d)
					_ = err3
					v6[i] = vv
				}
				m.Reaction = v6
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessagesReactions <--
type TLMessagesGetMessagesReactions struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLMessagesGetMessagesReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessagesReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8bba90e6: func() error {
			x.PutClazzID(0x8bba90e6)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessagesReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessagesReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessagesReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8bba90e6: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMessageReactionsList <--
type TLMessagesGetMessageReactionsList struct {
	ClazzID  uint32     `json:"_id"`
	Peer     *InputPeer `json:"peer"`
	Id       int32      `json:"id"`
	Reaction *Reaction  `json:"reaction"`
	Offset   *string    `json:"offset"`
	Limit    int32      `json:"limit"`
}

func (m *TLMessagesGetMessageReactionsList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMessageReactionsList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x461b3f48: func() error {
			x.PutClazzID(0x461b3f48)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Reaction != nil {
					flags |= 1 << 0
				}
				if m.Offset != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			if m.Reaction != nil {
				_ = m.Reaction.Encode(x, layer)
			}

			if m.Offset != nil {
				x.PutString(*m.Offset)
			}

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMessageReactionsList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMessageReactionsList, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMessageReactionsList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x461b3f48: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			m.Id, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m4 := &Reaction{}
				_ = m4.Decode(d)
				m.Reaction = m4
			}
			if (flags & (1 << 1)) != 0 {
				m.Offset = new(string)
				*m.Offset, err = d.String()
			}

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetChatAvailableReactions <--
type TLMessagesSetChatAvailableReactions struct {
	ClazzID            uint32         `json:"_id"`
	Peer               *InputPeer     `json:"peer"`
	AvailableReactions *ChatReactions `json:"available_reactions"`
	ReactionsLimit     *int32         `json:"reactions_limit"`
	PaidEnabled        *Bool          `json:"paid_enabled"`
}

func (m *TLMessagesSetChatAvailableReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetChatAvailableReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x864b2581: func() error {
			x.PutClazzID(0x864b2581)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ReactionsLimit != nil {
					flags |= 1 << 0
				}
				if m.PaidEnabled != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.AvailableReactions.Encode(x, layer)
			if m.ReactionsLimit != nil {
				x.PutInt32(*m.ReactionsLimit)
			}

			if m.PaidEnabled != nil {
				_ = m.PaidEnabled.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setChatAvailableReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setChatAvailableReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesSetChatAvailableReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x864b2581: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			m3 := &ChatReactions{}
			_ = m3.Decode(d)
			m.AvailableReactions = m3

			if (flags & (1 << 0)) != 0 {
				m.ReactionsLimit = new(int32)
				*m.ReactionsLimit, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m5 := &Bool{}
				_ = m5.Decode(d)
				m.PaidEnabled = m5
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAvailableReactions <--
type TLMessagesGetAvailableReactions struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetAvailableReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAvailableReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x18dea0ac: func() error {
			x.PutClazzID(0x18dea0ac)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAvailableReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAvailableReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAvailableReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x18dea0ac: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetDefaultReaction <--
type TLMessagesSetDefaultReaction struct {
	ClazzID  uint32    `json:"_id"`
	Reaction *Reaction `json:"reaction"`
}

func (m *TLMessagesSetDefaultReaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetDefaultReaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4f47a016: func() error {
			x.PutClazzID(0x4f47a016)

			_ = m.Reaction.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setDefaultReaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setDefaultReaction, layer)
	}
}

// Decode <--
func (m *TLMessagesSetDefaultReaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4f47a016: func() (err error) {

			m1 := &Reaction{}
			_ = m1.Decode(d)
			m.Reaction = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesTranslateText <--
type TLMessagesTranslateText struct {
	ClazzID uint32              `json:"_id"`
	Peer    *InputPeer          `json:"peer"`
	Id      []int32             `json:"id"`
	Text    []*TextWithEntities `json:"text"`
	ToLang  string              `json:"to_lang"`
}

func (m *TLMessagesTranslateText) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesTranslateText) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x63183030: func() error {
			x.PutClazzID(0x63183030)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Peer != nil {
					flags |= 1 << 0
				}
				if m.Id != nil {
					flags |= 1 << 0
				}
				if m.Text != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			if m.Id != nil {
				iface.EncodeInt32List(x, m.Id)
			}
			if m.Text != nil {
				_ = iface.EncodeObjectList(x, m.Text, layer)
			}
			x.PutString(m.ToLang)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_translateText, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_translateText, layer)
	}
}

// Decode <--
func (m *TLMessagesTranslateText) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x63183030: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &InputPeer{}
				_ = m2.Decode(d)
				m.Peer = m2
			}
			if (flags & (1 << 0)) != 0 {
				m.Id, err = iface.DecodeInt32List(d)
			}
			if (flags & (1 << 1)) != 0 {
				c4, err2 := d.ClazzID()
				if c4 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
					return err2
				}
				l4, err3 := d.Int()
				v4 := make([]*TextWithEntities, l4)
				for i := 0; i < l4; i++ {
					vv := new(TextWithEntities)
					err3 = vv.Decode(d)
					_ = err3
					v4[i] = vv
				}
				m.Text = v4
			}
			m.ToLang, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetUnreadReactions <--
type TLMessagesGetUnreadReactions struct {
	ClazzID   uint32     `json:"_id"`
	Peer      *InputPeer `json:"peer"`
	TopMsgId  *int32     `json:"top_msg_id"`
	OffsetId  int32      `json:"offset_id"`
	AddOffset int32      `json:"add_offset"`
	Limit     int32      `json:"limit"`
	MaxId     int32      `json:"max_id"`
	MinId     int32      `json:"min_id"`
}

func (m *TLMessagesGetUnreadReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetUnreadReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3223495b: func() error {
			x.PutClazzID(0x3223495b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			x.PutInt32(m.OffsetId)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getUnreadReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getUnreadReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetUnreadReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3223495b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}
			m.OffsetId, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReadReactions <--
type TLMessagesReadReactions struct {
	ClazzID  uint32     `json:"_id"`
	Peer     *InputPeer `json:"peer"`
	TopMsgId *int32     `json:"top_msg_id"`
}

func (m *TLMessagesReadReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReadReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x54aa7f8e: func() error {
			x.PutClazzID(0x54aa7f8e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.TopMsgId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.TopMsgId != nil {
				x.PutInt32(*m.TopMsgId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_readReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_readReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesReadReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x54aa7f8e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			if (flags & (1 << 0)) != 0 {
				m.TopMsgId = new(int32)
				*m.TopMsgId, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchSentMedia <--
type TLMessagesSearchSentMedia struct {
	ClazzID uint32          `json:"_id"`
	Q       string          `json:"q"`
	Filter  *MessagesFilter `json:"filter"`
	Limit   int32           `json:"limit"`
}

func (m *TLMessagesSearchSentMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchSentMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x107e31a0: func() error {
			x.PutClazzID(0x107e31a0)

			x.PutString(m.Q)
			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchSentMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchSentMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchSentMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x107e31a0: func() (err error) {
			m.Q, err = d.String()

			m2 := &MessagesFilter{}
			_ = m2.Decode(d)
			m.Filter = m2

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAttachMenuBots <--
type TLMessagesGetAttachMenuBots struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetAttachMenuBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAttachMenuBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x16fcc2cb: func() error {
			x.PutClazzID(0x16fcc2cb)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAttachMenuBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAttachMenuBots, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAttachMenuBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x16fcc2cb: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAttachMenuBot <--
type TLMessagesGetAttachMenuBot struct {
	ClazzID uint32     `json:"_id"`
	Bot     *InputUser `json:"bot"`
}

func (m *TLMessagesGetAttachMenuBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAttachMenuBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x77216192: func() error {
			x.PutClazzID(0x77216192)

			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAttachMenuBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAttachMenuBot, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAttachMenuBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x77216192: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleBotInAttachMenu <--
type TLMessagesToggleBotInAttachMenu struct {
	ClazzID      uint32     `json:"_id"`
	WriteAllowed bool       `json:"write_allowed"`
	Bot          *InputUser `json:"bot"`
	Enabled      *Bool      `json:"enabled"`
}

func (m *TLMessagesToggleBotInAttachMenu) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleBotInAttachMenu) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x69f59d69: func() error {
			x.PutClazzID(0x69f59d69)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.WriteAllowed == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Bot.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleBotInAttachMenu, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleBotInAttachMenu, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleBotInAttachMenu) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x69f59d69: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.WriteAllowed = true
			}

			m3 := &InputUser{}
			_ = m3.Decode(d)
			m.Bot = m3

			m4 := &Bool{}
			_ = m4.Decode(d)
			m.Enabled = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestWebView <--
type TLMessagesRequestWebView struct {
	ClazzID     uint32        `json:"_id"`
	FromBotMenu bool          `json:"from_bot_menu"`
	Silent      bool          `json:"silent"`
	Compact     bool          `json:"compact"`
	Fullscreen  bool          `json:"fullscreen"`
	Peer        *InputPeer    `json:"peer"`
	Bot         *InputUser    `json:"bot"`
	Url         *string       `json:"url"`
	StartParam  *string       `json:"start_param"`
	ThemeParams *DataJSON     `json:"theme_params"`
	Platform    string        `json:"platform"`
	ReplyTo     *InputReplyTo `json:"reply_to"`
	SendAs      *InputPeer    `json:"send_as"`
}

func (m *TLMessagesRequestWebView) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestWebView) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x269dc2c1: func() error {
			x.PutClazzID(0x269dc2c1)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FromBotMenu == true {
					flags |= 1 << 4
				}
				if m.Silent == true {
					flags |= 1 << 5
				}
				if m.Compact == true {
					flags |= 1 << 7
				}
				if m.Fullscreen == true {
					flags |= 1 << 8
				}

				if m.Url != nil {
					flags |= 1 << 1
				}
				if m.StartParam != nil {
					flags |= 1 << 3
				}
				if m.ThemeParams != nil {
					flags |= 1 << 2
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.Bot.Encode(x, layer)
			if m.Url != nil {
				x.PutString(*m.Url)
			}

			if m.StartParam != nil {
				x.PutString(*m.StartParam)
			}

			if m.ThemeParams != nil {
				_ = m.ThemeParams.Encode(x, layer)
			}

			x.PutString(m.Platform)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestWebView, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestWebView, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestWebView) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x269dc2c1: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 4)) != 0 {
				m.FromBotMenu = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}
			if (flags & (1 << 7)) != 0 {
				m.Compact = true
			}
			if (flags & (1 << 8)) != 0 {
				m.Fullscreen = true
			}

			m6 := &InputPeer{}
			_ = m6.Decode(d)
			m.Peer = m6

			m7 := &InputUser{}
			_ = m7.Decode(d)
			m.Bot = m7

			if (flags & (1 << 1)) != 0 {
				m.Url = new(string)
				*m.Url, err = d.String()
			}

			if (flags & (1 << 3)) != 0 {
				m.StartParam = new(string)
				*m.StartParam, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m10 := &DataJSON{}
				_ = m10.Decode(d)
				m.ThemeParams = m10
			}
			m.Platform, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m12 := &InputReplyTo{}
				_ = m12.Decode(d)
				m.ReplyTo = m12
			}
			if (flags & (1 << 13)) != 0 {
				m13 := &InputPeer{}
				_ = m13.Decode(d)
				m.SendAs = m13
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesProlongWebView <--
type TLMessagesProlongWebView struct {
	ClazzID uint32        `json:"_id"`
	Silent  bool          `json:"silent"`
	Peer    *InputPeer    `json:"peer"`
	Bot     *InputUser    `json:"bot"`
	QueryId int64         `json:"query_id"`
	ReplyTo *InputReplyTo `json:"reply_to"`
	SendAs  *InputPeer    `json:"send_as"`
}

func (m *TLMessagesProlongWebView) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesProlongWebView) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb0d81a83: func() error {
			x.PutClazzID(0xb0d81a83)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Silent == true {
					flags |= 1 << 5
				}

				if m.ReplyTo != nil {
					flags |= 1 << 0
				}
				if m.SendAs != nil {
					flags |= 1 << 13
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.Bot.Encode(x, layer)
			x.PutInt64(m.QueryId)
			if m.ReplyTo != nil {
				_ = m.ReplyTo.Encode(x, layer)
			}

			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_prolongWebView, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_prolongWebView, layer)
	}
}

// Decode <--
func (m *TLMessagesProlongWebView) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb0d81a83: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 5)) != 0 {
				m.Silent = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m4 := &InputUser{}
			_ = m4.Decode(d)
			m.Bot = m4

			m.QueryId, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m6 := &InputReplyTo{}
				_ = m6.Decode(d)
				m.ReplyTo = m6
			}
			if (flags & (1 << 13)) != 0 {
				m7 := &InputPeer{}
				_ = m7.Decode(d)
				m.SendAs = m7
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestSimpleWebView <--
type TLMessagesRequestSimpleWebView struct {
	ClazzID           uint32     `json:"_id"`
	FromSwitchWebview bool       `json:"from_switch_webview"`
	FromSideMenu      bool       `json:"from_side_menu"`
	Compact           bool       `json:"compact"`
	Fullscreen        bool       `json:"fullscreen"`
	Bot               *InputUser `json:"bot"`
	Url               *string    `json:"url"`
	StartParam        *string    `json:"start_param"`
	ThemeParams       *DataJSON  `json:"theme_params"`
	Platform          string     `json:"platform"`
}

func (m *TLMessagesRequestSimpleWebView) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestSimpleWebView) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x413a3e73: func() error {
			x.PutClazzID(0x413a3e73)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FromSwitchWebview == true {
					flags |= 1 << 1
				}
				if m.FromSideMenu == true {
					flags |= 1 << 2
				}
				if m.Compact == true {
					flags |= 1 << 7
				}
				if m.Fullscreen == true {
					flags |= 1 << 8
				}

				if m.Url != nil {
					flags |= 1 << 3
				}
				if m.StartParam != nil {
					flags |= 1 << 4
				}
				if m.ThemeParams != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Bot.Encode(x, layer)
			if m.Url != nil {
				x.PutString(*m.Url)
			}

			if m.StartParam != nil {
				x.PutString(*m.StartParam)
			}

			if m.ThemeParams != nil {
				_ = m.ThemeParams.Encode(x, layer)
			}

			x.PutString(m.Platform)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestSimpleWebView, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestSimpleWebView, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestSimpleWebView) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x413a3e73: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.FromSwitchWebview = true
			}
			if (flags & (1 << 2)) != 0 {
				m.FromSideMenu = true
			}
			if (flags & (1 << 7)) != 0 {
				m.Compact = true
			}
			if (flags & (1 << 8)) != 0 {
				m.Fullscreen = true
			}

			m6 := &InputUser{}
			_ = m6.Decode(d)
			m.Bot = m6

			if (flags & (1 << 3)) != 0 {
				m.Url = new(string)
				*m.Url, err = d.String()
			}

			if (flags & (1 << 4)) != 0 {
				m.StartParam = new(string)
				*m.StartParam, err = d.String()
			}

			if (flags & (1 << 0)) != 0 {
				m9 := &DataJSON{}
				_ = m9.Decode(d)
				m.ThemeParams = m9
			}
			m.Platform, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendWebViewResultMessage <--
type TLMessagesSendWebViewResultMessage struct {
	ClazzID    uint32                `json:"_id"`
	BotQueryId string                `json:"bot_query_id"`
	Result     *InputBotInlineResult `json:"result"`
}

func (m *TLMessagesSendWebViewResultMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendWebViewResultMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa4314f5: func() error {
			x.PutClazzID(0xa4314f5)

			x.PutString(m.BotQueryId)
			_ = m.Result.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendWebViewResultMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendWebViewResultMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesSendWebViewResultMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa4314f5: func() (err error) {
			m.BotQueryId, err = d.String()

			m2 := &InputBotInlineResult{}
			_ = m2.Decode(d)
			m.Result = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendWebViewData <--
type TLMessagesSendWebViewData struct {
	ClazzID    uint32     `json:"_id"`
	Bot        *InputUser `json:"bot"`
	RandomId   int64      `json:"random_id"`
	ButtonText string     `json:"button_text"`
	Data       string     `json:"data"`
}

func (m *TLMessagesSendWebViewData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendWebViewData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdc0242c8: func() error {
			x.PutClazzID(0xdc0242c8)

			_ = m.Bot.Encode(x, layer)
			x.PutInt64(m.RandomId)
			x.PutString(m.ButtonText)
			x.PutString(m.Data)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendWebViewData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendWebViewData, layer)
	}
}

// Decode <--
func (m *TLMessagesSendWebViewData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdc0242c8: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.RandomId, err = d.Int64()
			m.ButtonText, err = d.String()
			m.Data, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesTranscribeAudio <--
type TLMessagesTranscribeAudio struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MsgId   int32      `json:"msg_id"`
}

func (m *TLMessagesTranscribeAudio) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesTranscribeAudio) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x269e9a49: func() error {
			x.PutClazzID(0x269e9a49)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_transcribeAudio, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_transcribeAudio, layer)
	}
}

// Decode <--
func (m *TLMessagesTranscribeAudio) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x269e9a49: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRateTranscribedAudio <--
type TLMessagesRateTranscribedAudio struct {
	ClazzID         uint32     `json:"_id"`
	Peer            *InputPeer `json:"peer"`
	MsgId           int32      `json:"msg_id"`
	TranscriptionId int64      `json:"transcription_id"`
	Good            *Bool      `json:"good"`
}

func (m *TLMessagesRateTranscribedAudio) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRateTranscribedAudio) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7f1d072f: func() error {
			x.PutClazzID(0x7f1d072f)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutInt64(m.TranscriptionId)
			_ = m.Good.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_rateTranscribedAudio, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_rateTranscribedAudio, layer)
	}
}

// Decode <--
func (m *TLMessagesRateTranscribedAudio) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7f1d072f: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()
			m.TranscriptionId, err = d.Int64()

			m4 := &Bool{}
			_ = m4.Decode(d)
			m.Good = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetCustomEmojiDocuments <--
type TLMessagesGetCustomEmojiDocuments struct {
	ClazzID    uint32  `json:"_id"`
	DocumentId []int64 `json:"document_id"`
}

func (m *TLMessagesGetCustomEmojiDocuments) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetCustomEmojiDocuments) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd9ab0f54: func() error {
			x.PutClazzID(0xd9ab0f54)

			iface.EncodeInt64List(x, m.DocumentId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getCustomEmojiDocuments, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getCustomEmojiDocuments, layer)
	}
}

// Decode <--
func (m *TLMessagesGetCustomEmojiDocuments) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd9ab0f54: func() (err error) {

			m.DocumentId, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiStickers <--
type TLMessagesGetEmojiStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetEmojiStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfbfca18f: func() error {
			x.PutClazzID(0xfbfca18f)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfbfca18f: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetFeaturedEmojiStickers <--
type TLMessagesGetFeaturedEmojiStickers struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetFeaturedEmojiStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetFeaturedEmojiStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xecf6736: func() error {
			x.PutClazzID(0xecf6736)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getFeaturedEmojiStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getFeaturedEmojiStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetFeaturedEmojiStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xecf6736: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReportReaction <--
type TLMessagesReportReaction struct {
	ClazzID      uint32     `json:"_id"`
	Peer         *InputPeer `json:"peer"`
	Id           int32      `json:"id"`
	ReactionPeer *InputPeer `json:"reaction_peer"`
}

func (m *TLMessagesReportReaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReportReaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3f64c076: func() error {
			x.PutClazzID(0x3f64c076)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			_ = m.ReactionPeer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reportReaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reportReaction, layer)
	}
}

// Decode <--
func (m *TLMessagesReportReaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3f64c076: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = d.Int32()

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.ReactionPeer = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetTopReactions <--
type TLMessagesGetTopReactions struct {
	ClazzID uint32 `json:"_id"`
	Limit   int32  `json:"limit"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetTopReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetTopReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbb8125ba: func() error {
			x.PutClazzID(0xbb8125ba)

			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getTopReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getTopReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetTopReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbb8125ba: func() (err error) {
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetRecentReactions <--
type TLMessagesGetRecentReactions struct {
	ClazzID uint32 `json:"_id"`
	Limit   int32  `json:"limit"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetRecentReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetRecentReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x39461db2: func() error {
			x.PutClazzID(0x39461db2)

			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getRecentReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getRecentReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetRecentReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x39461db2: func() (err error) {
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesClearRecentReactions <--
type TLMessagesClearRecentReactions struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesClearRecentReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesClearRecentReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9dfeefb4: func() error {
			x.PutClazzID(0x9dfeefb4)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_clearRecentReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_clearRecentReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesClearRecentReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9dfeefb4: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetExtendedMedia <--
type TLMessagesGetExtendedMedia struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLMessagesGetExtendedMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetExtendedMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x84f80814: func() error {
			x.PutClazzID(0x84f80814)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getExtendedMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getExtendedMedia, layer)
	}
}

// Decode <--
func (m *TLMessagesGetExtendedMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x84f80814: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetDefaultHistoryTTL <--
type TLMessagesSetDefaultHistoryTTL struct {
	ClazzID uint32 `json:"_id"`
	Period  int32  `json:"period"`
}

func (m *TLMessagesSetDefaultHistoryTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetDefaultHistoryTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9eb51445: func() error {
			x.PutClazzID(0x9eb51445)

			x.PutInt32(m.Period)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setDefaultHistoryTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setDefaultHistoryTTL, layer)
	}
}

// Decode <--
func (m *TLMessagesSetDefaultHistoryTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9eb51445: func() (err error) {
			m.Period, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDefaultHistoryTTL <--
type TLMessagesGetDefaultHistoryTTL struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetDefaultHistoryTTL) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDefaultHistoryTTL) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x658b7188: func() error {
			x.PutClazzID(0x658b7188)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDefaultHistoryTTL, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDefaultHistoryTTL, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDefaultHistoryTTL) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x658b7188: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendBotRequestedPeer <--
type TLMessagesSendBotRequestedPeer struct {
	ClazzID        uint32       `json:"_id"`
	Peer           *InputPeer   `json:"peer"`
	MsgId          int32        `json:"msg_id"`
	ButtonId       int32        `json:"button_id"`
	RequestedPeers []*InputPeer `json:"requested_peers"`
}

func (m *TLMessagesSendBotRequestedPeer) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendBotRequestedPeer) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x91b2d060: func() error {
			x.PutClazzID(0x91b2d060)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutInt32(m.ButtonId)

			_ = iface.EncodeObjectList(x, m.RequestedPeers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendBotRequestedPeer, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendBotRequestedPeer, layer)
	}
}

// Decode <--
func (m *TLMessagesSendBotRequestedPeer) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x91b2d060: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()
			m.ButtonId, err = d.Int32()
			c4, err2 := d.ClazzID()
			if c4 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
				return err2
			}
			l4, err3 := d.Int()
			v4 := make([]*InputPeer, l4)
			for i := 0; i < l4; i++ {
				vv := new(InputPeer)
				err3 = vv.Decode(d)
				_ = err3
				v4[i] = vv
			}
			m.RequestedPeers = v4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiGroups <--
type TLMessagesGetEmojiGroups struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetEmojiGroups) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiGroups) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7488ce5b: func() error {
			x.PutClazzID(0x7488ce5b)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiGroups, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiGroups, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiGroups) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7488ce5b: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiStatusGroups <--
type TLMessagesGetEmojiStatusGroups struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetEmojiStatusGroups) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiStatusGroups) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2ecd56cd: func() error {
			x.PutClazzID(0x2ecd56cd)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiStatusGroups, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiStatusGroups, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiStatusGroups) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2ecd56cd: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiProfilePhotoGroups <--
type TLMessagesGetEmojiProfilePhotoGroups struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetEmojiProfilePhotoGroups) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiProfilePhotoGroups) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x21a548f3: func() error {
			x.PutClazzID(0x21a548f3)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiProfilePhotoGroups, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiProfilePhotoGroups, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiProfilePhotoGroups) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x21a548f3: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchCustomEmoji <--
type TLMessagesSearchCustomEmoji struct {
	ClazzID  uint32 `json:"_id"`
	Emoticon string `json:"emoticon"`
	Hash     int64  `json:"hash"`
}

func (m *TLMessagesSearchCustomEmoji) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchCustomEmoji) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2c11c0d7: func() error {
			x.PutClazzID(0x2c11c0d7)

			x.PutString(m.Emoticon)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchCustomEmoji, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchCustomEmoji, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchCustomEmoji) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2c11c0d7: func() (err error) {
			m.Emoticon, err = d.String()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesTogglePeerTranslations <--
type TLMessagesTogglePeerTranslations struct {
	ClazzID  uint32     `json:"_id"`
	Disabled bool       `json:"disabled"`
	Peer     *InputPeer `json:"peer"`
}

func (m *TLMessagesTogglePeerTranslations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesTogglePeerTranslations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe47cb579: func() error {
			x.PutClazzID(0xe47cb579)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Disabled == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_togglePeerTranslations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_togglePeerTranslations, layer)
	}
}

// Decode <--
func (m *TLMessagesTogglePeerTranslations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe47cb579: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Disabled = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetBotApp <--
type TLMessagesGetBotApp struct {
	ClazzID uint32       `json:"_id"`
	App     *InputBotApp `json:"app"`
	Hash    int64        `json:"hash"`
}

func (m *TLMessagesGetBotApp) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetBotApp) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x34fdc5c3: func() error {
			x.PutClazzID(0x34fdc5c3)

			_ = m.App.Encode(x, layer)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getBotApp, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getBotApp, layer)
	}
}

// Decode <--
func (m *TLMessagesGetBotApp) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x34fdc5c3: func() (err error) {

			m1 := &InputBotApp{}
			_ = m1.Decode(d)
			m.App = m1

			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestAppWebView <--
type TLMessagesRequestAppWebView struct {
	ClazzID      uint32       `json:"_id"`
	WriteAllowed bool         `json:"write_allowed"`
	Compact      bool         `json:"compact"`
	Fullscreen   bool         `json:"fullscreen"`
	Peer         *InputPeer   `json:"peer"`
	App          *InputBotApp `json:"app"`
	StartParam   *string      `json:"start_param"`
	ThemeParams  *DataJSON    `json:"theme_params"`
	Platform     string       `json:"platform"`
}

func (m *TLMessagesRequestAppWebView) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestAppWebView) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x53618bce: func() error {
			x.PutClazzID(0x53618bce)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.WriteAllowed == true {
					flags |= 1 << 0
				}
				if m.Compact == true {
					flags |= 1 << 7
				}
				if m.Fullscreen == true {
					flags |= 1 << 8
				}

				if m.StartParam != nil {
					flags |= 1 << 1
				}
				if m.ThemeParams != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.App.Encode(x, layer)
			if m.StartParam != nil {
				x.PutString(*m.StartParam)
			}

			if m.ThemeParams != nil {
				_ = m.ThemeParams.Encode(x, layer)
			}

			x.PutString(m.Platform)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestAppWebView, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestAppWebView, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestAppWebView) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x53618bce: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.WriteAllowed = true
			}
			if (flags & (1 << 7)) != 0 {
				m.Compact = true
			}
			if (flags & (1 << 8)) != 0 {
				m.Fullscreen = true
			}

			m5 := &InputPeer{}
			_ = m5.Decode(d)
			m.Peer = m5

			m6 := &InputBotApp{}
			_ = m6.Decode(d)
			m.App = m6

			if (flags & (1 << 1)) != 0 {
				m.StartParam = new(string)
				*m.StartParam, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m8 := &DataJSON{}
				_ = m8.Decode(d)
				m.ThemeParams = m8
			}
			m.Platform, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSetChatWallPaper <--
type TLMessagesSetChatWallPaper struct {
	ClazzID   uint32             `json:"_id"`
	ForBoth   bool               `json:"for_both"`
	Revert    bool               `json:"revert"`
	Peer      *InputPeer         `json:"peer"`
	Wallpaper *InputWallPaper    `json:"wallpaper"`
	Settings  *WallPaperSettings `json:"settings"`
	Id        *int32             `json:"id"`
}

func (m *TLMessagesSetChatWallPaper) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSetChatWallPaper) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8ffacae1: func() error {
			x.PutClazzID(0x8ffacae1)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForBoth == true {
					flags |= 1 << 3
				}
				if m.Revert == true {
					flags |= 1 << 4
				}

				if m.Wallpaper != nil {
					flags |= 1 << 0
				}
				if m.Settings != nil {
					flags |= 1 << 2
				}
				if m.Id != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.Wallpaper != nil {
				_ = m.Wallpaper.Encode(x, layer)
			}

			if m.Settings != nil {
				_ = m.Settings.Encode(x, layer)
			}

			if m.Id != nil {
				x.PutInt32(*m.Id)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_setChatWallPaper, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_setChatWallPaper, layer)
	}
}

// Decode <--
func (m *TLMessagesSetChatWallPaper) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8ffacae1: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 3)) != 0 {
				m.ForBoth = true
			}
			if (flags & (1 << 4)) != 0 {
				m.Revert = true
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			if (flags & (1 << 0)) != 0 {
				m5 := &InputWallPaper{}
				_ = m5.Decode(d)
				m.Wallpaper = m5
			}
			if (flags & (1 << 2)) != 0 {
				m6 := &WallPaperSettings{}
				_ = m6.Decode(d)
				m.Settings = m6
			}
			if (flags & (1 << 1)) != 0 {
				m.Id = new(int32)
				*m.Id, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchEmojiStickerSets <--
type TLMessagesSearchEmojiStickerSets struct {
	ClazzID         uint32 `json:"_id"`
	ExcludeFeatured bool   `json:"exclude_featured"`
	Q               string `json:"q"`
	Hash            int64  `json:"hash"`
}

func (m *TLMessagesSearchEmojiStickerSets) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchEmojiStickerSets) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x92b4494c: func() error {
			x.PutClazzID(0x92b4494c)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ExcludeFeatured == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Q)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchEmojiStickerSets, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchEmojiStickerSets, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchEmojiStickerSets) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x92b4494c: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ExcludeFeatured = true
			}
			m.Q, err = d.String()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSavedDialogs <--
type TLMessagesGetSavedDialogs struct {
	ClazzID       uint32     `json:"_id"`
	ExcludePinned bool       `json:"exclude_pinned"`
	OffsetDate    int32      `json:"offset_date"`
	OffsetId      int32      `json:"offset_id"`
	OffsetPeer    *InputPeer `json:"offset_peer"`
	Limit         int32      `json:"limit"`
	Hash          int64      `json:"hash"`
}

func (m *TLMessagesGetSavedDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSavedDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5381d21a: func() error {
			x.PutClazzID(0x5381d21a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ExcludePinned == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.OffsetId)
			_ = m.OffsetPeer.Encode(x, layer)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSavedDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSavedDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSavedDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5381d21a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ExcludePinned = true
			}
			m.OffsetDate, err = d.Int32()
			m.OffsetId, err = d.Int32()

			m5 := &InputPeer{}
			_ = m5.Decode(d)
			m.OffsetPeer = m5

			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSavedHistory <--
type TLMessagesGetSavedHistory struct {
	ClazzID    uint32     `json:"_id"`
	Peer       *InputPeer `json:"peer"`
	OffsetId   int32      `json:"offset_id"`
	OffsetDate int32      `json:"offset_date"`
	AddOffset  int32      `json:"add_offset"`
	Limit      int32      `json:"limit"`
	MaxId      int32      `json:"max_id"`
	MinId      int32      `json:"min_id"`
	Hash       int64      `json:"hash"`
}

func (m *TLMessagesGetSavedHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSavedHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3d9a414d: func() error {
			x.PutClazzID(0x3d9a414d)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.AddOffset)
			x.PutInt32(m.Limit)
			x.PutInt32(m.MaxId)
			x.PutInt32(m.MinId)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSavedHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSavedHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSavedHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3d9a414d: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.OffsetId, err = d.Int32()
			m.OffsetDate, err = d.Int32()
			m.AddOffset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.MaxId, err = d.Int32()
			m.MinId, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteSavedHistory <--
type TLMessagesDeleteSavedHistory struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MaxId   int32      `json:"max_id"`
	MinDate *int32     `json:"min_date"`
	MaxDate *int32     `json:"max_date"`
}

func (m *TLMessagesDeleteSavedHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteSavedHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6e98102b: func() error {
			x.PutClazzID(0x6e98102b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MinDate != nil {
					flags |= 1 << 2
				}
				if m.MaxDate != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxId)
			if m.MinDate != nil {
				x.PutInt32(*m.MinDate)
			}

			if m.MaxDate != nil {
				x.PutInt32(*m.MaxDate)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteSavedHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteSavedHistory, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteSavedHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6e98102b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			m.MaxId, err = d.Int32()
			if (flags & (1 << 2)) != 0 {
				m.MinDate = new(int32)
				*m.MinDate, err = d.Int32()
			}
			if (flags & (1 << 3)) != 0 {
				m.MaxDate = new(int32)
				*m.MaxDate, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPinnedSavedDialogs <--
type TLMessagesGetPinnedSavedDialogs struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetPinnedSavedDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPinnedSavedDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd63d94e0: func() error {
			x.PutClazzID(0xd63d94e0)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPinnedSavedDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPinnedSavedDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPinnedSavedDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd63d94e0: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleSavedDialogPin <--
type TLMessagesToggleSavedDialogPin struct {
	ClazzID uint32           `json:"_id"`
	Pinned  bool             `json:"pinned"`
	Peer    *InputDialogPeer `json:"peer"`
}

func (m *TLMessagesToggleSavedDialogPin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleSavedDialogPin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xac81bbde: func() error {
			x.PutClazzID(0xac81bbde)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Pinned == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleSavedDialogPin, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleSavedDialogPin, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleSavedDialogPin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xac81bbde: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Pinned = true
			}

			m3 := &InputDialogPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReorderPinnedSavedDialogs <--
type TLMessagesReorderPinnedSavedDialogs struct {
	ClazzID uint32             `json:"_id"`
	Force   bool               `json:"force"`
	Order   []*InputDialogPeer `json:"order"`
}

func (m *TLMessagesReorderPinnedSavedDialogs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReorderPinnedSavedDialogs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8b716587: func() error {
			x.PutClazzID(0x8b716587)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Force == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			_ = iface.EncodeObjectList(x, m.Order, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reorderPinnedSavedDialogs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reorderPinnedSavedDialogs, layer)
	}
}

// Decode <--
func (m *TLMessagesReorderPinnedSavedDialogs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8b716587: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Force = true
			}
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			v3 := make([]*InputDialogPeer, l3)
			for i := 0; i < l3; i++ {
				vv := new(InputDialogPeer)
				err3 = vv.Decode(d)
				_ = err3
				v3[i] = vv
			}
			m.Order = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSavedReactionTags <--
type TLMessagesGetSavedReactionTags struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Hash    int64      `json:"hash"`
}

func (m *TLMessagesGetSavedReactionTags) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSavedReactionTags) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3637e05b: func() error {
			x.PutClazzID(0x3637e05b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Peer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSavedReactionTags, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSavedReactionTags, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSavedReactionTags) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3637e05b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &InputPeer{}
				_ = m2.Decode(d)
				m.Peer = m2
			}
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesUpdateSavedReactionTag <--
type TLMessagesUpdateSavedReactionTag struct {
	ClazzID  uint32    `json:"_id"`
	Reaction *Reaction `json:"reaction"`
	Title    *string   `json:"title"`
}

func (m *TLMessagesUpdateSavedReactionTag) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesUpdateSavedReactionTag) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x60297dec: func() error {
			x.PutClazzID(0x60297dec)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Title != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Reaction.Encode(x, layer)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_updateSavedReactionTag, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_updateSavedReactionTag, layer)
	}
}

// Decode <--
func (m *TLMessagesUpdateSavedReactionTag) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x60297dec: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &Reaction{}
			_ = m2.Decode(d)
			m.Reaction = m2

			if (flags & (1 << 0)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetDefaultTagReactions <--
type TLMessagesGetDefaultTagReactions struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetDefaultTagReactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetDefaultTagReactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbdf93428: func() error {
			x.PutClazzID(0xbdf93428)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getDefaultTagReactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getDefaultTagReactions, layer)
	}
}

// Decode <--
func (m *TLMessagesGetDefaultTagReactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbdf93428: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetOutboxReadDate <--
type TLMessagesGetOutboxReadDate struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MsgId   int32      `json:"msg_id"`
}

func (m *TLMessagesGetOutboxReadDate) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetOutboxReadDate) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8c4bfe5d: func() error {
			x.PutClazzID(0x8c4bfe5d)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getOutboxReadDate, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getOutboxReadDate, layer)
	}
}

// Decode <--
func (m *TLMessagesGetOutboxReadDate) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8c4bfe5d: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetQuickReplies <--
type TLMessagesGetQuickReplies struct {
	ClazzID uint32 `json:"_id"`
	Hash    int64  `json:"hash"`
}

func (m *TLMessagesGetQuickReplies) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetQuickReplies) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd483f2a8: func() error {
			x.PutClazzID(0xd483f2a8)

			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getQuickReplies, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getQuickReplies, layer)
	}
}

// Decode <--
func (m *TLMessagesGetQuickReplies) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd483f2a8: func() (err error) {
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReorderQuickReplies <--
type TLMessagesReorderQuickReplies struct {
	ClazzID uint32  `json:"_id"`
	Order   []int32 `json:"order"`
}

func (m *TLMessagesReorderQuickReplies) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReorderQuickReplies) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x60331907: func() error {
			x.PutClazzID(0x60331907)

			iface.EncodeInt32List(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reorderQuickReplies, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reorderQuickReplies, layer)
	}
}

// Decode <--
func (m *TLMessagesReorderQuickReplies) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x60331907: func() (err error) {

			m.Order, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesCheckQuickReplyShortcut <--
type TLMessagesCheckQuickReplyShortcut struct {
	ClazzID  uint32 `json:"_id"`
	Shortcut string `json:"shortcut"`
}

func (m *TLMessagesCheckQuickReplyShortcut) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesCheckQuickReplyShortcut) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf1d0fbd3: func() error {
			x.PutClazzID(0xf1d0fbd3)

			x.PutString(m.Shortcut)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_checkQuickReplyShortcut, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_checkQuickReplyShortcut, layer)
	}
}

// Decode <--
func (m *TLMessagesCheckQuickReplyShortcut) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf1d0fbd3: func() (err error) {
			m.Shortcut, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditQuickReplyShortcut <--
type TLMessagesEditQuickReplyShortcut struct {
	ClazzID    uint32 `json:"_id"`
	ShortcutId int32  `json:"shortcut_id"`
	Shortcut   string `json:"shortcut"`
}

func (m *TLMessagesEditQuickReplyShortcut) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditQuickReplyShortcut) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5c003cef: func() error {
			x.PutClazzID(0x5c003cef)

			x.PutInt32(m.ShortcutId)
			x.PutString(m.Shortcut)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editQuickReplyShortcut, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editQuickReplyShortcut, layer)
	}
}

// Decode <--
func (m *TLMessagesEditQuickReplyShortcut) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5c003cef: func() (err error) {
			m.ShortcutId, err = d.Int32()
			m.Shortcut, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteQuickReplyShortcut <--
type TLMessagesDeleteQuickReplyShortcut struct {
	ClazzID    uint32 `json:"_id"`
	ShortcutId int32  `json:"shortcut_id"`
}

func (m *TLMessagesDeleteQuickReplyShortcut) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteQuickReplyShortcut) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3cc04740: func() error {
			x.PutClazzID(0x3cc04740)

			x.PutInt32(m.ShortcutId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteQuickReplyShortcut, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteQuickReplyShortcut, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteQuickReplyShortcut) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3cc04740: func() (err error) {
			m.ShortcutId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetQuickReplyMessages <--
type TLMessagesGetQuickReplyMessages struct {
	ClazzID    uint32  `json:"_id"`
	ShortcutId int32   `json:"shortcut_id"`
	Id         []int32 `json:"id"`
	Hash       int64   `json:"hash"`
}

func (m *TLMessagesGetQuickReplyMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetQuickReplyMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x94a495c3: func() error {
			x.PutClazzID(0x94a495c3)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Id != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.ShortcutId)
			if m.Id != nil {
				iface.EncodeInt32List(x, m.Id)
			}
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getQuickReplyMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getQuickReplyMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesGetQuickReplyMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x94a495c3: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.ShortcutId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Id, err = iface.DecodeInt32List(d)
			}
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendQuickReplyMessages <--
type TLMessagesSendQuickReplyMessages struct {
	ClazzID    uint32     `json:"_id"`
	Peer       *InputPeer `json:"peer"`
	ShortcutId int32      `json:"shortcut_id"`
	Id         []int32    `json:"id"`
	RandomId   []int64    `json:"random_id"`
}

func (m *TLMessagesSendQuickReplyMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendQuickReplyMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6c750de1: func() error {
			x.PutClazzID(0x6c750de1)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.ShortcutId)

			iface.EncodeInt32List(x, m.Id)

			iface.EncodeInt64List(x, m.RandomId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendQuickReplyMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendQuickReplyMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesSendQuickReplyMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6c750de1: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.ShortcutId, err = d.Int32()

			m.Id, err = iface.DecodeInt32List(d)

			m.RandomId, err = iface.DecodeInt64List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteQuickReplyMessages <--
type TLMessagesDeleteQuickReplyMessages struct {
	ClazzID    uint32  `json:"_id"`
	ShortcutId int32   `json:"shortcut_id"`
	Id         []int32 `json:"id"`
}

func (m *TLMessagesDeleteQuickReplyMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteQuickReplyMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe105e910: func() error {
			x.PutClazzID(0xe105e910)

			x.PutInt32(m.ShortcutId)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteQuickReplyMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteQuickReplyMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteQuickReplyMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe105e910: func() (err error) {
			m.ShortcutId, err = d.Int32()

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesToggleDialogFilterTags <--
type TLMessagesToggleDialogFilterTags struct {
	ClazzID uint32 `json:"_id"`
	Enabled *Bool  `json:"enabled"`
}

func (m *TLMessagesToggleDialogFilterTags) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesToggleDialogFilterTags) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfd2dda49: func() error {
			x.PutClazzID(0xfd2dda49)

			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_toggleDialogFilterTags, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_toggleDialogFilterTags, layer)
	}
}

// Decode <--
func (m *TLMessagesToggleDialogFilterTags) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfd2dda49: func() (err error) {

			m1 := &Bool{}
			_ = m1.Decode(d)
			m.Enabled = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetMyStickers <--
type TLMessagesGetMyStickers struct {
	ClazzID  uint32 `json:"_id"`
	OffsetId int64  `json:"offset_id"`
	Limit    int32  `json:"limit"`
}

func (m *TLMessagesGetMyStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetMyStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd0b5e1fc: func() error {
			x.PutClazzID(0xd0b5e1fc)

			x.PutInt64(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getMyStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getMyStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesGetMyStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd0b5e1fc: func() (err error) {
			m.OffsetId, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetEmojiStickerGroups <--
type TLMessagesGetEmojiStickerGroups struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetEmojiStickerGroups) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetEmojiStickerGroups) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1dd840f5: func() error {
			x.PutClazzID(0x1dd840f5)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getEmojiStickerGroups, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getEmojiStickerGroups, layer)
	}
}

// Decode <--
func (m *TLMessagesGetEmojiStickerGroups) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1dd840f5: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetAvailableEffects <--
type TLMessagesGetAvailableEffects struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLMessagesGetAvailableEffects) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetAvailableEffects) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdea20a39: func() error {
			x.PutClazzID(0xdea20a39)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getAvailableEffects, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getAvailableEffects, layer)
	}
}

// Decode <--
func (m *TLMessagesGetAvailableEffects) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdea20a39: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesEditFactCheck <--
type TLMessagesEditFactCheck struct {
	ClazzID uint32            `json:"_id"`
	Peer    *InputPeer        `json:"peer"`
	MsgId   int32             `json:"msg_id"`
	Text    *TextWithEntities `json:"text"`
}

func (m *TLMessagesEditFactCheck) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesEditFactCheck) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x589ee75: func() error {
			x.PutClazzID(0x589ee75)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			_ = m.Text.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_editFactCheck, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_editFactCheck, layer)
	}
}

// Decode <--
func (m *TLMessagesEditFactCheck) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x589ee75: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			m3 := &TextWithEntities{}
			_ = m3.Decode(d)
			m.Text = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesDeleteFactCheck <--
type TLMessagesDeleteFactCheck struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MsgId   int32      `json:"msg_id"`
}

func (m *TLMessagesDeleteFactCheck) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesDeleteFactCheck) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd1da940c: func() error {
			x.PutClazzID(0xd1da940c)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_deleteFactCheck, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_deleteFactCheck, layer)
	}
}

// Decode <--
func (m *TLMessagesDeleteFactCheck) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd1da940c: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetFactCheck <--
type TLMessagesGetFactCheck struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MsgId   []int32    `json:"msg_id"`
}

func (m *TLMessagesGetFactCheck) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetFactCheck) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb9cdc5ee: func() error {
			x.PutClazzID(0xb9cdc5ee)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getFactCheck, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getFactCheck, layer)
	}
}

// Decode <--
func (m *TLMessagesGetFactCheck) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb9cdc5ee: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesRequestMainWebView <--
type TLMessagesRequestMainWebView struct {
	ClazzID     uint32     `json:"_id"`
	Compact     bool       `json:"compact"`
	Fullscreen  bool       `json:"fullscreen"`
	Peer        *InputPeer `json:"peer"`
	Bot         *InputUser `json:"bot"`
	StartParam  *string    `json:"start_param"`
	ThemeParams *DataJSON  `json:"theme_params"`
	Platform    string     `json:"platform"`
}

func (m *TLMessagesRequestMainWebView) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesRequestMainWebView) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc9e01e7b: func() error {
			x.PutClazzID(0xc9e01e7b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Compact == true {
					flags |= 1 << 7
				}
				if m.Fullscreen == true {
					flags |= 1 << 8
				}

				if m.StartParam != nil {
					flags |= 1 << 1
				}
				if m.ThemeParams != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.Bot.Encode(x, layer)
			if m.StartParam != nil {
				x.PutString(*m.StartParam)
			}

			if m.ThemeParams != nil {
				_ = m.ThemeParams.Encode(x, layer)
			}

			x.PutString(m.Platform)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_requestMainWebView, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_requestMainWebView, layer)
	}
}

// Decode <--
func (m *TLMessagesRequestMainWebView) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc9e01e7b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 7)) != 0 {
				m.Compact = true
			}
			if (flags & (1 << 8)) != 0 {
				m.Fullscreen = true
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			m5 := &InputUser{}
			_ = m5.Decode(d)
			m.Bot = m5

			if (flags & (1 << 1)) != 0 {
				m.StartParam = new(string)
				*m.StartParam, err = d.String()
			}

			if (flags & (1 << 0)) != 0 {
				m7 := &DataJSON{}
				_ = m7.Decode(d)
				m.ThemeParams = m7
			}
			m.Platform, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSendPaidReaction <--
type TLMessagesSendPaidReaction struct {
	ClazzID  uint32               `json:"_id"`
	Peer     *InputPeer           `json:"peer"`
	MsgId    int32                `json:"msg_id"`
	Count    int32                `json:"count"`
	RandomId int64                `json:"random_id"`
	Private  *PaidReactionPrivacy `json:"private"`
}

func (m *TLMessagesSendPaidReaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSendPaidReaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x58bbcb50: func() error {
			x.PutClazzID(0x58bbcb50)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Private != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutInt32(m.Count)
			x.PutInt64(m.RandomId)
			if m.Private != nil {
				_ = m.Private.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_sendPaidReaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_sendPaidReaction, layer)
	}
}

// Decode <--
func (m *TLMessagesSendPaidReaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x58bbcb50: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			m.MsgId, err = d.Int32()
			m.Count, err = d.Int32()
			m.RandomId, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m6 := &PaidReactionPrivacy{}
				_ = m6.Decode(d)
				m.Private = m6
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesTogglePaidReactionPrivacy <--
type TLMessagesTogglePaidReactionPrivacy struct {
	ClazzID uint32               `json:"_id"`
	Peer    *InputPeer           `json:"peer"`
	MsgId   int32                `json:"msg_id"`
	Private *PaidReactionPrivacy `json:"private"`
}

func (m *TLMessagesTogglePaidReactionPrivacy) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesTogglePaidReactionPrivacy) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x435885b5: func() error {
			x.PutClazzID(0x435885b5)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)
			_ = m.Private.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_togglePaidReactionPrivacy, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_togglePaidReactionPrivacy, layer)
	}
}

// Decode <--
func (m *TLMessagesTogglePaidReactionPrivacy) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x435885b5: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			m3 := &PaidReactionPrivacy{}
			_ = m3.Decode(d)
			m.Private = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPaidReactionPrivacy <--
type TLMessagesGetPaidReactionPrivacy struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLMessagesGetPaidReactionPrivacy) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPaidReactionPrivacy) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x472455aa: func() error {
			x.PutClazzID(0x472455aa)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPaidReactionPrivacy, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPaidReactionPrivacy, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPaidReactionPrivacy) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x472455aa: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesViewSponsoredMessage <--
type TLMessagesViewSponsoredMessage struct {
	ClazzID  uint32     `json:"_id"`
	RandomId []byte     `json:"random_id"`
	Peer     *InputPeer `json:"peer"`
}

func (m *TLMessagesViewSponsoredMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesViewSponsoredMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x269e3643: func() error {
			x.PutClazzID(0x269e3643)

			x.PutBytes(m.RandomId)

			return nil
		},
		0x673ad8f1: func() error {
			x.PutClazzID(0x673ad8f1)

			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.RandomId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_viewSponsoredMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_viewSponsoredMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesViewSponsoredMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x269e3643: func() (err error) {
			m.RandomId, err = d.Bytes()

			return nil
		},
		0x673ad8f1: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.RandomId, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesClickSponsoredMessage <--
type TLMessagesClickSponsoredMessage struct {
	ClazzID    uint32     `json:"_id"`
	Media      bool       `json:"media"`
	Fullscreen bool       `json:"fullscreen"`
	RandomId   []byte     `json:"random_id"`
	Peer       *InputPeer `json:"peer"`
}

func (m *TLMessagesClickSponsoredMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesClickSponsoredMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8235057e: func() error {
			x.PutClazzID(0x8235057e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Media == true {
					flags |= 1 << 0
				}
				if m.Fullscreen == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutBytes(m.RandomId)

			return nil
		},
		0xf093465: func() error {
			x.PutClazzID(0xf093465)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Media == true {
					flags |= 1 << 0
				}
				if m.Fullscreen == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.RandomId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_clickSponsoredMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_clickSponsoredMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesClickSponsoredMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8235057e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Media = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Fullscreen = true
			}
			m.RandomId, err = d.Bytes()

			return nil
		},
		0xf093465: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Media = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Fullscreen = true
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			m.RandomId, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReportSponsoredMessage <--
type TLMessagesReportSponsoredMessage struct {
	ClazzID  uint32     `json:"_id"`
	RandomId []byte     `json:"random_id"`
	Option   []byte     `json:"option"`
	Peer     *InputPeer `json:"peer"`
}

func (m *TLMessagesReportSponsoredMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReportSponsoredMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x12cbf0c4: func() error {
			x.PutClazzID(0x12cbf0c4)

			x.PutBytes(m.RandomId)
			x.PutBytes(m.Option)

			return nil
		},
		0x1af3dbb8: func() error {
			x.PutClazzID(0x1af3dbb8)

			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.RandomId)
			x.PutBytes(m.Option)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reportSponsoredMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reportSponsoredMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesReportSponsoredMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x12cbf0c4: func() (err error) {
			m.RandomId, err = d.Bytes()
			m.Option, err = d.Bytes()

			return nil
		},
		0x1af3dbb8: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.RandomId, err = d.Bytes()
			m.Option, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetSponsoredMessages <--
type TLMessagesGetSponsoredMessages struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLMessagesGetSponsoredMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetSponsoredMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9bd2f439: func() error {
			x.PutClazzID(0x9bd2f439)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getSponsoredMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getSponsoredMessages, layer)
	}
}

// Decode <--
func (m *TLMessagesGetSponsoredMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9bd2f439: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSavePreparedInlineMessage <--
type TLMessagesSavePreparedInlineMessage struct {
	ClazzID   uint32                 `json:"_id"`
	Result    *InputBotInlineResult  `json:"result"`
	UserId    *InputUser             `json:"user_id"`
	PeerTypes []*InlineQueryPeerType `json:"peer_types"`
}

func (m *TLMessagesSavePreparedInlineMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSavePreparedInlineMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf21f7f2f: func() error {
			x.PutClazzID(0xf21f7f2f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.PeerTypes != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Result.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)
			if m.PeerTypes != nil {
				_ = iface.EncodeObjectList(x, m.PeerTypes, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_savePreparedInlineMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_savePreparedInlineMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesSavePreparedInlineMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf21f7f2f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputBotInlineResult{}
			_ = m2.Decode(d)
			m.Result = m2

			m3 := &InputUser{}
			_ = m3.Decode(d)
			m.UserId = m3

			if (flags & (1 << 0)) != 0 {
				c4, err2 := d.ClazzID()
				if c4 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 4, c4)
					return err2
				}
				l4, err3 := d.Int()
				v4 := make([]*InlineQueryPeerType, l4)
				for i := 0; i < l4; i++ {
					vv := new(InlineQueryPeerType)
					err3 = vv.Decode(d)
					_ = err3
					v4[i] = vv
				}
				m.PeerTypes = v4
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesGetPreparedInlineMessage <--
type TLMessagesGetPreparedInlineMessage struct {
	ClazzID uint32     `json:"_id"`
	Bot     *InputUser `json:"bot"`
	Id      string     `json:"id"`
}

func (m *TLMessagesGetPreparedInlineMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesGetPreparedInlineMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x857ebdb8: func() error {
			x.PutClazzID(0x857ebdb8)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_getPreparedInlineMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_getPreparedInlineMessage, layer)
	}
}

// Decode <--
func (m *TLMessagesGetPreparedInlineMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x857ebdb8: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.Id, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesSearchStickers <--
type TLMessagesSearchStickers struct {
	ClazzID  uint32   `json:"_id"`
	Emojis   bool     `json:"emojis"`
	Q        string   `json:"q"`
	Emoticon string   `json:"emoticon"`
	LangCode []string `json:"lang_code"`
	Offset   int32    `json:"offset"`
	Limit    int32    `json:"limit"`
	Hash     int64    `json:"hash"`
}

func (m *TLMessagesSearchStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesSearchStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x29b1c66a: func() error {
			x.PutClazzID(0x29b1c66a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Emojis == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Q)
			x.PutString(m.Emoticon)

			iface.EncodeStringList(x, m.LangCode)

			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_searchStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_searchStickers, layer)
	}
}

// Decode <--
func (m *TLMessagesSearchStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x29b1c66a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Emojis = true
			}
			m.Q, err = d.String()
			m.Emoticon, err = d.String()

			m.LangCode, err = iface.DecodeStringList(d)

			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLMessagesReportMessagesDelivery <--
type TLMessagesReportMessagesDelivery struct {
	ClazzID uint32     `json:"_id"`
	Push    bool       `json:"push"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLMessagesReportMessagesDelivery) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLMessagesReportMessagesDelivery) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5a6d7395: func() error {
			x.PutClazzID(0x5a6d7395)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Push == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_messages_reportMessagesDelivery, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_messages_reportMessagesDelivery, layer)
	}
}

// Decode <--
func (m *TLMessagesReportMessagesDelivery) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5a6d7395: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Push = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUpdatesGetState <--
type TLUpdatesGetState struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLUpdatesGetState) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUpdatesGetState) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xedd4882a: func() error {
			x.PutClazzID(0xedd4882a)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_updates_getState, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_updates_getState, layer)
	}
}

// Decode <--
func (m *TLUpdatesGetState) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xedd4882a: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUpdatesGetDifference <--
type TLUpdatesGetDifference struct {
	ClazzID       uint32 `json:"_id"`
	Pts           int32  `json:"pts"`
	PtsLimit      *int32 `json:"pts_limit"`
	PtsTotalLimit *int32 `json:"pts_total_limit"`
	Date          int32  `json:"date"`
	Qts           int32  `json:"qts"`
	QtsLimit      *int32 `json:"qts_limit"`
}

func (m *TLUpdatesGetDifference) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUpdatesGetDifference) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x19c2f763: func() error {
			x.PutClazzID(0x19c2f763)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.PtsLimit != nil {
					flags |= 1 << 1
				}
				if m.PtsTotalLimit != nil {
					flags |= 1 << 0
				}

				if m.QtsLimit != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt32(m.Pts)
			if m.PtsLimit != nil {
				x.PutInt32(*m.PtsLimit)
			}

			if m.PtsTotalLimit != nil {
				x.PutInt32(*m.PtsTotalLimit)
			}

			x.PutInt32(m.Date)
			x.PutInt32(m.Qts)
			if m.QtsLimit != nil {
				x.PutInt32(*m.QtsLimit)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_updates_getDifference, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_updates_getDifference, layer)
	}
}

// Decode <--
func (m *TLUpdatesGetDifference) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x19c2f763: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Pts, err = d.Int32()
			if (flags & (1 << 1)) != 0 {
				m.PtsLimit = new(int32)
				*m.PtsLimit, err = d.Int32()
			}
			if (flags & (1 << 0)) != 0 {
				m.PtsTotalLimit = new(int32)
				*m.PtsTotalLimit, err = d.Int32()
			}
			m.Date, err = d.Int32()
			m.Qts, err = d.Int32()
			if (flags & (1 << 2)) != 0 {
				m.QtsLimit = new(int32)
				*m.QtsLimit, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUpdatesGetChannelDifference <--
type TLUpdatesGetChannelDifference struct {
	ClazzID uint32                 `json:"_id"`
	Force   bool                   `json:"force"`
	Channel *InputChannel          `json:"channel"`
	Filter  *ChannelMessagesFilter `json:"filter"`
	Pts     int32                  `json:"pts"`
	Limit   int32                  `json:"limit"`
}

func (m *TLUpdatesGetChannelDifference) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUpdatesGetChannelDifference) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3173d78: func() error {
			x.PutClazzID(0x3173d78)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Force == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.Pts)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_updates_getChannelDifference, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_updates_getChannelDifference, layer)
	}
}

// Decode <--
func (m *TLUpdatesGetChannelDifference) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3173d78: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Force = true
			}

			m3 := &InputChannel{}
			_ = m3.Decode(d)
			m.Channel = m3

			m4 := &ChannelMessagesFilter{}
			_ = m4.Decode(d)
			m.Filter = m4

			m.Pts, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhotosUpdateProfilePhoto <--
type TLPhotosUpdateProfilePhoto struct {
	ClazzID  uint32      `json:"_id"`
	Fallback bool        `json:"fallback"`
	Bot      *InputUser  `json:"bot"`
	Id       *InputPhoto `json:"id"`
}

func (m *TLPhotosUpdateProfilePhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhotosUpdateProfilePhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9e82039: func() error {
			x.PutClazzID(0x9e82039)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Fallback == true {
					flags |= 1 << 0
				}
				if m.Bot != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Bot != nil {
				_ = m.Bot.Encode(x, layer)
			}

			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_photos_updateProfilePhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_photos_updateProfilePhoto, layer)
	}
}

// Decode <--
func (m *TLPhotosUpdateProfilePhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9e82039: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Fallback = true
			}
			if (flags & (1 << 1)) != 0 {
				m3 := &InputUser{}
				_ = m3.Decode(d)
				m.Bot = m3
			}

			m4 := &InputPhoto{}
			_ = m4.Decode(d)
			m.Id = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhotosUploadProfilePhoto <--
type TLPhotosUploadProfilePhoto struct {
	ClazzID          uint32     `json:"_id"`
	Fallback         bool       `json:"fallback"`
	Bot              *InputUser `json:"bot"`
	File             *InputFile `json:"file"`
	Video            *InputFile `json:"video"`
	VideoStartTs     *float64   `json:"video_start_ts"`
	VideoEmojiMarkup *VideoSize `json:"video_emoji_markup"`
}

func (m *TLPhotosUploadProfilePhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhotosUploadProfilePhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x388a3b5: func() error {
			x.PutClazzID(0x388a3b5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Fallback == true {
					flags |= 1 << 3
				}
				if m.Bot != nil {
					flags |= 1 << 5
				}
				if m.File != nil {
					flags |= 1 << 0
				}
				if m.Video != nil {
					flags |= 1 << 1
				}
				if m.VideoStartTs != nil {
					flags |= 1 << 2
				}
				if m.VideoEmojiMarkup != nil {
					flags |= 1 << 4
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Bot != nil {
				_ = m.Bot.Encode(x, layer)
			}

			if m.File != nil {
				_ = m.File.Encode(x, layer)
			}

			if m.Video != nil {
				_ = m.Video.Encode(x, layer)
			}

			if m.VideoStartTs != nil {
				x.PutDouble(*m.VideoStartTs)
			}

			if m.VideoEmojiMarkup != nil {
				_ = m.VideoEmojiMarkup.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_photos_uploadProfilePhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_photos_uploadProfilePhoto, layer)
	}
}

// Decode <--
func (m *TLPhotosUploadProfilePhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x388a3b5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 3)) != 0 {
				m.Fallback = true
			}
			if (flags & (1 << 5)) != 0 {
				m3 := &InputUser{}
				_ = m3.Decode(d)
				m.Bot = m3
			}
			if (flags & (1 << 0)) != 0 {
				m4 := &InputFile{}
				_ = m4.Decode(d)
				m.File = m4
			}
			if (flags & (1 << 1)) != 0 {
				m5 := &InputFile{}
				_ = m5.Decode(d)
				m.Video = m5
			}
			if (flags & (1 << 2)) != 0 {
				m.VideoStartTs = new(float64)
				*m.VideoStartTs, err = d.Double()
			}

			if (flags & (1 << 4)) != 0 {
				m7 := &VideoSize{}
				_ = m7.Decode(d)
				m.VideoEmojiMarkup = m7
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhotosDeletePhotos <--
type TLPhotosDeletePhotos struct {
	ClazzID uint32        `json:"_id"`
	Id      []*InputPhoto `json:"id"`
}

func (m *TLPhotosDeletePhotos) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhotosDeletePhotos) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x87cf7f2f: func() error {
			x.PutClazzID(0x87cf7f2f)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_photos_deletePhotos, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_photos_deletePhotos, layer)
	}
}

// Decode <--
func (m *TLPhotosDeletePhotos) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x87cf7f2f: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputPhoto, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputPhoto)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhotosGetUserPhotos <--
type TLPhotosGetUserPhotos struct {
	ClazzID uint32     `json:"_id"`
	UserId  *InputUser `json:"user_id"`
	Offset  int32      `json:"offset"`
	MaxId   int64      `json:"max_id"`
	Limit   int32      `json:"limit"`
}

func (m *TLPhotosGetUserPhotos) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhotosGetUserPhotos) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x91cd32a8: func() error {
			x.PutClazzID(0x91cd32a8)

			_ = m.UserId.Encode(x, layer)
			x.PutInt32(m.Offset)
			x.PutInt64(m.MaxId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_photos_getUserPhotos, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_photos_getUserPhotos, layer)
	}
}

// Decode <--
func (m *TLPhotosGetUserPhotos) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x91cd32a8: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.UserId = m1

			m.Offset, err = d.Int32()
			m.MaxId, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhotosUploadContactProfilePhoto <--
type TLPhotosUploadContactProfilePhoto struct {
	ClazzID          uint32     `json:"_id"`
	Suggest          bool       `json:"suggest"`
	Save             bool       `json:"save"`
	UserId           *InputUser `json:"user_id"`
	File             *InputFile `json:"file"`
	Video            *InputFile `json:"video"`
	VideoStartTs     *float64   `json:"video_start_ts"`
	VideoEmojiMarkup *VideoSize `json:"video_emoji_markup"`
}

func (m *TLPhotosUploadContactProfilePhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhotosUploadContactProfilePhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe14c4a71: func() error {
			x.PutClazzID(0xe14c4a71)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Suggest == true {
					flags |= 1 << 3
				}
				if m.Save == true {
					flags |= 1 << 4
				}

				if m.File != nil {
					flags |= 1 << 0
				}
				if m.Video != nil {
					flags |= 1 << 1
				}
				if m.VideoStartTs != nil {
					flags |= 1 << 2
				}
				if m.VideoEmojiMarkup != nil {
					flags |= 1 << 5
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.UserId.Encode(x, layer)
			if m.File != nil {
				_ = m.File.Encode(x, layer)
			}

			if m.Video != nil {
				_ = m.Video.Encode(x, layer)
			}

			if m.VideoStartTs != nil {
				x.PutDouble(*m.VideoStartTs)
			}

			if m.VideoEmojiMarkup != nil {
				_ = m.VideoEmojiMarkup.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_photos_uploadContactProfilePhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_photos_uploadContactProfilePhoto, layer)
	}
}

// Decode <--
func (m *TLPhotosUploadContactProfilePhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe14c4a71: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 3)) != 0 {
				m.Suggest = true
			}
			if (flags & (1 << 4)) != 0 {
				m.Save = true
			}

			m4 := &InputUser{}
			_ = m4.Decode(d)
			m.UserId = m4

			if (flags & (1 << 0)) != 0 {
				m5 := &InputFile{}
				_ = m5.Decode(d)
				m.File = m5
			}
			if (flags & (1 << 1)) != 0 {
				m6 := &InputFile{}
				_ = m6.Decode(d)
				m.Video = m6
			}
			if (flags & (1 << 2)) != 0 {
				m.VideoStartTs = new(float64)
				*m.VideoStartTs, err = d.Double()
			}

			if (flags & (1 << 5)) != 0 {
				m8 := &VideoSize{}
				_ = m8.Decode(d)
				m.VideoEmojiMarkup = m8
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadSaveFilePart <--
type TLUploadSaveFilePart struct {
	ClazzID  uint32 `json:"_id"`
	FileId   int64  `json:"file_id"`
	FilePart int32  `json:"file_part"`
	Bytes    []byte `json:"bytes"`
}

func (m *TLUploadSaveFilePart) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadSaveFilePart) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb304a621: func() error {
			x.PutClazzID(0xb304a621)

			x.PutInt64(m.FileId)
			x.PutInt32(m.FilePart)
			x.PutBytes(m.Bytes)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_saveFilePart, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_saveFilePart, layer)
	}
}

// Decode <--
func (m *TLUploadSaveFilePart) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb304a621: func() (err error) {
			m.FileId, err = d.Int64()
			m.FilePart, err = d.Int32()
			m.Bytes, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadGetFile <--
type TLUploadGetFile struct {
	ClazzID      uint32             `json:"_id"`
	Precise      bool               `json:"precise"`
	CdnSupported bool               `json:"cdn_supported"`
	Location     *InputFileLocation `json:"location"`
	Offset       int64              `json:"offset"`
	Limit        int32              `json:"limit"`
}

func (m *TLUploadGetFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadGetFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbe5335be: func() error {
			x.PutClazzID(0xbe5335be)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Precise == true {
					flags |= 1 << 0
				}
				if m.CdnSupported == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Location.Encode(x, layer)
			x.PutInt64(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_getFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_getFile, layer)
	}
}

// Decode <--
func (m *TLUploadGetFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbe5335be: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Precise = true
			}
			if (flags & (1 << 1)) != 0 {
				m.CdnSupported = true
			}

			m4 := &InputFileLocation{}
			_ = m4.Decode(d)
			m.Location = m4

			m.Offset, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadSaveBigFilePart <--
type TLUploadSaveBigFilePart struct {
	ClazzID        uint32 `json:"_id"`
	FileId         int64  `json:"file_id"`
	FilePart       int32  `json:"file_part"`
	FileTotalParts int32  `json:"file_total_parts"`
	Bytes          []byte `json:"bytes"`
}

func (m *TLUploadSaveBigFilePart) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadSaveBigFilePart) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xde7b673d: func() error {
			x.PutClazzID(0xde7b673d)

			x.PutInt64(m.FileId)
			x.PutInt32(m.FilePart)
			x.PutInt32(m.FileTotalParts)
			x.PutBytes(m.Bytes)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_saveBigFilePart, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_saveBigFilePart, layer)
	}
}

// Decode <--
func (m *TLUploadSaveBigFilePart) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xde7b673d: func() (err error) {
			m.FileId, err = d.Int64()
			m.FilePart, err = d.Int32()
			m.FileTotalParts, err = d.Int32()
			m.Bytes, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadGetWebFile <--
type TLUploadGetWebFile struct {
	ClazzID  uint32                `json:"_id"`
	Location *InputWebFileLocation `json:"location"`
	Offset   int32                 `json:"offset"`
	Limit    int32                 `json:"limit"`
}

func (m *TLUploadGetWebFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadGetWebFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x24e6818d: func() error {
			x.PutClazzID(0x24e6818d)

			_ = m.Location.Encode(x, layer)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_getWebFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_getWebFile, layer)
	}
}

// Decode <--
func (m *TLUploadGetWebFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x24e6818d: func() (err error) {

			m1 := &InputWebFileLocation{}
			_ = m1.Decode(d)
			m.Location = m1

			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadGetCdnFile <--
type TLUploadGetCdnFile struct {
	ClazzID   uint32 `json:"_id"`
	FileToken []byte `json:"file_token"`
	Offset    int64  `json:"offset"`
	Limit     int32  `json:"limit"`
}

func (m *TLUploadGetCdnFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadGetCdnFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x395f69da: func() error {
			x.PutClazzID(0x395f69da)

			x.PutBytes(m.FileToken)
			x.PutInt64(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_getCdnFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_getCdnFile, layer)
	}
}

// Decode <--
func (m *TLUploadGetCdnFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x395f69da: func() (err error) {
			m.FileToken, err = d.Bytes()
			m.Offset, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadReuploadCdnFile <--
type TLUploadReuploadCdnFile struct {
	ClazzID      uint32 `json:"_id"`
	FileToken    []byte `json:"file_token"`
	RequestToken []byte `json:"request_token"`
}

func (m *TLUploadReuploadCdnFile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadReuploadCdnFile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9b2754a8: func() error {
			x.PutClazzID(0x9b2754a8)

			x.PutBytes(m.FileToken)
			x.PutBytes(m.RequestToken)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_reuploadCdnFile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_reuploadCdnFile, layer)
	}
}

// Decode <--
func (m *TLUploadReuploadCdnFile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9b2754a8: func() (err error) {
			m.FileToken, err = d.Bytes()
			m.RequestToken, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadGetCdnFileHashes <--
type TLUploadGetCdnFileHashes struct {
	ClazzID   uint32 `json:"_id"`
	FileToken []byte `json:"file_token"`
	Offset    int64  `json:"offset"`
}

func (m *TLUploadGetCdnFileHashes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadGetCdnFileHashes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x91dc3f31: func() error {
			x.PutClazzID(0x91dc3f31)

			x.PutBytes(m.FileToken)
			x.PutInt64(m.Offset)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_getCdnFileHashes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_getCdnFileHashes, layer)
	}
}

// Decode <--
func (m *TLUploadGetCdnFileHashes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x91dc3f31: func() (err error) {
			m.FileToken, err = d.Bytes()
			m.Offset, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUploadGetFileHashes <--
type TLUploadGetFileHashes struct {
	ClazzID  uint32             `json:"_id"`
	Location *InputFileLocation `json:"location"`
	Offset   int64              `json:"offset"`
}

func (m *TLUploadGetFileHashes) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUploadGetFileHashes) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9156982a: func() error {
			x.PutClazzID(0x9156982a)

			_ = m.Location.Encode(x, layer)
			x.PutInt64(m.Offset)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_upload_getFileHashes, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_upload_getFileHashes, layer)
	}
}

// Decode <--
func (m *TLUploadGetFileHashes) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9156982a: func() (err error) {

			m1 := &InputFileLocation{}
			_ = m1.Decode(d)
			m.Location = m1

			m.Offset, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetConfig <--
type TLHelpGetConfig struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc4f9186b: func() error {
			x.PutClazzID(0xc4f9186b)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getConfig, layer)
	}
}

// Decode <--
func (m *TLHelpGetConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc4f9186b: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetNearestDc <--
type TLHelpGetNearestDc struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetNearestDc) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetNearestDc) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1fb33026: func() error {
			x.PutClazzID(0x1fb33026)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getNearestDc, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getNearestDc, layer)
	}
}

// Decode <--
func (m *TLHelpGetNearestDc) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1fb33026: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetAppUpdate <--
type TLHelpGetAppUpdate struct {
	ClazzID uint32 `json:"_id"`
	Source  string `json:"source"`
}

func (m *TLHelpGetAppUpdate) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetAppUpdate) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x522d5a7d: func() error {
			x.PutClazzID(0x522d5a7d)

			x.PutString(m.Source)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getAppUpdate, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getAppUpdate, layer)
	}
}

// Decode <--
func (m *TLHelpGetAppUpdate) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x522d5a7d: func() (err error) {
			m.Source, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetInviteText <--
type TLHelpGetInviteText struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetInviteText) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetInviteText) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4d392343: func() error {
			x.PutClazzID(0x4d392343)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getInviteText, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getInviteText, layer)
	}
}

// Decode <--
func (m *TLHelpGetInviteText) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4d392343: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetSupport <--
type TLHelpGetSupport struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetSupport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetSupport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9cdf08cd: func() error {
			x.PutClazzID(0x9cdf08cd)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getSupport, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getSupport, layer)
	}
}

// Decode <--
func (m *TLHelpGetSupport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9cdf08cd: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpSetBotUpdatesStatus <--
type TLHelpSetBotUpdatesStatus struct {
	ClazzID             uint32 `json:"_id"`
	PendingUpdatesCount int32  `json:"pending_updates_count"`
	Message             string `json:"message"`
}

func (m *TLHelpSetBotUpdatesStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpSetBotUpdatesStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xec22cfcd: func() error {
			x.PutClazzID(0xec22cfcd)

			x.PutInt32(m.PendingUpdatesCount)
			x.PutString(m.Message)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_setBotUpdatesStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_setBotUpdatesStatus, layer)
	}
}

// Decode <--
func (m *TLHelpSetBotUpdatesStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xec22cfcd: func() (err error) {
			m.PendingUpdatesCount, err = d.Int32()
			m.Message, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetCdnConfig <--
type TLHelpGetCdnConfig struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetCdnConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetCdnConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x52029342: func() error {
			x.PutClazzID(0x52029342)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getCdnConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getCdnConfig, layer)
	}
}

// Decode <--
func (m *TLHelpGetCdnConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x52029342: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetRecentMeUrls <--
type TLHelpGetRecentMeUrls struct {
	ClazzID uint32 `json:"_id"`
	Referer string `json:"referer"`
}

func (m *TLHelpGetRecentMeUrls) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetRecentMeUrls) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3dc0f114: func() error {
			x.PutClazzID(0x3dc0f114)

			x.PutString(m.Referer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getRecentMeUrls, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getRecentMeUrls, layer)
	}
}

// Decode <--
func (m *TLHelpGetRecentMeUrls) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3dc0f114: func() (err error) {
			m.Referer, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetTermsOfServiceUpdate <--
type TLHelpGetTermsOfServiceUpdate struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetTermsOfServiceUpdate) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetTermsOfServiceUpdate) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2ca51fd1: func() error {
			x.PutClazzID(0x2ca51fd1)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getTermsOfServiceUpdate, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getTermsOfServiceUpdate, layer)
	}
}

// Decode <--
func (m *TLHelpGetTermsOfServiceUpdate) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2ca51fd1: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpAcceptTermsOfService <--
type TLHelpAcceptTermsOfService struct {
	ClazzID uint32    `json:"_id"`
	Id      *DataJSON `json:"id"`
}

func (m *TLHelpAcceptTermsOfService) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpAcceptTermsOfService) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xee72f79a: func() error {
			x.PutClazzID(0xee72f79a)

			_ = m.Id.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_acceptTermsOfService, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_acceptTermsOfService, layer)
	}
}

// Decode <--
func (m *TLHelpAcceptTermsOfService) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xee72f79a: func() (err error) {

			m1 := &DataJSON{}
			_ = m1.Decode(d)
			m.Id = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetDeepLinkInfo <--
type TLHelpGetDeepLinkInfo struct {
	ClazzID uint32 `json:"_id"`
	Path    string `json:"path"`
}

func (m *TLHelpGetDeepLinkInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetDeepLinkInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3fedc75f: func() error {
			x.PutClazzID(0x3fedc75f)

			x.PutString(m.Path)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getDeepLinkInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getDeepLinkInfo, layer)
	}
}

// Decode <--
func (m *TLHelpGetDeepLinkInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3fedc75f: func() (err error) {
			m.Path, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetAppConfig <--
type TLHelpGetAppConfig struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLHelpGetAppConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetAppConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x61e3f854: func() error {
			x.PutClazzID(0x61e3f854)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getAppConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getAppConfig, layer)
	}
}

// Decode <--
func (m *TLHelpGetAppConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x61e3f854: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpSaveAppLog <--
type TLHelpSaveAppLog struct {
	ClazzID uint32           `json:"_id"`
	Events  []*InputAppEvent `json:"events"`
}

func (m *TLHelpSaveAppLog) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpSaveAppLog) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6f02f748: func() error {
			x.PutClazzID(0x6f02f748)

			_ = iface.EncodeObjectList(x, m.Events, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_saveAppLog, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_saveAppLog, layer)
	}
}

// Decode <--
func (m *TLHelpSaveAppLog) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6f02f748: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputAppEvent, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputAppEvent)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Events = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetPassportConfig <--
type TLHelpGetPassportConfig struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLHelpGetPassportConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetPassportConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc661ad08: func() error {
			x.PutClazzID(0xc661ad08)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getPassportConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getPassportConfig, layer)
	}
}

// Decode <--
func (m *TLHelpGetPassportConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc661ad08: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetSupportName <--
type TLHelpGetSupportName struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetSupportName) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetSupportName) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd360e72c: func() error {
			x.PutClazzID(0xd360e72c)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getSupportName, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getSupportName, layer)
	}
}

// Decode <--
func (m *TLHelpGetSupportName) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd360e72c: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetUserInfo <--
type TLHelpGetUserInfo struct {
	ClazzID uint32     `json:"_id"`
	UserId  *InputUser `json:"user_id"`
}

func (m *TLHelpGetUserInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetUserInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x38a08d3: func() error {
			x.PutClazzID(0x38a08d3)

			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getUserInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getUserInfo, layer)
	}
}

// Decode <--
func (m *TLHelpGetUserInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x38a08d3: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.UserId = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpEditUserInfo <--
type TLHelpEditUserInfo struct {
	ClazzID  uint32           `json:"_id"`
	UserId   *InputUser       `json:"user_id"`
	Message  string           `json:"message"`
	Entities []*MessageEntity `json:"entities"`
}

func (m *TLHelpEditUserInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpEditUserInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x66b91b70: func() error {
			x.PutClazzID(0x66b91b70)

			_ = m.UserId.Encode(x, layer)
			x.PutString(m.Message)

			_ = iface.EncodeObjectList(x, m.Entities, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_editUserInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_editUserInfo, layer)
	}
}

// Decode <--
func (m *TLHelpEditUserInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x66b91b70: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.UserId = m1

			m.Message, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			v3 := make([]*MessageEntity, l3)
			for i := 0; i < l3; i++ {
				vv := new(MessageEntity)
				err3 = vv.Decode(d)
				_ = err3
				v3[i] = vv
			}
			m.Entities = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetPromoData <--
type TLHelpGetPromoData struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetPromoData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetPromoData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc0977421: func() error {
			x.PutClazzID(0xc0977421)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getPromoData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getPromoData, layer)
	}
}

// Decode <--
func (m *TLHelpGetPromoData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc0977421: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpHidePromoData <--
type TLHelpHidePromoData struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLHelpHidePromoData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpHidePromoData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1e251c95: func() error {
			x.PutClazzID(0x1e251c95)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_hidePromoData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_hidePromoData, layer)
	}
}

// Decode <--
func (m *TLHelpHidePromoData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1e251c95: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpDismissSuggestion <--
type TLHelpDismissSuggestion struct {
	ClazzID    uint32     `json:"_id"`
	Peer       *InputPeer `json:"peer"`
	Suggestion string     `json:"suggestion"`
}

func (m *TLHelpDismissSuggestion) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpDismissSuggestion) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf50dbaa1: func() error {
			x.PutClazzID(0xf50dbaa1)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Suggestion)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_dismissSuggestion, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_dismissSuggestion, layer)
	}
}

// Decode <--
func (m *TLHelpDismissSuggestion) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf50dbaa1: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Suggestion, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetCountriesList <--
type TLHelpGetCountriesList struct {
	ClazzID  uint32 `json:"_id"`
	LangCode string `json:"lang_code"`
	Hash     int32  `json:"hash"`
}

func (m *TLHelpGetCountriesList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetCountriesList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x735787a8: func() error {
			x.PutClazzID(0x735787a8)

			x.PutString(m.LangCode)
			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getCountriesList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getCountriesList, layer)
	}
}

// Decode <--
func (m *TLHelpGetCountriesList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x735787a8: func() (err error) {
			m.LangCode, err = d.String()
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetPremiumPromo <--
type TLHelpGetPremiumPromo struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLHelpGetPremiumPromo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetPremiumPromo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb81b93d4: func() error {
			x.PutClazzID(0xb81b93d4)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getPremiumPromo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getPremiumPromo, layer)
	}
}

// Decode <--
func (m *TLHelpGetPremiumPromo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb81b93d4: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetPeerColors <--
type TLHelpGetPeerColors struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLHelpGetPeerColors) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetPeerColors) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xda80f42f: func() error {
			x.PutClazzID(0xda80f42f)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getPeerColors, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getPeerColors, layer)
	}
}

// Decode <--
func (m *TLHelpGetPeerColors) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xda80f42f: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetPeerProfileColors <--
type TLHelpGetPeerProfileColors struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLHelpGetPeerProfileColors) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetPeerProfileColors) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xabcfa9fd: func() error {
			x.PutClazzID(0xabcfa9fd)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getPeerProfileColors, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getPeerProfileColors, layer)
	}
}

// Decode <--
func (m *TLHelpGetPeerProfileColors) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xabcfa9fd: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLHelpGetTimezonesList <--
type TLHelpGetTimezonesList struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLHelpGetTimezonesList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLHelpGetTimezonesList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x49b30240: func() error {
			x.PutClazzID(0x49b30240)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_help_getTimezonesList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_help_getTimezonesList, layer)
	}
}

// Decode <--
func (m *TLHelpGetTimezonesList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x49b30240: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReadHistory <--
type TLChannelsReadHistory struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	MaxId   int32         `json:"max_id"`
}

func (m *TLChannelsReadHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReadHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcc104937: func() error {
			x.PutClazzID(0xcc104937)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_readHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_readHistory, layer)
	}
}

// Decode <--
func (m *TLChannelsReadHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcc104937: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeleteMessages <--
type TLChannelsDeleteMessages struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Id      []int32       `json:"id"`
}

func (m *TLChannelsDeleteMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeleteMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x84c1fd4e: func() error {
			x.PutClazzID(0x84c1fd4e)

			_ = m.Channel.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deleteMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deleteMessages, layer)
	}
}

// Decode <--
func (m *TLChannelsDeleteMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x84c1fd4e: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReportSpam <--
type TLChannelsReportSpam struct {
	ClazzID     uint32        `json:"_id"`
	Channel     *InputChannel `json:"channel"`
	Participant *InputPeer    `json:"participant"`
	Id          []int32       `json:"id"`
}

func (m *TLChannelsReportSpam) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReportSpam) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf44a8315: func() error {
			x.PutClazzID(0xf44a8315)

			_ = m.Channel.Encode(x, layer)
			_ = m.Participant.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_reportSpam, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_reportSpam, layer)
	}
}

// Decode <--
func (m *TLChannelsReportSpam) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf44a8315: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Participant = m2

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetMessages <--
type TLChannelsGetMessages struct {
	ClazzID               uint32          `json:"_id"`
	Channel               *InputChannel   `json:"channel"`
	Id_VECTORINPUTMESSAGE []*InputMessage `json:"id_VECTORINPUTMESSAGE"`
	Id_VECTORINT32        []int32         `json:"id_VECTORINT32"`
}

func (m *TLChannelsGetMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xad8c9a23: func() error {
			x.PutClazzID(0xad8c9a23)

			_ = m.Channel.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Id_VECTORINPUTMESSAGE, layer)

			return nil
		},
		0x93d7b347: func() error {
			x.PutClazzID(0x93d7b347)

			_ = m.Channel.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id_VECTORINT32)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getMessages, layer)
	}
}

// Decode <--
func (m *TLChannelsGetMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xad8c9a23: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputMessage, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputMessage)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Id_VECTORINPUTMESSAGE = v2

			return nil
		},
		0x93d7b347: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Id_VECTORINT32, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetParticipants <--
type TLChannelsGetParticipants struct {
	ClazzID uint32                     `json:"_id"`
	Channel *InputChannel              `json:"channel"`
	Filter  *ChannelParticipantsFilter `json:"filter"`
	Offset  int32                      `json:"offset"`
	Limit   int32                      `json:"limit"`
	Hash    int64                      `json:"hash"`
}

func (m *TLChannelsGetParticipants) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetParticipants) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x77ced9d0: func() error {
			x.PutClazzID(0x77ced9d0)

			_ = m.Channel.Encode(x, layer)
			_ = m.Filter.Encode(x, layer)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)
			x.PutInt64(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getParticipants, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getParticipants, layer)
	}
}

// Decode <--
func (m *TLChannelsGetParticipants) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x77ced9d0: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &ChannelParticipantsFilter{}
			_ = m2.Decode(d)
			m.Filter = m2

			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()
			m.Hash, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetParticipant <--
type TLChannelsGetParticipant struct {
	ClazzID     uint32        `json:"_id"`
	Channel     *InputChannel `json:"channel"`
	Participant *InputPeer    `json:"participant"`
}

func (m *TLChannelsGetParticipant) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetParticipant) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa0ab6cc6: func() error {
			x.PutClazzID(0xa0ab6cc6)

			_ = m.Channel.Encode(x, layer)
			_ = m.Participant.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getParticipant, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getParticipant, layer)
	}
}

// Decode <--
func (m *TLChannelsGetParticipant) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa0ab6cc6: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Participant = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetChannels <--
type TLChannelsGetChannels struct {
	ClazzID uint32          `json:"_id"`
	Id      []*InputChannel `json:"id"`
}

func (m *TLChannelsGetChannels) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetChannels) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa7f6bbb: func() error {
			x.PutClazzID(0xa7f6bbb)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getChannels, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getChannels, layer)
	}
}

// Decode <--
func (m *TLChannelsGetChannels) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa7f6bbb: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputChannel, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputChannel)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetFullChannel <--
type TLChannelsGetFullChannel struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
}

func (m *TLChannelsGetFullChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetFullChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8736a09: func() error {
			x.PutClazzID(0x8736a09)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getFullChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getFullChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsGetFullChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8736a09: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsCreateChannel <--
type TLChannelsCreateChannel struct {
	ClazzID   uint32         `json:"_id"`
	Broadcast bool           `json:"broadcast"`
	Megagroup bool           `json:"megagroup"`
	ForImport bool           `json:"for_import"`
	Forum     bool           `json:"forum"`
	Title     string         `json:"title"`
	About     string         `json:"about"`
	GeoPoint  *InputGeoPoint `json:"geo_point"`
	Address   *string        `json:"address"`
	TtlPeriod *int32         `json:"ttl_period"`
}

func (m *TLChannelsCreateChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsCreateChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x91006707: func() error {
			x.PutClazzID(0x91006707)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Broadcast == true {
					flags |= 1 << 0
				}
				if m.Megagroup == true {
					flags |= 1 << 1
				}
				if m.ForImport == true {
					flags |= 1 << 3
				}
				if m.Forum == true {
					flags |= 1 << 5
				}

				if m.GeoPoint != nil {
					flags |= 1 << 2
				}
				if m.Address != nil {
					flags |= 1 << 2
				}
				if m.TtlPeriod != nil {
					flags |= 1 << 4
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Title)
			x.PutString(m.About)
			if m.GeoPoint != nil {
				_ = m.GeoPoint.Encode(x, layer)
			}

			if m.Address != nil {
				x.PutString(*m.Address)
			}

			if m.TtlPeriod != nil {
				x.PutInt32(*m.TtlPeriod)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_createChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_createChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsCreateChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x91006707: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Broadcast = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Megagroup = true
			}
			if (flags & (1 << 3)) != 0 {
				m.ForImport = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Forum = true
			}
			m.Title, err = d.String()
			m.About, err = d.String()
			if (flags & (1 << 2)) != 0 {
				m8 := &InputGeoPoint{}
				_ = m8.Decode(d)
				m.GeoPoint = m8
			}
			if (flags & (1 << 2)) != 0 {
				m.Address = new(string)
				*m.Address, err = d.String()
			}

			if (flags & (1 << 4)) != 0 {
				m.TtlPeriod = new(int32)
				*m.TtlPeriod, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditAdmin <--
type TLChannelsEditAdmin struct {
	ClazzID     uint32           `json:"_id"`
	Channel     *InputChannel    `json:"channel"`
	UserId      *InputUser       `json:"user_id"`
	AdminRights *ChatAdminRights `json:"admin_rights"`
	Rank        string           `json:"rank"`
}

func (m *TLChannelsEditAdmin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditAdmin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd33c8902: func() error {
			x.PutClazzID(0xd33c8902)

			_ = m.Channel.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)
			_ = m.AdminRights.Encode(x, layer)
			x.PutString(m.Rank)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editAdmin, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editAdmin, layer)
	}
}

// Decode <--
func (m *TLChannelsEditAdmin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd33c8902: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.UserId = m2

			m3 := &ChatAdminRights{}
			_ = m3.Decode(d)
			m.AdminRights = m3

			m.Rank, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditTitle <--
type TLChannelsEditTitle struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Title   string        `json:"title"`
}

func (m *TLChannelsEditTitle) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditTitle) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x566decd0: func() error {
			x.PutClazzID(0x566decd0)

			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Title)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editTitle, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editTitle, layer)
	}
}

// Decode <--
func (m *TLChannelsEditTitle) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x566decd0: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Title, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditPhoto <--
type TLChannelsEditPhoto struct {
	ClazzID uint32          `json:"_id"`
	Channel *InputChannel   `json:"channel"`
	Photo   *InputChatPhoto `json:"photo"`
}

func (m *TLChannelsEditPhoto) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditPhoto) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf12e57c9: func() error {
			x.PutClazzID(0xf12e57c9)

			_ = m.Channel.Encode(x, layer)
			_ = m.Photo.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editPhoto, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editPhoto, layer)
	}
}

// Decode <--
func (m *TLChannelsEditPhoto) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf12e57c9: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &InputChatPhoto{}
			_ = m2.Decode(d)
			m.Photo = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsCheckUsername <--
type TLChannelsCheckUsername struct {
	ClazzID  uint32        `json:"_id"`
	Channel  *InputChannel `json:"channel"`
	Username string        `json:"username"`
}

func (m *TLChannelsCheckUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsCheckUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x10e6bd2c: func() error {
			x.PutClazzID(0x10e6bd2c)

			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Username)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_checkUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_checkUsername, layer)
	}
}

// Decode <--
func (m *TLChannelsCheckUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x10e6bd2c: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Username, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsUpdateUsername <--
type TLChannelsUpdateUsername struct {
	ClazzID  uint32        `json:"_id"`
	Channel  *InputChannel `json:"channel"`
	Username string        `json:"username"`
}

func (m *TLChannelsUpdateUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsUpdateUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3514b3de: func() error {
			x.PutClazzID(0x3514b3de)

			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Username)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_updateUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_updateUsername, layer)
	}
}

// Decode <--
func (m *TLChannelsUpdateUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3514b3de: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Username, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsJoinChannel <--
type TLChannelsJoinChannel struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
}

func (m *TLChannelsJoinChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsJoinChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x24b524c5: func() error {
			x.PutClazzID(0x24b524c5)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_joinChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_joinChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsJoinChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x24b524c5: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsLeaveChannel <--
type TLChannelsLeaveChannel struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
}

func (m *TLChannelsLeaveChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsLeaveChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf836aa95: func() error {
			x.PutClazzID(0xf836aa95)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_leaveChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_leaveChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsLeaveChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf836aa95: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsInviteToChannel <--
type TLChannelsInviteToChannel struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Users   []*InputUser  `json:"users"`
}

func (m *TLChannelsInviteToChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsInviteToChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc9e33d54: func() error {
			x.PutClazzID(0xc9e33d54)

			_ = m.Channel.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Users, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_inviteToChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_inviteToChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsInviteToChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc9e33d54: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputUser, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputUser)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Users = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeleteChannel <--
type TLChannelsDeleteChannel struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
}

func (m *TLChannelsDeleteChannel) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeleteChannel) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc0111fe3: func() error {
			x.PutClazzID(0xc0111fe3)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deleteChannel, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deleteChannel, layer)
	}
}

// Decode <--
func (m *TLChannelsDeleteChannel) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc0111fe3: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsExportMessageLink <--
type TLChannelsExportMessageLink struct {
	ClazzID uint32        `json:"_id"`
	Grouped bool          `json:"grouped"`
	Thread  bool          `json:"thread"`
	Channel *InputChannel `json:"channel"`
	Id      int32         `json:"id"`
}

func (m *TLChannelsExportMessageLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsExportMessageLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe63fadeb: func() error {
			x.PutClazzID(0xe63fadeb)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Grouped == true {
					flags |= 1 << 0
				}
				if m.Thread == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_exportMessageLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_exportMessageLink, layer)
	}
}

// Decode <--
func (m *TLChannelsExportMessageLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe63fadeb: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Grouped = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Thread = true
			}

			m4 := &InputChannel{}
			_ = m4.Decode(d)
			m.Channel = m4

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleSignatures <--
type TLChannelsToggleSignatures struct {
	ClazzID           uint32        `json:"_id"`
	SignaturesEnabled bool          `json:"signatures_enabled"`
	ProfilesEnabled   bool          `json:"profiles_enabled"`
	Channel           *InputChannel `json:"channel"`
}

func (m *TLChannelsToggleSignatures) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleSignatures) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x418d549c: func() error {
			x.PutClazzID(0x418d549c)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.SignaturesEnabled == true {
					flags |= 1 << 0
				}
				if m.ProfilesEnabled == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleSignatures, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleSignatures, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleSignatures) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x418d549c: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.SignaturesEnabled = true
			}
			if (flags & (1 << 1)) != 0 {
				m.ProfilesEnabled = true
			}

			m4 := &InputChannel{}
			_ = m4.Decode(d)
			m.Channel = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetAdminedPublicChannels <--
type TLChannelsGetAdminedPublicChannels struct {
	ClazzID     uint32 `json:"_id"`
	ByLocation  bool   `json:"by_location"`
	CheckLimit  bool   `json:"check_limit"`
	ForPersonal bool   `json:"for_personal"`
}

func (m *TLChannelsGetAdminedPublicChannels) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetAdminedPublicChannels) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf8b036af: func() error {
			x.PutClazzID(0xf8b036af)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ByLocation == true {
					flags |= 1 << 0
				}
				if m.CheckLimit == true {
					flags |= 1 << 1
				}
				if m.ForPersonal == true {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getAdminedPublicChannels, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getAdminedPublicChannels, layer)
	}
}

// Decode <--
func (m *TLChannelsGetAdminedPublicChannels) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf8b036af: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ByLocation = true
			}
			if (flags & (1 << 1)) != 0 {
				m.CheckLimit = true
			}
			if (flags & (1 << 2)) != 0 {
				m.ForPersonal = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditBanned <--
type TLChannelsEditBanned struct {
	ClazzID      uint32            `json:"_id"`
	Channel      *InputChannel     `json:"channel"`
	Participant  *InputPeer        `json:"participant"`
	BannedRights *ChatBannedRights `json:"banned_rights"`
}

func (m *TLChannelsEditBanned) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditBanned) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x96e6cd81: func() error {
			x.PutClazzID(0x96e6cd81)

			_ = m.Channel.Encode(x, layer)
			_ = m.Participant.Encode(x, layer)
			_ = m.BannedRights.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editBanned, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editBanned, layer)
	}
}

// Decode <--
func (m *TLChannelsEditBanned) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x96e6cd81: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Participant = m2

			m3 := &ChatBannedRights{}
			_ = m3.Decode(d)
			m.BannedRights = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetAdminLog <--
type TLChannelsGetAdminLog struct {
	ClazzID      uint32                       `json:"_id"`
	Channel      *InputChannel                `json:"channel"`
	Q            string                       `json:"q"`
	EventsFilter *ChannelAdminLogEventsFilter `json:"events_filter"`
	Admins       []*InputUser                 `json:"admins"`
	MaxId        int64                        `json:"max_id"`
	MinId        int64                        `json:"min_id"`
	Limit        int32                        `json:"limit"`
}

func (m *TLChannelsGetAdminLog) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetAdminLog) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x33ddf480: func() error {
			x.PutClazzID(0x33ddf480)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.EventsFilter != nil {
					flags |= 1 << 0
				}
				if m.Admins != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Q)
			if m.EventsFilter != nil {
				_ = m.EventsFilter.Encode(x, layer)
			}

			if m.Admins != nil {
				_ = iface.EncodeObjectList(x, m.Admins, layer)
			}
			x.PutInt64(m.MaxId)
			x.PutInt64(m.MinId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getAdminLog, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getAdminLog, layer)
	}
}

// Decode <--
func (m *TLChannelsGetAdminLog) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x33ddf480: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputChannel{}
			_ = m2.Decode(d)
			m.Channel = m2

			m.Q, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m4 := &ChannelAdminLogEventsFilter{}
				_ = m4.Decode(d)
				m.EventsFilter = m4
			}
			if (flags & (1 << 1)) != 0 {
				c5, err2 := d.ClazzID()
				if c5 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
					return err2
				}
				l5, err3 := d.Int()
				v5 := make([]*InputUser, l5)
				for i := 0; i < l5; i++ {
					vv := new(InputUser)
					err3 = vv.Decode(d)
					_ = err3
					v5[i] = vv
				}
				m.Admins = v5
			}
			m.MaxId, err = d.Int64()
			m.MinId, err = d.Int64()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSetStickers <--
type TLChannelsSetStickers struct {
	ClazzID    uint32           `json:"_id"`
	Channel    *InputChannel    `json:"channel"`
	Stickerset *InputStickerSet `json:"stickerset"`
}

func (m *TLChannelsSetStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSetStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xea8ca4f9: func() error {
			x.PutClazzID(0xea8ca4f9)

			_ = m.Channel.Encode(x, layer)
			_ = m.Stickerset.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_setStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_setStickers, layer)
	}
}

// Decode <--
func (m *TLChannelsSetStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xea8ca4f9: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &InputStickerSet{}
			_ = m2.Decode(d)
			m.Stickerset = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReadMessageContents <--
type TLChannelsReadMessageContents struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Id      []int32       `json:"id"`
}

func (m *TLChannelsReadMessageContents) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReadMessageContents) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xeab5dc38: func() error {
			x.PutClazzID(0xeab5dc38)

			_ = m.Channel.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_readMessageContents, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_readMessageContents, layer)
	}
}

// Decode <--
func (m *TLChannelsReadMessageContents) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xeab5dc38: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeleteHistory <--
type TLChannelsDeleteHistory struct {
	ClazzID     uint32        `json:"_id"`
	ForEveryone bool          `json:"for_everyone"`
	Channel     *InputChannel `json:"channel"`
	MaxId       int32         `json:"max_id"`
}

func (m *TLChannelsDeleteHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeleteHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9baa9647: func() error {
			x.PutClazzID(0x9baa9647)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForEveryone == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deleteHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deleteHistory, layer)
	}
}

// Decode <--
func (m *TLChannelsDeleteHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9baa9647: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ForEveryone = true
			}

			m3 := &InputChannel{}
			_ = m3.Decode(d)
			m.Channel = m3

			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsTogglePreHistoryHidden <--
type TLChannelsTogglePreHistoryHidden struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Enabled *Bool         `json:"enabled"`
}

func (m *TLChannelsTogglePreHistoryHidden) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsTogglePreHistoryHidden) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xeabbb94c: func() error {
			x.PutClazzID(0xeabbb94c)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_togglePreHistoryHidden, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_togglePreHistoryHidden, layer)
	}
}

// Decode <--
func (m *TLChannelsTogglePreHistoryHidden) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xeabbb94c: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Enabled = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetLeftChannels <--
type TLChannelsGetLeftChannels struct {
	ClazzID uint32 `json:"_id"`
	Offset  int32  `json:"offset"`
}

func (m *TLChannelsGetLeftChannels) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetLeftChannels) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8341ecc0: func() error {
			x.PutClazzID(0x8341ecc0)

			x.PutInt32(m.Offset)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getLeftChannels, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getLeftChannels, layer)
	}
}

// Decode <--
func (m *TLChannelsGetLeftChannels) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8341ecc0: func() (err error) {
			m.Offset, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetGroupsForDiscussion <--
type TLChannelsGetGroupsForDiscussion struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLChannelsGetGroupsForDiscussion) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetGroupsForDiscussion) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf5dad378: func() error {
			x.PutClazzID(0xf5dad378)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getGroupsForDiscussion, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getGroupsForDiscussion, layer)
	}
}

// Decode <--
func (m *TLChannelsGetGroupsForDiscussion) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf5dad378: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSetDiscussionGroup <--
type TLChannelsSetDiscussionGroup struct {
	ClazzID   uint32        `json:"_id"`
	Broadcast *InputChannel `json:"broadcast"`
	Group     *InputChannel `json:"group"`
}

func (m *TLChannelsSetDiscussionGroup) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSetDiscussionGroup) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x40582bb2: func() error {
			x.PutClazzID(0x40582bb2)

			_ = m.Broadcast.Encode(x, layer)
			_ = m.Group.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_setDiscussionGroup, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_setDiscussionGroup, layer)
	}
}

// Decode <--
func (m *TLChannelsSetDiscussionGroup) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x40582bb2: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Broadcast = m1

			m2 := &InputChannel{}
			_ = m2.Decode(d)
			m.Group = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditCreator <--
type TLChannelsEditCreator struct {
	ClazzID  uint32                 `json:"_id"`
	Channel  *InputChannel          `json:"channel"`
	UserId   *InputUser             `json:"user_id"`
	Password *InputCheckPasswordSRP `json:"password"`
}

func (m *TLChannelsEditCreator) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditCreator) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8f38cd1f: func() error {
			x.PutClazzID(0x8f38cd1f)

			_ = m.Channel.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)
			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editCreator, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editCreator, layer)
	}
}

// Decode <--
func (m *TLChannelsEditCreator) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8f38cd1f: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.UserId = m2

			m3 := &InputCheckPasswordSRP{}
			_ = m3.Decode(d)
			m.Password = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditLocation <--
type TLChannelsEditLocation struct {
	ClazzID  uint32         `json:"_id"`
	Channel  *InputChannel  `json:"channel"`
	GeoPoint *InputGeoPoint `json:"geo_point"`
	Address  string         `json:"address"`
}

func (m *TLChannelsEditLocation) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditLocation) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x58e63f6d: func() error {
			x.PutClazzID(0x58e63f6d)

			_ = m.Channel.Encode(x, layer)
			_ = m.GeoPoint.Encode(x, layer)
			x.PutString(m.Address)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editLocation, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editLocation, layer)
	}
}

// Decode <--
func (m *TLChannelsEditLocation) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x58e63f6d: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &InputGeoPoint{}
			_ = m2.Decode(d)
			m.GeoPoint = m2

			m.Address, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleSlowMode <--
type TLChannelsToggleSlowMode struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Seconds int32         `json:"seconds"`
}

func (m *TLChannelsToggleSlowMode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleSlowMode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xedd49ef0: func() error {
			x.PutClazzID(0xedd49ef0)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.Seconds)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleSlowMode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleSlowMode, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleSlowMode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xedd49ef0: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Seconds, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetInactiveChannels <--
type TLChannelsGetInactiveChannels struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLChannelsGetInactiveChannels) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetInactiveChannels) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x11e831ee: func() error {
			x.PutClazzID(0x11e831ee)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getInactiveChannels, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getInactiveChannels, layer)
	}
}

// Decode <--
func (m *TLChannelsGetInactiveChannels) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x11e831ee: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsConvertToGigagroup <--
type TLChannelsConvertToGigagroup struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
}

func (m *TLChannelsConvertToGigagroup) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsConvertToGigagroup) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb290c69: func() error {
			x.PutClazzID(0xb290c69)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_convertToGigagroup, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_convertToGigagroup, layer)
	}
}

// Decode <--
func (m *TLChannelsConvertToGigagroup) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb290c69: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetSendAs <--
type TLChannelsGetSendAs struct {
	ClazzID          uint32     `json:"_id"`
	ForPaidReactions bool       `json:"for_paid_reactions"`
	Peer             *InputPeer `json:"peer"`
}

func (m *TLChannelsGetSendAs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetSendAs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe785a43f: func() error {
			x.PutClazzID(0xe785a43f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForPaidReactions == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getSendAs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getSendAs, layer)
	}
}

// Decode <--
func (m *TLChannelsGetSendAs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe785a43f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ForPaidReactions = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeleteParticipantHistory <--
type TLChannelsDeleteParticipantHistory struct {
	ClazzID     uint32        `json:"_id"`
	Channel     *InputChannel `json:"channel"`
	Participant *InputPeer    `json:"participant"`
}

func (m *TLChannelsDeleteParticipantHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeleteParticipantHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x367544db: func() error {
			x.PutClazzID(0x367544db)

			_ = m.Channel.Encode(x, layer)
			_ = m.Participant.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deleteParticipantHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deleteParticipantHistory, layer)
	}
}

// Decode <--
func (m *TLChannelsDeleteParticipantHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x367544db: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Participant = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleJoinToSend <--
type TLChannelsToggleJoinToSend struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Enabled *Bool         `json:"enabled"`
}

func (m *TLChannelsToggleJoinToSend) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleJoinToSend) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe4cb9580: func() error {
			x.PutClazzID(0xe4cb9580)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleJoinToSend, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleJoinToSend, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleJoinToSend) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe4cb9580: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Enabled = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleJoinRequest <--
type TLChannelsToggleJoinRequest struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Enabled *Bool         `json:"enabled"`
}

func (m *TLChannelsToggleJoinRequest) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleJoinRequest) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4c2985b6: func() error {
			x.PutClazzID(0x4c2985b6)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleJoinRequest, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleJoinRequest, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleJoinRequest) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4c2985b6: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Enabled = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReorderUsernames <--
type TLChannelsReorderUsernames struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Order   []string      `json:"order"`
}

func (m *TLChannelsReorderUsernames) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReorderUsernames) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb45ced1d: func() error {
			x.PutClazzID(0xb45ced1d)

			_ = m.Channel.Encode(x, layer)

			iface.EncodeStringList(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_reorderUsernames, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_reorderUsernames, layer)
	}
}

// Decode <--
func (m *TLChannelsReorderUsernames) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb45ced1d: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Order, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleUsername <--
type TLChannelsToggleUsername struct {
	ClazzID  uint32        `json:"_id"`
	Channel  *InputChannel `json:"channel"`
	Username string        `json:"username"`
	Active   *Bool         `json:"active"`
}

func (m *TLChannelsToggleUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x50f24105: func() error {
			x.PutClazzID(0x50f24105)

			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Username)
			_ = m.Active.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleUsername, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x50f24105: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Username, err = d.String()

			m3 := &Bool{}
			_ = m3.Decode(d)
			m.Active = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeactivateAllUsernames <--
type TLChannelsDeactivateAllUsernames struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
}

func (m *TLChannelsDeactivateAllUsernames) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeactivateAllUsernames) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa245dd3: func() error {
			x.PutClazzID(0xa245dd3)

			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deactivateAllUsernames, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deactivateAllUsernames, layer)
	}
}

// Decode <--
func (m *TLChannelsDeactivateAllUsernames) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa245dd3: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleForum <--
type TLChannelsToggleForum struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Enabled *Bool         `json:"enabled"`
}

func (m *TLChannelsToggleForum) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleForum) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa4298b29: func() error {
			x.PutClazzID(0xa4298b29)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleForum, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleForum, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleForum) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa4298b29: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Enabled = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsCreateForumTopic <--
type TLChannelsCreateForumTopic struct {
	ClazzID     uint32        `json:"_id"`
	Channel     *InputChannel `json:"channel"`
	Title       string        `json:"title"`
	IconColor   *int32        `json:"icon_color"`
	IconEmojiId *int64        `json:"icon_emoji_id"`
	RandomId    int64         `json:"random_id"`
	SendAs      *InputPeer    `json:"send_as"`
}

func (m *TLChannelsCreateForumTopic) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsCreateForumTopic) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf40c0224: func() error {
			x.PutClazzID(0xf40c0224)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.IconColor != nil {
					flags |= 1 << 0
				}
				if m.IconEmojiId != nil {
					flags |= 1 << 3
				}

				if m.SendAs != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutString(m.Title)
			if m.IconColor != nil {
				x.PutInt32(*m.IconColor)
			}

			if m.IconEmojiId != nil {
				x.PutInt64(*m.IconEmojiId)
			}

			x.PutInt64(m.RandomId)
			if m.SendAs != nil {
				_ = m.SendAs.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_createForumTopic, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_createForumTopic, layer)
	}
}

// Decode <--
func (m *TLChannelsCreateForumTopic) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf40c0224: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputChannel{}
			_ = m2.Decode(d)
			m.Channel = m2

			m.Title, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.IconColor = new(int32)
				*m.IconColor, err = d.Int32()
			}
			if (flags & (1 << 3)) != 0 {
				m.IconEmojiId = new(int64)
				*m.IconEmojiId, err = d.Int64()
			}

			m.RandomId, err = d.Int64()
			if (flags & (1 << 2)) != 0 {
				m7 := &InputPeer{}
				_ = m7.Decode(d)
				m.SendAs = m7
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetForumTopics <--
type TLChannelsGetForumTopics struct {
	ClazzID     uint32        `json:"_id"`
	Channel     *InputChannel `json:"channel"`
	Q           *string       `json:"q"`
	OffsetDate  int32         `json:"offset_date"`
	OffsetId    int32         `json:"offset_id"`
	OffsetTopic int32         `json:"offset_topic"`
	Limit       int32         `json:"limit"`
}

func (m *TLChannelsGetForumTopics) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetForumTopics) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xde560d1: func() error {
			x.PutClazzID(0xde560d1)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Q != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			if m.Q != nil {
				x.PutString(*m.Q)
			}

			x.PutInt32(m.OffsetDate)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.OffsetTopic)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getForumTopics, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getForumTopics, layer)
	}
}

// Decode <--
func (m *TLChannelsGetForumTopics) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xde560d1: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputChannel{}
			_ = m2.Decode(d)
			m.Channel = m2

			if (flags & (1 << 0)) != 0 {
				m.Q = new(string)
				*m.Q, err = d.String()
			}

			m.OffsetDate, err = d.Int32()
			m.OffsetId, err = d.Int32()
			m.OffsetTopic, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetForumTopicsByID <--
type TLChannelsGetForumTopicsByID struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Topics  []int32       `json:"topics"`
}

func (m *TLChannelsGetForumTopicsByID) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetForumTopicsByID) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb0831eb9: func() error {
			x.PutClazzID(0xb0831eb9)

			_ = m.Channel.Encode(x, layer)

			iface.EncodeInt32List(x, m.Topics)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getForumTopicsByID, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getForumTopicsByID, layer)
	}
}

// Decode <--
func (m *TLChannelsGetForumTopicsByID) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb0831eb9: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Topics, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsEditForumTopic <--
type TLChannelsEditForumTopic struct {
	ClazzID     uint32        `json:"_id"`
	Channel     *InputChannel `json:"channel"`
	TopicId     int32         `json:"topic_id"`
	Title       *string       `json:"title"`
	IconEmojiId *int64        `json:"icon_emoji_id"`
	Closed      *Bool         `json:"closed"`
	Hidden      *Bool         `json:"hidden"`
}

func (m *TLChannelsEditForumTopic) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsEditForumTopic) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf4dfa185: func() error {
			x.PutClazzID(0xf4dfa185)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Title != nil {
					flags |= 1 << 0
				}
				if m.IconEmojiId != nil {
					flags |= 1 << 1
				}
				if m.Closed != nil {
					flags |= 1 << 2
				}
				if m.Hidden != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.TopicId)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.IconEmojiId != nil {
				x.PutInt64(*m.IconEmojiId)
			}

			if m.Closed != nil {
				_ = m.Closed.Encode(x, layer)
			}

			if m.Hidden != nil {
				_ = m.Hidden.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_editForumTopic, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_editForumTopic, layer)
	}
}

// Decode <--
func (m *TLChannelsEditForumTopic) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf4dfa185: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputChannel{}
			_ = m2.Decode(d)
			m.Channel = m2

			m.TopicId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.IconEmojiId = new(int64)
				*m.IconEmojiId, err = d.Int64()
			}

			if (flags & (1 << 2)) != 0 {
				m6 := &Bool{}
				_ = m6.Decode(d)
				m.Closed = m6
			}
			if (flags & (1 << 3)) != 0 {
				m7 := &Bool{}
				_ = m7.Decode(d)
				m.Hidden = m7
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsUpdatePinnedForumTopic <--
type TLChannelsUpdatePinnedForumTopic struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	TopicId int32         `json:"topic_id"`
	Pinned  *Bool         `json:"pinned"`
}

func (m *TLChannelsUpdatePinnedForumTopic) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsUpdatePinnedForumTopic) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6c2d9026: func() error {
			x.PutClazzID(0x6c2d9026)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.TopicId)
			_ = m.Pinned.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_updatePinnedForumTopic, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_updatePinnedForumTopic, layer)
	}
}

// Decode <--
func (m *TLChannelsUpdatePinnedForumTopic) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6c2d9026: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.TopicId, err = d.Int32()

			m3 := &Bool{}
			_ = m3.Decode(d)
			m.Pinned = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsDeleteTopicHistory <--
type TLChannelsDeleteTopicHistory struct {
	ClazzID  uint32        `json:"_id"`
	Channel  *InputChannel `json:"channel"`
	TopMsgId int32         `json:"top_msg_id"`
}

func (m *TLChannelsDeleteTopicHistory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsDeleteTopicHistory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x34435f2d: func() error {
			x.PutClazzID(0x34435f2d)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.TopMsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_deleteTopicHistory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_deleteTopicHistory, layer)
	}
}

// Decode <--
func (m *TLChannelsDeleteTopicHistory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x34435f2d: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.TopMsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReorderPinnedForumTopics <--
type TLChannelsReorderPinnedForumTopics struct {
	ClazzID uint32        `json:"_id"`
	Force   bool          `json:"force"`
	Channel *InputChannel `json:"channel"`
	Order   []int32       `json:"order"`
}

func (m *TLChannelsReorderPinnedForumTopics) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReorderPinnedForumTopics) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2950a18f: func() error {
			x.PutClazzID(0x2950a18f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Force == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)

			iface.EncodeInt32List(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_reorderPinnedForumTopics, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_reorderPinnedForumTopics, layer)
	}
}

// Decode <--
func (m *TLChannelsReorderPinnedForumTopics) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2950a18f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Force = true
			}

			m3 := &InputChannel{}
			_ = m3.Decode(d)
			m.Channel = m3

			m.Order, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleAntiSpam <--
type TLChannelsToggleAntiSpam struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Enabled *Bool         `json:"enabled"`
}

func (m *TLChannelsToggleAntiSpam) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleAntiSpam) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x68f3e4eb: func() error {
			x.PutClazzID(0x68f3e4eb)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleAntiSpam, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleAntiSpam, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleAntiSpam) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x68f3e4eb: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Enabled = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsReportAntiSpamFalsePositive <--
type TLChannelsReportAntiSpamFalsePositive struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	MsgId   int32         `json:"msg_id"`
}

func (m *TLChannelsReportAntiSpamFalsePositive) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsReportAntiSpamFalsePositive) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa850a693: func() error {
			x.PutClazzID(0xa850a693)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_reportAntiSpamFalsePositive, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_reportAntiSpamFalsePositive, layer)
	}
}

// Decode <--
func (m *TLChannelsReportAntiSpamFalsePositive) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa850a693: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleParticipantsHidden <--
type TLChannelsToggleParticipantsHidden struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Enabled *Bool         `json:"enabled"`
}

func (m *TLChannelsToggleParticipantsHidden) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleParticipantsHidden) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6a6e7854: func() error {
			x.PutClazzID(0x6a6e7854)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleParticipantsHidden, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleParticipantsHidden, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleParticipantsHidden) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6a6e7854: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Enabled = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsUpdateColor <--
type TLChannelsUpdateColor struct {
	ClazzID           uint32        `json:"_id"`
	ForProfile        bool          `json:"for_profile"`
	Channel           *InputChannel `json:"channel"`
	Color             *int32        `json:"color"`
	BackgroundEmojiId *int64        `json:"background_emoji_id"`
}

func (m *TLChannelsUpdateColor) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsUpdateColor) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd8aa3671: func() error {
			x.PutClazzID(0xd8aa3671)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForProfile == true {
					flags |= 1 << 1
				}

				if m.Color != nil {
					flags |= 1 << 2
				}
				if m.BackgroundEmojiId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			if m.Color != nil {
				x.PutInt32(*m.Color)
			}

			if m.BackgroundEmojiId != nil {
				x.PutInt64(*m.BackgroundEmojiId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_updateColor, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_updateColor, layer)
	}
}

// Decode <--
func (m *TLChannelsUpdateColor) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd8aa3671: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.ForProfile = true
			}

			m3 := &InputChannel{}
			_ = m3.Decode(d)
			m.Channel = m3

			if (flags & (1 << 2)) != 0 {
				m.Color = new(int32)
				*m.Color, err = d.Int32()
			}
			if (flags & (1 << 0)) != 0 {
				m.BackgroundEmojiId = new(int64)
				*m.BackgroundEmojiId, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsToggleViewForumAsMessages <--
type TLChannelsToggleViewForumAsMessages struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Enabled *Bool         `json:"enabled"`
}

func (m *TLChannelsToggleViewForumAsMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsToggleViewForumAsMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9738bb15: func() error {
			x.PutClazzID(0x9738bb15)

			_ = m.Channel.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_toggleViewForumAsMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_toggleViewForumAsMessages, layer)
	}
}

// Decode <--
func (m *TLChannelsToggleViewForumAsMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9738bb15: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Enabled = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsGetChannelRecommendations <--
type TLChannelsGetChannelRecommendations struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
}

func (m *TLChannelsGetChannelRecommendations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsGetChannelRecommendations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x25a71742: func() error {
			x.PutClazzID(0x25a71742)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Channel != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Channel != nil {
				_ = m.Channel.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_getChannelRecommendations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_getChannelRecommendations, layer)
	}
}

// Decode <--
func (m *TLChannelsGetChannelRecommendations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x25a71742: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &InputChannel{}
				_ = m2.Decode(d)
				m.Channel = m2
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsUpdateEmojiStatus <--
type TLChannelsUpdateEmojiStatus struct {
	ClazzID     uint32        `json:"_id"`
	Channel     *InputChannel `json:"channel"`
	EmojiStatus *EmojiStatus  `json:"emoji_status"`
}

func (m *TLChannelsUpdateEmojiStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsUpdateEmojiStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf0d3e6a8: func() error {
			x.PutClazzID(0xf0d3e6a8)

			_ = m.Channel.Encode(x, layer)
			_ = m.EmojiStatus.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_updateEmojiStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_updateEmojiStatus, layer)
	}
}

// Decode <--
func (m *TLChannelsUpdateEmojiStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf0d3e6a8: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &EmojiStatus{}
			_ = m2.Decode(d)
			m.EmojiStatus = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSetBoostsToUnblockRestrictions <--
type TLChannelsSetBoostsToUnblockRestrictions struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	Boosts  int32         `json:"boosts"`
}

func (m *TLChannelsSetBoostsToUnblockRestrictions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSetBoostsToUnblockRestrictions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xad399cee: func() error {
			x.PutClazzID(0xad399cee)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.Boosts)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_setBoostsToUnblockRestrictions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_setBoostsToUnblockRestrictions, layer)
	}
}

// Decode <--
func (m *TLChannelsSetBoostsToUnblockRestrictions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xad399cee: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.Boosts, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSetEmojiStickers <--
type TLChannelsSetEmojiStickers struct {
	ClazzID    uint32           `json:"_id"`
	Channel    *InputChannel    `json:"channel"`
	Stickerset *InputStickerSet `json:"stickerset"`
}

func (m *TLChannelsSetEmojiStickers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSetEmojiStickers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3cd930b7: func() error {
			x.PutClazzID(0x3cd930b7)

			_ = m.Channel.Encode(x, layer)
			_ = m.Stickerset.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_setEmojiStickers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_setEmojiStickers, layer)
	}
}

// Decode <--
func (m *TLChannelsSetEmojiStickers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3cd930b7: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &InputStickerSet{}
			_ = m2.Decode(d)
			m.Stickerset = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsRestrictSponsoredMessages <--
type TLChannelsRestrictSponsoredMessages struct {
	ClazzID    uint32        `json:"_id"`
	Channel    *InputChannel `json:"channel"`
	Restricted *Bool         `json:"restricted"`
}

func (m *TLChannelsRestrictSponsoredMessages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsRestrictSponsoredMessages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9ae91519: func() error {
			x.PutClazzID(0x9ae91519)

			_ = m.Channel.Encode(x, layer)
			_ = m.Restricted.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_restrictSponsoredMessages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_restrictSponsoredMessages, layer)
	}
}

// Decode <--
func (m *TLChannelsRestrictSponsoredMessages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9ae91519: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Restricted = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsSearchPosts <--
type TLChannelsSearchPosts struct {
	ClazzID    uint32     `json:"_id"`
	Hashtag    string     `json:"hashtag"`
	OffsetRate int32      `json:"offset_rate"`
	OffsetPeer *InputPeer `json:"offset_peer"`
	OffsetId   int32      `json:"offset_id"`
	Limit      int32      `json:"limit"`
}

func (m *TLChannelsSearchPosts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsSearchPosts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd19f987b: func() error {
			x.PutClazzID(0xd19f987b)

			x.PutString(m.Hashtag)
			x.PutInt32(m.OffsetRate)
			_ = m.OffsetPeer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_searchPosts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_searchPosts, layer)
	}
}

// Decode <--
func (m *TLChannelsSearchPosts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd19f987b: func() (err error) {
			m.Hashtag, err = d.String()
			m.OffsetRate, err = d.Int32()

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.OffsetPeer = m3

			m.OffsetId, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChannelsUpdatePaidMessagesPrice <--
type TLChannelsUpdatePaidMessagesPrice struct {
	ClazzID               uint32        `json:"_id"`
	Channel               *InputChannel `json:"channel"`
	SendPaidMessagesStars int64         `json:"send_paid_messages_stars"`
}

func (m *TLChannelsUpdatePaidMessagesPrice) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChannelsUpdatePaidMessagesPrice) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfc84653f: func() error {
			x.PutClazzID(0xfc84653f)

			_ = m.Channel.Encode(x, layer)
			x.PutInt64(m.SendPaidMessagesStars)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_channels_updatePaidMessagesPrice, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_channels_updatePaidMessagesPrice, layer)
	}
}

// Decode <--
func (m *TLChannelsUpdatePaidMessagesPrice) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfc84653f: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.SendPaidMessagesStars, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSendCustomRequest <--
type TLBotsSendCustomRequest struct {
	ClazzID      uint32    `json:"_id"`
	CustomMethod string    `json:"custom_method"`
	Params       *DataJSON `json:"params"`
}

func (m *TLBotsSendCustomRequest) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSendCustomRequest) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaa2769ed: func() error {
			x.PutClazzID(0xaa2769ed)

			x.PutString(m.CustomMethod)
			_ = m.Params.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_sendCustomRequest, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_sendCustomRequest, layer)
	}
}

// Decode <--
func (m *TLBotsSendCustomRequest) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaa2769ed: func() (err error) {
			m.CustomMethod, err = d.String()

			m2 := &DataJSON{}
			_ = m2.Decode(d)
			m.Params = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsAnswerWebhookJSONQuery <--
type TLBotsAnswerWebhookJSONQuery struct {
	ClazzID uint32    `json:"_id"`
	QueryId int64     `json:"query_id"`
	Data    *DataJSON `json:"data"`
}

func (m *TLBotsAnswerWebhookJSONQuery) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsAnswerWebhookJSONQuery) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe6213f4d: func() error {
			x.PutClazzID(0xe6213f4d)

			x.PutInt64(m.QueryId)
			_ = m.Data.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_answerWebhookJSONQuery, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_answerWebhookJSONQuery, layer)
	}
}

// Decode <--
func (m *TLBotsAnswerWebhookJSONQuery) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe6213f4d: func() (err error) {
			m.QueryId, err = d.Int64()

			m2 := &DataJSON{}
			_ = m2.Decode(d)
			m.Data = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetBotCommands <--
type TLBotsSetBotCommands struct {
	ClazzID  uint32           `json:"_id"`
	Scope    *BotCommandScope `json:"scope"`
	LangCode string           `json:"lang_code"`
	Commands []*BotCommand    `json:"commands"`
}

func (m *TLBotsSetBotCommands) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetBotCommands) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x517165a: func() error {
			x.PutClazzID(0x517165a)

			_ = m.Scope.Encode(x, layer)
			x.PutString(m.LangCode)

			_ = iface.EncodeObjectList(x, m.Commands, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setBotCommands, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setBotCommands, layer)
	}
}

// Decode <--
func (m *TLBotsSetBotCommands) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x517165a: func() (err error) {

			m1 := &BotCommandScope{}
			_ = m1.Decode(d)
			m.Scope = m1

			m.LangCode, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			v3 := make([]*BotCommand, l3)
			for i := 0; i < l3; i++ {
				vv := new(BotCommand)
				err3 = vv.Decode(d)
				_ = err3
				v3[i] = vv
			}
			m.Commands = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsResetBotCommands <--
type TLBotsResetBotCommands struct {
	ClazzID  uint32           `json:"_id"`
	Scope    *BotCommandScope `json:"scope"`
	LangCode string           `json:"lang_code"`
}

func (m *TLBotsResetBotCommands) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsResetBotCommands) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3d8de0f9: func() error {
			x.PutClazzID(0x3d8de0f9)

			_ = m.Scope.Encode(x, layer)
			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_resetBotCommands, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_resetBotCommands, layer)
	}
}

// Decode <--
func (m *TLBotsResetBotCommands) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3d8de0f9: func() (err error) {

			m1 := &BotCommandScope{}
			_ = m1.Decode(d)
			m.Scope = m1

			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetBotCommands <--
type TLBotsGetBotCommands struct {
	ClazzID  uint32           `json:"_id"`
	Scope    *BotCommandScope `json:"scope"`
	LangCode string           `json:"lang_code"`
}

func (m *TLBotsGetBotCommands) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetBotCommands) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe34c0dd6: func() error {
			x.PutClazzID(0xe34c0dd6)

			_ = m.Scope.Encode(x, layer)
			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getBotCommands, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getBotCommands, layer)
	}
}

// Decode <--
func (m *TLBotsGetBotCommands) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe34c0dd6: func() (err error) {

			m1 := &BotCommandScope{}
			_ = m1.Decode(d)
			m.Scope = m1

			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetBotMenuButton <--
type TLBotsSetBotMenuButton struct {
	ClazzID uint32         `json:"_id"`
	UserId  *InputUser     `json:"user_id"`
	Button  *BotMenuButton `json:"button"`
}

func (m *TLBotsSetBotMenuButton) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetBotMenuButton) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4504d54f: func() error {
			x.PutClazzID(0x4504d54f)

			_ = m.UserId.Encode(x, layer)
			_ = m.Button.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setBotMenuButton, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setBotMenuButton, layer)
	}
}

// Decode <--
func (m *TLBotsSetBotMenuButton) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4504d54f: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.UserId = m1

			m2 := &BotMenuButton{}
			_ = m2.Decode(d)
			m.Button = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetBotMenuButton <--
type TLBotsGetBotMenuButton struct {
	ClazzID uint32     `json:"_id"`
	UserId  *InputUser `json:"user_id"`
}

func (m *TLBotsGetBotMenuButton) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetBotMenuButton) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9c60eb28: func() error {
			x.PutClazzID(0x9c60eb28)

			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getBotMenuButton, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getBotMenuButton, layer)
	}
}

// Decode <--
func (m *TLBotsGetBotMenuButton) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9c60eb28: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.UserId = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetBotBroadcastDefaultAdminRights <--
type TLBotsSetBotBroadcastDefaultAdminRights struct {
	ClazzID     uint32           `json:"_id"`
	AdminRights *ChatAdminRights `json:"admin_rights"`
}

func (m *TLBotsSetBotBroadcastDefaultAdminRights) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetBotBroadcastDefaultAdminRights) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x788464e1: func() error {
			x.PutClazzID(0x788464e1)

			_ = m.AdminRights.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setBotBroadcastDefaultAdminRights, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setBotBroadcastDefaultAdminRights, layer)
	}
}

// Decode <--
func (m *TLBotsSetBotBroadcastDefaultAdminRights) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x788464e1: func() (err error) {

			m1 := &ChatAdminRights{}
			_ = m1.Decode(d)
			m.AdminRights = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetBotGroupDefaultAdminRights <--
type TLBotsSetBotGroupDefaultAdminRights struct {
	ClazzID     uint32           `json:"_id"`
	AdminRights *ChatAdminRights `json:"admin_rights"`
}

func (m *TLBotsSetBotGroupDefaultAdminRights) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetBotGroupDefaultAdminRights) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x925ec9ea: func() error {
			x.PutClazzID(0x925ec9ea)

			_ = m.AdminRights.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setBotGroupDefaultAdminRights, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setBotGroupDefaultAdminRights, layer)
	}
}

// Decode <--
func (m *TLBotsSetBotGroupDefaultAdminRights) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x925ec9ea: func() (err error) {

			m1 := &ChatAdminRights{}
			_ = m1.Decode(d)
			m.AdminRights = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetBotInfo <--
type TLBotsSetBotInfo struct {
	ClazzID     uint32     `json:"_id"`
	Bot         *InputUser `json:"bot"`
	LangCode    string     `json:"lang_code"`
	Name        *string    `json:"name"`
	About       *string    `json:"about"`
	Description *string    `json:"description"`
}

func (m *TLBotsSetBotInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetBotInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x10cf3123: func() error {
			x.PutClazzID(0x10cf3123)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Bot != nil {
					flags |= 1 << 2
				}

				if m.Name != nil {
					flags |= 1 << 3
				}
				if m.About != nil {
					flags |= 1 << 0
				}
				if m.Description != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Bot != nil {
				_ = m.Bot.Encode(x, layer)
			}

			x.PutString(m.LangCode)
			if m.Name != nil {
				x.PutString(*m.Name)
			}

			if m.About != nil {
				x.PutString(*m.About)
			}

			if m.Description != nil {
				x.PutString(*m.Description)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setBotInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setBotInfo, layer)
	}
}

// Decode <--
func (m *TLBotsSetBotInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x10cf3123: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m2 := &InputUser{}
				_ = m2.Decode(d)
				m.Bot = m2
			}
			m.LangCode, err = d.String()
			if (flags & (1 << 3)) != 0 {
				m.Name = new(string)
				*m.Name, err = d.String()
			}

			if (flags & (1 << 0)) != 0 {
				m.About = new(string)
				*m.About, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.Description = new(string)
				*m.Description, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetBotInfo <--
type TLBotsGetBotInfo struct {
	ClazzID  uint32     `json:"_id"`
	Bot      *InputUser `json:"bot"`
	LangCode string     `json:"lang_code"`
}

func (m *TLBotsGetBotInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetBotInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdcd914fd: func() error {
			x.PutClazzID(0xdcd914fd)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Bot != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Bot != nil {
				_ = m.Bot.Encode(x, layer)
			}

			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getBotInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getBotInfo, layer)
	}
}

// Decode <--
func (m *TLBotsGetBotInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdcd914fd: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &InputUser{}
				_ = m2.Decode(d)
				m.Bot = m2
			}
			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsReorderUsernames <--
type TLBotsReorderUsernames struct {
	ClazzID uint32     `json:"_id"`
	Bot     *InputUser `json:"bot"`
	Order   []string   `json:"order"`
}

func (m *TLBotsReorderUsernames) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsReorderUsernames) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9709b1c2: func() error {
			x.PutClazzID(0x9709b1c2)

			_ = m.Bot.Encode(x, layer)

			iface.EncodeStringList(x, m.Order)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_reorderUsernames, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_reorderUsernames, layer)
	}
}

// Decode <--
func (m *TLBotsReorderUsernames) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9709b1c2: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.Order, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsToggleUsername <--
type TLBotsToggleUsername struct {
	ClazzID  uint32     `json:"_id"`
	Bot      *InputUser `json:"bot"`
	Username string     `json:"username"`
	Active   *Bool      `json:"active"`
}

func (m *TLBotsToggleUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsToggleUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x53ca973: func() error {
			x.PutClazzID(0x53ca973)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.Username)
			_ = m.Active.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_toggleUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_toggleUsername, layer)
	}
}

// Decode <--
func (m *TLBotsToggleUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x53ca973: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.Username, err = d.String()

			m3 := &Bool{}
			_ = m3.Decode(d)
			m.Active = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsCanSendMessage <--
type TLBotsCanSendMessage struct {
	ClazzID uint32     `json:"_id"`
	Bot     *InputUser `json:"bot"`
}

func (m *TLBotsCanSendMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsCanSendMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1359f4e6: func() error {
			x.PutClazzID(0x1359f4e6)

			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_canSendMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_canSendMessage, layer)
	}
}

// Decode <--
func (m *TLBotsCanSendMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1359f4e6: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsAllowSendMessage <--
type TLBotsAllowSendMessage struct {
	ClazzID uint32     `json:"_id"`
	Bot     *InputUser `json:"bot"`
}

func (m *TLBotsAllowSendMessage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsAllowSendMessage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf132e3ef: func() error {
			x.PutClazzID(0xf132e3ef)

			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_allowSendMessage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_allowSendMessage, layer)
	}
}

// Decode <--
func (m *TLBotsAllowSendMessage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf132e3ef: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsInvokeWebViewCustomMethod <--
type TLBotsInvokeWebViewCustomMethod struct {
	ClazzID      uint32     `json:"_id"`
	Bot          *InputUser `json:"bot"`
	CustomMethod string     `json:"custom_method"`
	Params       *DataJSON  `json:"params"`
}

func (m *TLBotsInvokeWebViewCustomMethod) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsInvokeWebViewCustomMethod) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x87fc5e7: func() error {
			x.PutClazzID(0x87fc5e7)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.CustomMethod)
			_ = m.Params.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_invokeWebViewCustomMethod, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_invokeWebViewCustomMethod, layer)
	}
}

// Decode <--
func (m *TLBotsInvokeWebViewCustomMethod) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x87fc5e7: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.CustomMethod, err = d.String()

			m3 := &DataJSON{}
			_ = m3.Decode(d)
			m.Params = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetPopularAppBots <--
type TLBotsGetPopularAppBots struct {
	ClazzID uint32 `json:"_id"`
	Offset  string `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (m *TLBotsGetPopularAppBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetPopularAppBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc2510192: func() error {
			x.PutClazzID(0xc2510192)

			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getPopularAppBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getPopularAppBots, layer)
	}
}

// Decode <--
func (m *TLBotsGetPopularAppBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc2510192: func() (err error) {
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsAddPreviewMedia <--
type TLBotsAddPreviewMedia struct {
	ClazzID  uint32      `json:"_id"`
	Bot      *InputUser  `json:"bot"`
	LangCode string      `json:"lang_code"`
	Media    *InputMedia `json:"media"`
}

func (m *TLBotsAddPreviewMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsAddPreviewMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x17aeb75a: func() error {
			x.PutClazzID(0x17aeb75a)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.LangCode)
			_ = m.Media.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_addPreviewMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_addPreviewMedia, layer)
	}
}

// Decode <--
func (m *TLBotsAddPreviewMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x17aeb75a: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.LangCode, err = d.String()

			m3 := &InputMedia{}
			_ = m3.Decode(d)
			m.Media = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsEditPreviewMedia <--
type TLBotsEditPreviewMedia struct {
	ClazzID  uint32      `json:"_id"`
	Bot      *InputUser  `json:"bot"`
	LangCode string      `json:"lang_code"`
	Media    *InputMedia `json:"media"`
	NewMedia *InputMedia `json:"new_media"`
}

func (m *TLBotsEditPreviewMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsEditPreviewMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8525606f: func() error {
			x.PutClazzID(0x8525606f)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.LangCode)
			_ = m.Media.Encode(x, layer)
			_ = m.NewMedia.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_editPreviewMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_editPreviewMedia, layer)
	}
}

// Decode <--
func (m *TLBotsEditPreviewMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8525606f: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.LangCode, err = d.String()

			m3 := &InputMedia{}
			_ = m3.Decode(d)
			m.Media = m3

			m4 := &InputMedia{}
			_ = m4.Decode(d)
			m.NewMedia = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsDeletePreviewMedia <--
type TLBotsDeletePreviewMedia struct {
	ClazzID  uint32        `json:"_id"`
	Bot      *InputUser    `json:"bot"`
	LangCode string        `json:"lang_code"`
	Media    []*InputMedia `json:"media"`
}

func (m *TLBotsDeletePreviewMedia) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsDeletePreviewMedia) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2d0135b3: func() error {
			x.PutClazzID(0x2d0135b3)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.LangCode)

			_ = iface.EncodeObjectList(x, m.Media, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_deletePreviewMedia, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_deletePreviewMedia, layer)
	}
}

// Decode <--
func (m *TLBotsDeletePreviewMedia) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2d0135b3: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.LangCode, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			v3 := make([]*InputMedia, l3)
			for i := 0; i < l3; i++ {
				vv := new(InputMedia)
				err3 = vv.Decode(d)
				_ = err3
				v3[i] = vv
			}
			m.Media = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsReorderPreviewMedias <--
type TLBotsReorderPreviewMedias struct {
	ClazzID  uint32        `json:"_id"`
	Bot      *InputUser    `json:"bot"`
	LangCode string        `json:"lang_code"`
	Order    []*InputMedia `json:"order"`
}

func (m *TLBotsReorderPreviewMedias) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsReorderPreviewMedias) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb627f3aa: func() error {
			x.PutClazzID(0xb627f3aa)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.LangCode)

			_ = iface.EncodeObjectList(x, m.Order, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_reorderPreviewMedias, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_reorderPreviewMedias, layer)
	}
}

// Decode <--
func (m *TLBotsReorderPreviewMedias) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb627f3aa: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.LangCode, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			v3 := make([]*InputMedia, l3)
			for i := 0; i < l3; i++ {
				vv := new(InputMedia)
				err3 = vv.Decode(d)
				_ = err3
				v3[i] = vv
			}
			m.Order = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetPreviewInfo <--
type TLBotsGetPreviewInfo struct {
	ClazzID  uint32     `json:"_id"`
	Bot      *InputUser `json:"bot"`
	LangCode string     `json:"lang_code"`
}

func (m *TLBotsGetPreviewInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetPreviewInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x423ab3ad: func() error {
			x.PutClazzID(0x423ab3ad)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getPreviewInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getPreviewInfo, layer)
	}
}

// Decode <--
func (m *TLBotsGetPreviewInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x423ab3ad: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetPreviewMedias <--
type TLBotsGetPreviewMedias struct {
	ClazzID uint32     `json:"_id"`
	Bot     *InputUser `json:"bot"`
}

func (m *TLBotsGetPreviewMedias) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetPreviewMedias) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa2a5594d: func() error {
			x.PutClazzID(0xa2a5594d)

			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getPreviewMedias, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getPreviewMedias, layer)
	}
}

// Decode <--
func (m *TLBotsGetPreviewMedias) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa2a5594d: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsUpdateUserEmojiStatus <--
type TLBotsUpdateUserEmojiStatus struct {
	ClazzID     uint32       `json:"_id"`
	UserId      *InputUser   `json:"user_id"`
	EmojiStatus *EmojiStatus `json:"emoji_status"`
}

func (m *TLBotsUpdateUserEmojiStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsUpdateUserEmojiStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xed9f30c5: func() error {
			x.PutClazzID(0xed9f30c5)

			_ = m.UserId.Encode(x, layer)
			_ = m.EmojiStatus.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_updateUserEmojiStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_updateUserEmojiStatus, layer)
	}
}

// Decode <--
func (m *TLBotsUpdateUserEmojiStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xed9f30c5: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.UserId = m1

			m2 := &EmojiStatus{}
			_ = m2.Decode(d)
			m.EmojiStatus = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsToggleUserEmojiStatusPermission <--
type TLBotsToggleUserEmojiStatusPermission struct {
	ClazzID uint32     `json:"_id"`
	Bot     *InputUser `json:"bot"`
	Enabled *Bool      `json:"enabled"`
}

func (m *TLBotsToggleUserEmojiStatusPermission) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsToggleUserEmojiStatusPermission) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6de6392: func() error {
			x.PutClazzID(0x6de6392)

			_ = m.Bot.Encode(x, layer)
			_ = m.Enabled.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_toggleUserEmojiStatusPermission, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_toggleUserEmojiStatusPermission, layer)
	}
}

// Decode <--
func (m *TLBotsToggleUserEmojiStatusPermission) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6de6392: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Enabled = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsCheckDownloadFileParams <--
type TLBotsCheckDownloadFileParams struct {
	ClazzID  uint32     `json:"_id"`
	Bot      *InputUser `json:"bot"`
	FileName string     `json:"file_name"`
	Url      string     `json:"url"`
}

func (m *TLBotsCheckDownloadFileParams) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsCheckDownloadFileParams) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x50077589: func() error {
			x.PutClazzID(0x50077589)

			_ = m.Bot.Encode(x, layer)
			x.PutString(m.FileName)
			x.PutString(m.Url)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_checkDownloadFileParams, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_checkDownloadFileParams, layer)
	}
}

// Decode <--
func (m *TLBotsCheckDownloadFileParams) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x50077589: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			m.FileName, err = d.String()
			m.Url, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetAdminedBots <--
type TLBotsGetAdminedBots struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLBotsGetAdminedBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetAdminedBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb0711d83: func() error {
			x.PutClazzID(0xb0711d83)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getAdminedBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getAdminedBots, layer)
	}
}

// Decode <--
func (m *TLBotsGetAdminedBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb0711d83: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsUpdateStarRefProgram <--
type TLBotsUpdateStarRefProgram struct {
	ClazzID            uint32     `json:"_id"`
	Bot                *InputUser `json:"bot"`
	CommissionPermille int32      `json:"commission_permille"`
	DurationMonths     *int32     `json:"duration_months"`
}

func (m *TLBotsUpdateStarRefProgram) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsUpdateStarRefProgram) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x778b5ab3: func() error {
			x.PutClazzID(0x778b5ab3)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.DurationMonths != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Bot.Encode(x, layer)
			x.PutInt32(m.CommissionPermille)
			if m.DurationMonths != nil {
				x.PutInt32(*m.DurationMonths)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_updateStarRefProgram, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_updateStarRefProgram, layer)
	}
}

// Decode <--
func (m *TLBotsUpdateStarRefProgram) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x778b5ab3: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.Bot = m2

			m.CommissionPermille, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.DurationMonths = new(int32)
				*m.DurationMonths, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsSetCustomVerification <--
type TLBotsSetCustomVerification struct {
	ClazzID           uint32     `json:"_id"`
	Enabled           bool       `json:"enabled"`
	Bot               *InputUser `json:"bot"`
	Peer              *InputPeer `json:"peer"`
	CustomDescription *string    `json:"custom_description"`
}

func (m *TLBotsSetCustomVerification) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsSetCustomVerification) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8b89dfbd: func() error {
			x.PutClazzID(0x8b89dfbd)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Enabled == true {
					flags |= 1 << 1
				}
				if m.Bot != nil {
					flags |= 1 << 0
				}

				if m.CustomDescription != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Bot != nil {
				_ = m.Bot.Encode(x, layer)
			}

			_ = m.Peer.Encode(x, layer)
			if m.CustomDescription != nil {
				x.PutString(*m.CustomDescription)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_setCustomVerification, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_setCustomVerification, layer)
	}
}

// Decode <--
func (m *TLBotsSetCustomVerification) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8b89dfbd: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Enabled = true
			}
			if (flags & (1 << 0)) != 0 {
				m3 := &InputUser{}
				_ = m3.Decode(d)
				m.Bot = m3
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			if (flags & (1 << 2)) != 0 {
				m.CustomDescription = new(string)
				*m.CustomDescription, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBotsGetBotRecommendations <--
type TLBotsGetBotRecommendations struct {
	ClazzID uint32     `json:"_id"`
	Bot     *InputUser `json:"bot"`
}

func (m *TLBotsGetBotRecommendations) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBotsGetBotRecommendations) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa1b70815: func() error {
			x.PutClazzID(0xa1b70815)

			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_bots_getBotRecommendations, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_bots_getBotRecommendations, layer)
	}
}

// Decode <--
func (m *TLBotsGetBotRecommendations) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa1b70815: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.Bot = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetPaymentForm <--
type TLPaymentsGetPaymentForm struct {
	ClazzID     uint32        `json:"_id"`
	Invoice     *InputInvoice `json:"invoice"`
	ThemeParams *DataJSON     `json:"theme_params"`
}

func (m *TLPaymentsGetPaymentForm) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetPaymentForm) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x37148dbb: func() error {
			x.PutClazzID(0x37148dbb)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ThemeParams != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Invoice.Encode(x, layer)
			if m.ThemeParams != nil {
				_ = m.ThemeParams.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getPaymentForm, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getPaymentForm, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetPaymentForm) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x37148dbb: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputInvoice{}
			_ = m2.Decode(d)
			m.Invoice = m2

			if (flags & (1 << 0)) != 0 {
				m3 := &DataJSON{}
				_ = m3.Decode(d)
				m.ThemeParams = m3
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetPaymentReceipt <--
type TLPaymentsGetPaymentReceipt struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MsgId   int32      `json:"msg_id"`
}

func (m *TLPaymentsGetPaymentReceipt) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetPaymentReceipt) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2478d1cc: func() error {
			x.PutClazzID(0x2478d1cc)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getPaymentReceipt, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getPaymentReceipt, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetPaymentReceipt) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2478d1cc: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsValidateRequestedInfo <--
type TLPaymentsValidateRequestedInfo struct {
	ClazzID uint32                `json:"_id"`
	Save    bool                  `json:"save"`
	Invoice *InputInvoice         `json:"invoice"`
	Info    *PaymentRequestedInfo `json:"info"`
}

func (m *TLPaymentsValidateRequestedInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsValidateRequestedInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb6c8f12b: func() error {
			x.PutClazzID(0xb6c8f12b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Save == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Invoice.Encode(x, layer)
			_ = m.Info.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_validateRequestedInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_validateRequestedInfo, layer)
	}
}

// Decode <--
func (m *TLPaymentsValidateRequestedInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb6c8f12b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Save = true
			}

			m3 := &InputInvoice{}
			_ = m3.Decode(d)
			m.Invoice = m3

			m4 := &PaymentRequestedInfo{}
			_ = m4.Decode(d)
			m.Info = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsSendPaymentForm <--
type TLPaymentsSendPaymentForm struct {
	ClazzID          uint32                   `json:"_id"`
	FormId           int64                    `json:"form_id"`
	Invoice          *InputInvoice            `json:"invoice"`
	RequestedInfoId  *string                  `json:"requested_info_id"`
	ShippingOptionId *string                  `json:"shipping_option_id"`
	Credentials      *InputPaymentCredentials `json:"credentials"`
	TipAmount        *int64                   `json:"tip_amount"`
}

func (m *TLPaymentsSendPaymentForm) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsSendPaymentForm) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2d03522f: func() error {
			x.PutClazzID(0x2d03522f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.RequestedInfoId != nil {
					flags |= 1 << 0
				}
				if m.ShippingOptionId != nil {
					flags |= 1 << 1
				}

				if m.TipAmount != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.FormId)
			_ = m.Invoice.Encode(x, layer)
			if m.RequestedInfoId != nil {
				x.PutString(*m.RequestedInfoId)
			}

			if m.ShippingOptionId != nil {
				x.PutString(*m.ShippingOptionId)
			}

			_ = m.Credentials.Encode(x, layer)
			if m.TipAmount != nil {
				x.PutInt64(*m.TipAmount)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_sendPaymentForm, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_sendPaymentForm, layer)
	}
}

// Decode <--
func (m *TLPaymentsSendPaymentForm) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2d03522f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.FormId, err = d.Int64()

			m3 := &InputInvoice{}
			_ = m3.Decode(d)
			m.Invoice = m3

			if (flags & (1 << 0)) != 0 {
				m.RequestedInfoId = new(string)
				*m.RequestedInfoId, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.ShippingOptionId = new(string)
				*m.ShippingOptionId, err = d.String()
			}

			m6 := &InputPaymentCredentials{}
			_ = m6.Decode(d)
			m.Credentials = m6

			if (flags & (1 << 2)) != 0 {
				m.TipAmount = new(int64)
				*m.TipAmount, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetSavedInfo <--
type TLPaymentsGetSavedInfo struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPaymentsGetSavedInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetSavedInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x227d824b: func() error {
			x.PutClazzID(0x227d824b)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getSavedInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getSavedInfo, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetSavedInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x227d824b: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsClearSavedInfo <--
type TLPaymentsClearSavedInfo struct {
	ClazzID     uint32 `json:"_id"`
	Credentials bool   `json:"credentials"`
	Info        bool   `json:"info"`
}

func (m *TLPaymentsClearSavedInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsClearSavedInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd83d70c1: func() error {
			x.PutClazzID(0xd83d70c1)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Credentials == true {
					flags |= 1 << 0
				}
				if m.Info == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_clearSavedInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_clearSavedInfo, layer)
	}
}

// Decode <--
func (m *TLPaymentsClearSavedInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd83d70c1: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Credentials = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Info = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetBankCardData <--
type TLPaymentsGetBankCardData struct {
	ClazzID uint32 `json:"_id"`
	Number  string `json:"number"`
}

func (m *TLPaymentsGetBankCardData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetBankCardData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2e79d779: func() error {
			x.PutClazzID(0x2e79d779)

			x.PutString(m.Number)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getBankCardData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getBankCardData, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetBankCardData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2e79d779: func() (err error) {
			m.Number, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsExportInvoice <--
type TLPaymentsExportInvoice struct {
	ClazzID      uint32      `json:"_id"`
	InvoiceMedia *InputMedia `json:"invoice_media"`
}

func (m *TLPaymentsExportInvoice) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsExportInvoice) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf91b065: func() error {
			x.PutClazzID(0xf91b065)

			_ = m.InvoiceMedia.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_exportInvoice, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_exportInvoice, layer)
	}
}

// Decode <--
func (m *TLPaymentsExportInvoice) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf91b065: func() (err error) {

			m1 := &InputMedia{}
			_ = m1.Decode(d)
			m.InvoiceMedia = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsAssignAppStoreTransaction <--
type TLPaymentsAssignAppStoreTransaction struct {
	ClazzID uint32                    `json:"_id"`
	Receipt []byte                    `json:"receipt"`
	Purpose *InputStorePaymentPurpose `json:"purpose"`
}

func (m *TLPaymentsAssignAppStoreTransaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsAssignAppStoreTransaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x80ed747d: func() error {
			x.PutClazzID(0x80ed747d)

			x.PutBytes(m.Receipt)
			_ = m.Purpose.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_assignAppStoreTransaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_assignAppStoreTransaction, layer)
	}
}

// Decode <--
func (m *TLPaymentsAssignAppStoreTransaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x80ed747d: func() (err error) {
			m.Receipt, err = d.Bytes()

			m2 := &InputStorePaymentPurpose{}
			_ = m2.Decode(d)
			m.Purpose = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsAssignPlayMarketTransaction <--
type TLPaymentsAssignPlayMarketTransaction struct {
	ClazzID uint32                    `json:"_id"`
	Receipt *DataJSON                 `json:"receipt"`
	Purpose *InputStorePaymentPurpose `json:"purpose"`
}

func (m *TLPaymentsAssignPlayMarketTransaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsAssignPlayMarketTransaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdffd50d3: func() error {
			x.PutClazzID(0xdffd50d3)

			_ = m.Receipt.Encode(x, layer)
			_ = m.Purpose.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_assignPlayMarketTransaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_assignPlayMarketTransaction, layer)
	}
}

// Decode <--
func (m *TLPaymentsAssignPlayMarketTransaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdffd50d3: func() (err error) {

			m1 := &DataJSON{}
			_ = m1.Decode(d)
			m.Receipt = m1

			m2 := &InputStorePaymentPurpose{}
			_ = m2.Decode(d)
			m.Purpose = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetPremiumGiftCodeOptions <--
type TLPaymentsGetPremiumGiftCodeOptions struct {
	ClazzID   uint32     `json:"_id"`
	BoostPeer *InputPeer `json:"boost_peer"`
}

func (m *TLPaymentsGetPremiumGiftCodeOptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetPremiumGiftCodeOptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2757ba54: func() error {
			x.PutClazzID(0x2757ba54)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.BoostPeer != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.BoostPeer != nil {
				_ = m.BoostPeer.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getPremiumGiftCodeOptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getPremiumGiftCodeOptions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetPremiumGiftCodeOptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2757ba54: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &InputPeer{}
				_ = m2.Decode(d)
				m.BoostPeer = m2
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsCheckGiftCode <--
type TLPaymentsCheckGiftCode struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLPaymentsCheckGiftCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsCheckGiftCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8e51b4c1: func() error {
			x.PutClazzID(0x8e51b4c1)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_checkGiftCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_checkGiftCode, layer)
	}
}

// Decode <--
func (m *TLPaymentsCheckGiftCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8e51b4c1: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsApplyGiftCode <--
type TLPaymentsApplyGiftCode struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLPaymentsApplyGiftCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsApplyGiftCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf6e26854: func() error {
			x.PutClazzID(0xf6e26854)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_applyGiftCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_applyGiftCode, layer)
	}
}

// Decode <--
func (m *TLPaymentsApplyGiftCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf6e26854: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetGiveawayInfo <--
type TLPaymentsGetGiveawayInfo struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MsgId   int32      `json:"msg_id"`
}

func (m *TLPaymentsGetGiveawayInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetGiveawayInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf4239425: func() error {
			x.PutClazzID(0xf4239425)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getGiveawayInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getGiveawayInfo, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetGiveawayInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf4239425: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsLaunchPrepaidGiveaway <--
type TLPaymentsLaunchPrepaidGiveaway struct {
	ClazzID    uint32                    `json:"_id"`
	Peer       *InputPeer                `json:"peer"`
	GiveawayId int64                     `json:"giveaway_id"`
	Purpose    *InputStorePaymentPurpose `json:"purpose"`
}

func (m *TLPaymentsLaunchPrepaidGiveaway) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsLaunchPrepaidGiveaway) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5ff58f20: func() error {
			x.PutClazzID(0x5ff58f20)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.GiveawayId)
			_ = m.Purpose.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_launchPrepaidGiveaway, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_launchPrepaidGiveaway, layer)
	}
}

// Decode <--
func (m *TLPaymentsLaunchPrepaidGiveaway) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5ff58f20: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.GiveawayId, err = d.Int64()

			m3 := &InputStorePaymentPurpose{}
			_ = m3.Decode(d)
			m.Purpose = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsTopupOptions <--
type TLPaymentsGetStarsTopupOptions struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPaymentsGetStarsTopupOptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsTopupOptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc00ec7d3: func() error {
			x.PutClazzID(0xc00ec7d3)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsTopupOptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsTopupOptions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsTopupOptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc00ec7d3: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsStatus <--
type TLPaymentsGetStarsStatus struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLPaymentsGetStarsStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x104fcfa7: func() error {
			x.PutClazzID(0x104fcfa7)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsStatus, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x104fcfa7: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsTransactions <--
type TLPaymentsGetStarsTransactions struct {
	ClazzID        uint32     `json:"_id"`
	Inbound        bool       `json:"inbound"`
	Outbound       bool       `json:"outbound"`
	Ascending      bool       `json:"ascending"`
	SubscriptionId *string    `json:"subscription_id"`
	Peer           *InputPeer `json:"peer"`
	Offset         string     `json:"offset"`
	Limit          int32      `json:"limit"`
}

func (m *TLPaymentsGetStarsTransactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsTransactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x69da4557: func() error {
			x.PutClazzID(0x69da4557)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Inbound == true {
					flags |= 1 << 0
				}
				if m.Outbound == true {
					flags |= 1 << 1
				}
				if m.Ascending == true {
					flags |= 1 << 2
				}
				if m.SubscriptionId != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.SubscriptionId != nil {
				x.PutString(*m.SubscriptionId)
			}

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsTransactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsTransactions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsTransactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x69da4557: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Inbound = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Outbound = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Ascending = true
			}
			if (flags & (1 << 3)) != 0 {
				m.SubscriptionId = new(string)
				*m.SubscriptionId, err = d.String()
			}

			m6 := &InputPeer{}
			_ = m6.Decode(d)
			m.Peer = m6

			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsSendStarsForm <--
type TLPaymentsSendStarsForm struct {
	ClazzID uint32        `json:"_id"`
	FormId  int64         `json:"form_id"`
	Invoice *InputInvoice `json:"invoice"`
}

func (m *TLPaymentsSendStarsForm) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsSendStarsForm) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7998c914: func() error {
			x.PutClazzID(0x7998c914)

			x.PutInt64(m.FormId)
			_ = m.Invoice.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_sendStarsForm, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_sendStarsForm, layer)
	}
}

// Decode <--
func (m *TLPaymentsSendStarsForm) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7998c914: func() (err error) {
			m.FormId, err = d.Int64()

			m2 := &InputInvoice{}
			_ = m2.Decode(d)
			m.Invoice = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsRefundStarsCharge <--
type TLPaymentsRefundStarsCharge struct {
	ClazzID  uint32     `json:"_id"`
	UserId   *InputUser `json:"user_id"`
	ChargeId string     `json:"charge_id"`
}

func (m *TLPaymentsRefundStarsCharge) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsRefundStarsCharge) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x25ae8f4a: func() error {
			x.PutClazzID(0x25ae8f4a)

			_ = m.UserId.Encode(x, layer)
			x.PutString(m.ChargeId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_refundStarsCharge, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_refundStarsCharge, layer)
	}
}

// Decode <--
func (m *TLPaymentsRefundStarsCharge) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x25ae8f4a: func() (err error) {

			m1 := &InputUser{}
			_ = m1.Decode(d)
			m.UserId = m1

			m.ChargeId, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsRevenueStats <--
type TLPaymentsGetStarsRevenueStats struct {
	ClazzID uint32     `json:"_id"`
	Dark    bool       `json:"dark"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLPaymentsGetStarsRevenueStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsRevenueStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd91ffad6: func() error {
			x.PutClazzID(0xd91ffad6)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsRevenueStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsRevenueStats, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsRevenueStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd91ffad6: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsRevenueWithdrawalUrl <--
type TLPaymentsGetStarsRevenueWithdrawalUrl struct {
	ClazzID  uint32                 `json:"_id"`
	Peer     *InputPeer             `json:"peer"`
	Stars    int64                  `json:"stars"`
	Password *InputCheckPasswordSRP `json:"password"`
}

func (m *TLPaymentsGetStarsRevenueWithdrawalUrl) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsRevenueWithdrawalUrl) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x13bbe8b3: func() error {
			x.PutClazzID(0x13bbe8b3)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.Stars)
			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsRevenueWithdrawalUrl, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsRevenueWithdrawalUrl, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsRevenueWithdrawalUrl) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x13bbe8b3: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Stars, err = d.Int64()

			m3 := &InputCheckPasswordSRP{}
			_ = m3.Decode(d)
			m.Password = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsRevenueAdsAccountUrl <--
type TLPaymentsGetStarsRevenueAdsAccountUrl struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLPaymentsGetStarsRevenueAdsAccountUrl) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsRevenueAdsAccountUrl) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd1d7efc5: func() error {
			x.PutClazzID(0xd1d7efc5)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsRevenueAdsAccountUrl, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsRevenueAdsAccountUrl, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsRevenueAdsAccountUrl) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd1d7efc5: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsTransactionsByID <--
type TLPaymentsGetStarsTransactionsByID struct {
	ClazzID uint32                   `json:"_id"`
	Peer    *InputPeer               `json:"peer"`
	Id      []*InputStarsTransaction `json:"id"`
}

func (m *TLPaymentsGetStarsTransactionsByID) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsTransactionsByID) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x27842d2e: func() error {
			x.PutClazzID(0x27842d2e)

			_ = m.Peer.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsTransactionsByID, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsTransactionsByID, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsTransactionsByID) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x27842d2e: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputStarsTransaction, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputStarsTransaction)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Id = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsGiftOptions <--
type TLPaymentsGetStarsGiftOptions struct {
	ClazzID uint32     `json:"_id"`
	UserId  *InputUser `json:"user_id"`
}

func (m *TLPaymentsGetStarsGiftOptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsGiftOptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd3c96bc8: func() error {
			x.PutClazzID(0xd3c96bc8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.UserId != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.UserId != nil {
				_ = m.UserId.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsGiftOptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsGiftOptions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsGiftOptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd3c96bc8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m2 := &InputUser{}
				_ = m2.Decode(d)
				m.UserId = m2
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsSubscriptions <--
type TLPaymentsGetStarsSubscriptions struct {
	ClazzID        uint32     `json:"_id"`
	MissingBalance bool       `json:"missing_balance"`
	Peer           *InputPeer `json:"peer"`
	Offset         string     `json:"offset"`
}

func (m *TLPaymentsGetStarsSubscriptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsSubscriptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x32512c5: func() error {
			x.PutClazzID(0x32512c5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.MissingBalance == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Offset)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsSubscriptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsSubscriptions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsSubscriptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x32512c5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.MissingBalance = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.Offset, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsChangeStarsSubscription <--
type TLPaymentsChangeStarsSubscription struct {
	ClazzID        uint32     `json:"_id"`
	Peer           *InputPeer `json:"peer"`
	SubscriptionId string     `json:"subscription_id"`
	Canceled       *Bool      `json:"canceled"`
}

func (m *TLPaymentsChangeStarsSubscription) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsChangeStarsSubscription) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc7770878: func() error {
			x.PutClazzID(0xc7770878)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Canceled != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.SubscriptionId)
			if m.Canceled != nil {
				_ = m.Canceled.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_changeStarsSubscription, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_changeStarsSubscription, layer)
	}
}

// Decode <--
func (m *TLPaymentsChangeStarsSubscription) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc7770878: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			m.SubscriptionId, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m4 := &Bool{}
				_ = m4.Decode(d)
				m.Canceled = m4
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsFulfillStarsSubscription <--
type TLPaymentsFulfillStarsSubscription struct {
	ClazzID        uint32     `json:"_id"`
	Peer           *InputPeer `json:"peer"`
	SubscriptionId string     `json:"subscription_id"`
}

func (m *TLPaymentsFulfillStarsSubscription) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsFulfillStarsSubscription) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcc5bebb3: func() error {
			x.PutClazzID(0xcc5bebb3)

			_ = m.Peer.Encode(x, layer)
			x.PutString(m.SubscriptionId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_fulfillStarsSubscription, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_fulfillStarsSubscription, layer)
	}
}

// Decode <--
func (m *TLPaymentsFulfillStarsSubscription) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcc5bebb3: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.SubscriptionId, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarsGiveawayOptions <--
type TLPaymentsGetStarsGiveawayOptions struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPaymentsGetStarsGiveawayOptions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarsGiveawayOptions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbd1efd3e: func() error {
			x.PutClazzID(0xbd1efd3e)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarsGiveawayOptions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarsGiveawayOptions, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarsGiveawayOptions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbd1efd3e: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarGifts <--
type TLPaymentsGetStarGifts struct {
	ClazzID uint32 `json:"_id"`
	Hash    int32  `json:"hash"`
}

func (m *TLPaymentsGetStarGifts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarGifts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc4563590: func() error {
			x.PutClazzID(0xc4563590)

			x.PutInt32(m.Hash)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarGifts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarGifts, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarGifts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc4563590: func() (err error) {
			m.Hash, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsSaveStarGift <--
type TLPaymentsSaveStarGift struct {
	ClazzID  uint32              `json:"_id"`
	Unsave   bool                `json:"unsave"`
	Stargift *InputSavedStarGift `json:"stargift"`
}

func (m *TLPaymentsSaveStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsSaveStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2a2a697c: func() error {
			x.PutClazzID(0x2a2a697c)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Unsave == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Stargift.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_saveStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_saveStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsSaveStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2a2a697c: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Unsave = true
			}

			m3 := &InputSavedStarGift{}
			_ = m3.Decode(d)
			m.Stargift = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsConvertStarGift <--
type TLPaymentsConvertStarGift struct {
	ClazzID  uint32              `json:"_id"`
	Stargift *InputSavedStarGift `json:"stargift"`
}

func (m *TLPaymentsConvertStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsConvertStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x74bf076b: func() error {
			x.PutClazzID(0x74bf076b)

			_ = m.Stargift.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_convertStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_convertStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsConvertStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x74bf076b: func() (err error) {

			m1 := &InputSavedStarGift{}
			_ = m1.Decode(d)
			m.Stargift = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsBotCancelStarsSubscription <--
type TLPaymentsBotCancelStarsSubscription struct {
	ClazzID  uint32     `json:"_id"`
	Restore  bool       `json:"restore"`
	UserId   *InputUser `json:"user_id"`
	ChargeId string     `json:"charge_id"`
}

func (m *TLPaymentsBotCancelStarsSubscription) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsBotCancelStarsSubscription) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6dfa0622: func() error {
			x.PutClazzID(0x6dfa0622)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Restore == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.UserId.Encode(x, layer)
			x.PutString(m.ChargeId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_botCancelStarsSubscription, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_botCancelStarsSubscription, layer)
	}
}

// Decode <--
func (m *TLPaymentsBotCancelStarsSubscription) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6dfa0622: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Restore = true
			}

			m3 := &InputUser{}
			_ = m3.Decode(d)
			m.UserId = m3

			m.ChargeId, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetConnectedStarRefBots <--
type TLPaymentsGetConnectedStarRefBots struct {
	ClazzID    uint32     `json:"_id"`
	Peer       *InputPeer `json:"peer"`
	OffsetDate *int32     `json:"offset_date"`
	OffsetLink *string    `json:"offset_link"`
	Limit      int32      `json:"limit"`
}

func (m *TLPaymentsGetConnectedStarRefBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetConnectedStarRefBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5869a553: func() error {
			x.PutClazzID(0x5869a553)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.OffsetDate != nil {
					flags |= 1 << 2
				}
				if m.OffsetLink != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.OffsetDate != nil {
				x.PutInt32(*m.OffsetDate)
			}

			if m.OffsetLink != nil {
				x.PutString(*m.OffsetLink)
			}

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getConnectedStarRefBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getConnectedStarRefBots, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetConnectedStarRefBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5869a553: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			if (flags & (1 << 2)) != 0 {
				m.OffsetDate = new(int32)
				*m.OffsetDate, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				m.OffsetLink = new(string)
				*m.OffsetLink, err = d.String()
			}

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetConnectedStarRefBot <--
type TLPaymentsGetConnectedStarRefBot struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Bot     *InputUser `json:"bot"`
}

func (m *TLPaymentsGetConnectedStarRefBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetConnectedStarRefBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb7d998f0: func() error {
			x.PutClazzID(0xb7d998f0)

			_ = m.Peer.Encode(x, layer)
			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getConnectedStarRefBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getConnectedStarRefBot, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetConnectedStarRefBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb7d998f0: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.Bot = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetSuggestedStarRefBots <--
type TLPaymentsGetSuggestedStarRefBots struct {
	ClazzID        uint32     `json:"_id"`
	OrderByRevenue bool       `json:"order_by_revenue"`
	OrderByDate    bool       `json:"order_by_date"`
	Peer           *InputPeer `json:"peer"`
	Offset         string     `json:"offset"`
	Limit          int32      `json:"limit"`
}

func (m *TLPaymentsGetSuggestedStarRefBots) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetSuggestedStarRefBots) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd6b48f7: func() error {
			x.PutClazzID(0xd6b48f7)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.OrderByRevenue == true {
					flags |= 1 << 0
				}
				if m.OrderByDate == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getSuggestedStarRefBots, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getSuggestedStarRefBots, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetSuggestedStarRefBots) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd6b48f7: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.OrderByRevenue = true
			}
			if (flags & (1 << 1)) != 0 {
				m.OrderByDate = true
			}

			m4 := &InputPeer{}
			_ = m4.Decode(d)
			m.Peer = m4

			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsConnectStarRefBot <--
type TLPaymentsConnectStarRefBot struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Bot     *InputUser `json:"bot"`
}

func (m *TLPaymentsConnectStarRefBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsConnectStarRefBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7ed5348a: func() error {
			x.PutClazzID(0x7ed5348a)

			_ = m.Peer.Encode(x, layer)
			_ = m.Bot.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_connectStarRefBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_connectStarRefBot, layer)
	}
}

// Decode <--
func (m *TLPaymentsConnectStarRefBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7ed5348a: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.Bot = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsEditConnectedStarRefBot <--
type TLPaymentsEditConnectedStarRefBot struct {
	ClazzID uint32     `json:"_id"`
	Revoked bool       `json:"revoked"`
	Peer    *InputPeer `json:"peer"`
	Link    string     `json:"link"`
}

func (m *TLPaymentsEditConnectedStarRefBot) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsEditConnectedStarRefBot) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe4fca4a3: func() error {
			x.PutClazzID(0xe4fca4a3)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Revoked == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Link)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_editConnectedStarRefBot, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_editConnectedStarRefBot, layer)
	}
}

// Decode <--
func (m *TLPaymentsEditConnectedStarRefBot) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe4fca4a3: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Revoked = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.Link, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarGiftUpgradePreview <--
type TLPaymentsGetStarGiftUpgradePreview struct {
	ClazzID uint32 `json:"_id"`
	GiftId  int64  `json:"gift_id"`
}

func (m *TLPaymentsGetStarGiftUpgradePreview) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarGiftUpgradePreview) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9c9abcb1: func() error {
			x.PutClazzID(0x9c9abcb1)

			x.PutInt64(m.GiftId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarGiftUpgradePreview, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarGiftUpgradePreview, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarGiftUpgradePreview) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9c9abcb1: func() (err error) {
			m.GiftId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsUpgradeStarGift <--
type TLPaymentsUpgradeStarGift struct {
	ClazzID             uint32              `json:"_id"`
	KeepOriginalDetails bool                `json:"keep_original_details"`
	Stargift            *InputSavedStarGift `json:"stargift"`
}

func (m *TLPaymentsUpgradeStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsUpgradeStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xaed6e4f5: func() error {
			x.PutClazzID(0xaed6e4f5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.KeepOriginalDetails == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Stargift.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_upgradeStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_upgradeStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsUpgradeStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xaed6e4f5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.KeepOriginalDetails = true
			}

			m3 := &InputSavedStarGift{}
			_ = m3.Decode(d)
			m.Stargift = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsTransferStarGift <--
type TLPaymentsTransferStarGift struct {
	ClazzID  uint32              `json:"_id"`
	Stargift *InputSavedStarGift `json:"stargift"`
	ToId     *InputPeer          `json:"to_id"`
}

func (m *TLPaymentsTransferStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsTransferStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7f18176a: func() error {
			x.PutClazzID(0x7f18176a)

			_ = m.Stargift.Encode(x, layer)
			_ = m.ToId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_transferStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_transferStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsTransferStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7f18176a: func() (err error) {

			m1 := &InputSavedStarGift{}
			_ = m1.Decode(d)
			m.Stargift = m1

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.ToId = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetUniqueStarGift <--
type TLPaymentsGetUniqueStarGift struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLPaymentsGetUniqueStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetUniqueStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa1974d72: func() error {
			x.PutClazzID(0xa1974d72)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getUniqueStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getUniqueStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetUniqueStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa1974d72: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetSavedStarGifts <--
type TLPaymentsGetSavedStarGifts struct {
	ClazzID          uint32     `json:"_id"`
	ExcludeUnsaved   bool       `json:"exclude_unsaved"`
	ExcludeSaved     bool       `json:"exclude_saved"`
	ExcludeUnlimited bool       `json:"exclude_unlimited"`
	ExcludeLimited   bool       `json:"exclude_limited"`
	ExcludeUnique    bool       `json:"exclude_unique"`
	SortByValue      bool       `json:"sort_by_value"`
	Peer             *InputPeer `json:"peer"`
	Offset           string     `json:"offset"`
	Limit            int32      `json:"limit"`
}

func (m *TLPaymentsGetSavedStarGifts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetSavedStarGifts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x23830de9: func() error {
			x.PutClazzID(0x23830de9)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ExcludeUnsaved == true {
					flags |= 1 << 0
				}
				if m.ExcludeSaved == true {
					flags |= 1 << 1
				}
				if m.ExcludeUnlimited == true {
					flags |= 1 << 2
				}
				if m.ExcludeLimited == true {
					flags |= 1 << 3
				}
				if m.ExcludeUnique == true {
					flags |= 1 << 4
				}
				if m.SortByValue == true {
					flags |= 1 << 5
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getSavedStarGifts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getSavedStarGifts, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetSavedStarGifts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x23830de9: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.ExcludeUnsaved = true
			}
			if (flags & (1 << 1)) != 0 {
				m.ExcludeSaved = true
			}
			if (flags & (1 << 2)) != 0 {
				m.ExcludeUnlimited = true
			}
			if (flags & (1 << 3)) != 0 {
				m.ExcludeLimited = true
			}
			if (flags & (1 << 4)) != 0 {
				m.ExcludeUnique = true
			}
			if (flags & (1 << 5)) != 0 {
				m.SortByValue = true
			}

			m8 := &InputPeer{}
			_ = m8.Decode(d)
			m.Peer = m8

			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetSavedStarGift <--
type TLPaymentsGetSavedStarGift struct {
	ClazzID  uint32                `json:"_id"`
	Stargift []*InputSavedStarGift `json:"stargift"`
}

func (m *TLPaymentsGetSavedStarGift) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetSavedStarGift) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb455a106: func() error {
			x.PutClazzID(0xb455a106)

			_ = iface.EncodeObjectList(x, m.Stargift, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getSavedStarGift, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getSavedStarGift, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetSavedStarGift) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb455a106: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputSavedStarGift, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputSavedStarGift)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Stargift = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsGetStarGiftWithdrawalUrl <--
type TLPaymentsGetStarGiftWithdrawalUrl struct {
	ClazzID  uint32                 `json:"_id"`
	Stargift *InputSavedStarGift    `json:"stargift"`
	Password *InputCheckPasswordSRP `json:"password"`
}

func (m *TLPaymentsGetStarGiftWithdrawalUrl) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsGetStarGiftWithdrawalUrl) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd06e93a8: func() error {
			x.PutClazzID(0xd06e93a8)

			_ = m.Stargift.Encode(x, layer)
			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_getStarGiftWithdrawalUrl, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_getStarGiftWithdrawalUrl, layer)
	}
}

// Decode <--
func (m *TLPaymentsGetStarGiftWithdrawalUrl) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd06e93a8: func() (err error) {

			m1 := &InputSavedStarGift{}
			_ = m1.Decode(d)
			m.Stargift = m1

			m2 := &InputCheckPasswordSRP{}
			_ = m2.Decode(d)
			m.Password = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsToggleChatStarGiftNotifications <--
type TLPaymentsToggleChatStarGiftNotifications struct {
	ClazzID uint32     `json:"_id"`
	Enabled bool       `json:"enabled"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLPaymentsToggleChatStarGiftNotifications) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsToggleChatStarGiftNotifications) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x60eaefa1: func() error {
			x.PutClazzID(0x60eaefa1)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Enabled == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_toggleChatStarGiftNotifications, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_toggleChatStarGiftNotifications, layer)
	}
}

// Decode <--
func (m *TLPaymentsToggleChatStarGiftNotifications) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x60eaefa1: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Enabled = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsToggleStarGiftsPinnedToTop <--
type TLPaymentsToggleStarGiftsPinnedToTop struct {
	ClazzID  uint32                `json:"_id"`
	Peer     *InputPeer            `json:"peer"`
	Stargift []*InputSavedStarGift `json:"stargift"`
}

func (m *TLPaymentsToggleStarGiftsPinnedToTop) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsToggleStarGiftsPinnedToTop) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1513e7b0: func() error {
			x.PutClazzID(0x1513e7b0)

			_ = m.Peer.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Stargift, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_toggleStarGiftsPinnedToTop, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_toggleStarGiftsPinnedToTop, layer)
	}
}

// Decode <--
func (m *TLPaymentsToggleStarGiftsPinnedToTop) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1513e7b0: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputSavedStarGift, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputSavedStarGift)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Stargift = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsCanPurchaseStore <--
type TLPaymentsCanPurchaseStore struct {
	ClazzID uint32                    `json:"_id"`
	Purpose *InputStorePaymentPurpose `json:"purpose"`
}

func (m *TLPaymentsCanPurchaseStore) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsCanPurchaseStore) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4fdc5ea7: func() error {
			x.PutClazzID(0x4fdc5ea7)

			_ = m.Purpose.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_canPurchaseStore, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_canPurchaseStore, layer)
	}
}

// Decode <--
func (m *TLPaymentsCanPurchaseStore) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4fdc5ea7: func() (err error) {

			m1 := &InputStorePaymentPurpose{}
			_ = m1.Decode(d)
			m.Purpose = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersCreateStickerSet <--
type TLStickersCreateStickerSet struct {
	ClazzID   uint32                 `json:"_id"`
	Masks     bool                   `json:"masks"`
	Emojis    bool                   `json:"emojis"`
	TextColor bool                   `json:"text_color"`
	UserId    *InputUser             `json:"user_id"`
	Title     string                 `json:"title"`
	ShortName string                 `json:"short_name"`
	Thumb     *InputDocument         `json:"thumb"`
	Stickers  []*InputStickerSetItem `json:"stickers"`
	Software  *string                `json:"software"`
}

func (m *TLStickersCreateStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersCreateStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9021ab67: func() error {
			x.PutClazzID(0x9021ab67)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Masks == true {
					flags |= 1 << 0
				}
				if m.Emojis == true {
					flags |= 1 << 5
				}
				if m.TextColor == true {
					flags |= 1 << 6
				}

				if m.Thumb != nil {
					flags |= 1 << 2
				}

				if m.Software != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.UserId.Encode(x, layer)
			x.PutString(m.Title)
			x.PutString(m.ShortName)
			if m.Thumb != nil {
				_ = m.Thumb.Encode(x, layer)
			}

			_ = iface.EncodeObjectList(x, m.Stickers, layer)

			if m.Software != nil {
				x.PutString(*m.Software)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_createStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_createStickerSet, layer)
	}
}

// Decode <--
func (m *TLStickersCreateStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9021ab67: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Masks = true
			}
			if (flags & (1 << 5)) != 0 {
				m.Emojis = true
			}
			if (flags & (1 << 6)) != 0 {
				m.TextColor = true
			}

			m5 := &InputUser{}
			_ = m5.Decode(d)
			m.UserId = m5

			m.Title, err = d.String()
			m.ShortName, err = d.String()
			if (flags & (1 << 2)) != 0 {
				m8 := &InputDocument{}
				_ = m8.Decode(d)
				m.Thumb = m8
			}
			c9, err2 := d.ClazzID()
			if c9 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 9, c9)
				return err2
			}
			l9, err3 := d.Int()
			v9 := make([]*InputStickerSetItem, l9)
			for i := 0; i < l9; i++ {
				vv := new(InputStickerSetItem)
				err3 = vv.Decode(d)
				_ = err3
				v9[i] = vv
			}
			m.Stickers = v9

			if (flags & (1 << 3)) != 0 {
				m.Software = new(string)
				*m.Software, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersRemoveStickerFromSet <--
type TLStickersRemoveStickerFromSet struct {
	ClazzID uint32         `json:"_id"`
	Sticker *InputDocument `json:"sticker"`
}

func (m *TLStickersRemoveStickerFromSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersRemoveStickerFromSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf7760f51: func() error {
			x.PutClazzID(0xf7760f51)

			_ = m.Sticker.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_removeStickerFromSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_removeStickerFromSet, layer)
	}
}

// Decode <--
func (m *TLStickersRemoveStickerFromSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf7760f51: func() (err error) {

			m1 := &InputDocument{}
			_ = m1.Decode(d)
			m.Sticker = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersChangeStickerPosition <--
type TLStickersChangeStickerPosition struct {
	ClazzID  uint32         `json:"_id"`
	Sticker  *InputDocument `json:"sticker"`
	Position int32          `json:"position"`
}

func (m *TLStickersChangeStickerPosition) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersChangeStickerPosition) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xffb6d4ca: func() error {
			x.PutClazzID(0xffb6d4ca)

			_ = m.Sticker.Encode(x, layer)
			x.PutInt32(m.Position)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_changeStickerPosition, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_changeStickerPosition, layer)
	}
}

// Decode <--
func (m *TLStickersChangeStickerPosition) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xffb6d4ca: func() (err error) {

			m1 := &InputDocument{}
			_ = m1.Decode(d)
			m.Sticker = m1

			m.Position, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersAddStickerToSet <--
type TLStickersAddStickerToSet struct {
	ClazzID    uint32               `json:"_id"`
	Stickerset *InputStickerSet     `json:"stickerset"`
	Sticker    *InputStickerSetItem `json:"sticker"`
}

func (m *TLStickersAddStickerToSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersAddStickerToSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8653febe: func() error {
			x.PutClazzID(0x8653febe)

			_ = m.Stickerset.Encode(x, layer)
			_ = m.Sticker.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_addStickerToSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_addStickerToSet, layer)
	}
}

// Decode <--
func (m *TLStickersAddStickerToSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8653febe: func() (err error) {

			m1 := &InputStickerSet{}
			_ = m1.Decode(d)
			m.Stickerset = m1

			m2 := &InputStickerSetItem{}
			_ = m2.Decode(d)
			m.Sticker = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersSetStickerSetThumb <--
type TLStickersSetStickerSetThumb struct {
	ClazzID         uint32           `json:"_id"`
	Stickerset      *InputStickerSet `json:"stickerset"`
	Thumb           *InputDocument   `json:"thumb"`
	ThumbDocumentId *int64           `json:"thumb_document_id"`
}

func (m *TLStickersSetStickerSetThumb) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersSetStickerSetThumb) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa76a5392: func() error {
			x.PutClazzID(0xa76a5392)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Thumb != nil {
					flags |= 1 << 0
				}
				if m.ThumbDocumentId != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Stickerset.Encode(x, layer)
			if m.Thumb != nil {
				_ = m.Thumb.Encode(x, layer)
			}

			if m.ThumbDocumentId != nil {
				x.PutInt64(*m.ThumbDocumentId)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_setStickerSetThumb, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_setStickerSetThumb, layer)
	}
}

// Decode <--
func (m *TLStickersSetStickerSetThumb) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa76a5392: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputStickerSet{}
			_ = m2.Decode(d)
			m.Stickerset = m2

			if (flags & (1 << 0)) != 0 {
				m3 := &InputDocument{}
				_ = m3.Decode(d)
				m.Thumb = m3
			}
			if (flags & (1 << 1)) != 0 {
				m.ThumbDocumentId = new(int64)
				*m.ThumbDocumentId, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersCheckShortName <--
type TLStickersCheckShortName struct {
	ClazzID   uint32 `json:"_id"`
	ShortName string `json:"short_name"`
}

func (m *TLStickersCheckShortName) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersCheckShortName) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x284b3639: func() error {
			x.PutClazzID(0x284b3639)

			x.PutString(m.ShortName)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_checkShortName, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_checkShortName, layer)
	}
}

// Decode <--
func (m *TLStickersCheckShortName) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x284b3639: func() (err error) {
			m.ShortName, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersSuggestShortName <--
type TLStickersSuggestShortName struct {
	ClazzID uint32 `json:"_id"`
	Title   string `json:"title"`
}

func (m *TLStickersSuggestShortName) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersSuggestShortName) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4dafc503: func() error {
			x.PutClazzID(0x4dafc503)

			x.PutString(m.Title)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_suggestShortName, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_suggestShortName, layer)
	}
}

// Decode <--
func (m *TLStickersSuggestShortName) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4dafc503: func() (err error) {
			m.Title, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersChangeSticker <--
type TLStickersChangeSticker struct {
	ClazzID    uint32         `json:"_id"`
	Sticker    *InputDocument `json:"sticker"`
	Emoji      *string        `json:"emoji"`
	MaskCoords *MaskCoords    `json:"mask_coords"`
	Keywords   *string        `json:"keywords"`
}

func (m *TLStickersChangeSticker) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersChangeSticker) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf5537ebc: func() error {
			x.PutClazzID(0xf5537ebc)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Emoji != nil {
					flags |= 1 << 0
				}
				if m.MaskCoords != nil {
					flags |= 1 << 1
				}
				if m.Keywords != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Sticker.Encode(x, layer)
			if m.Emoji != nil {
				x.PutString(*m.Emoji)
			}

			if m.MaskCoords != nil {
				_ = m.MaskCoords.Encode(x, layer)
			}

			if m.Keywords != nil {
				x.PutString(*m.Keywords)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_changeSticker, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_changeSticker, layer)
	}
}

// Decode <--
func (m *TLStickersChangeSticker) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf5537ebc: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputDocument{}
			_ = m2.Decode(d)
			m.Sticker = m2

			if (flags & (1 << 0)) != 0 {
				m.Emoji = new(string)
				*m.Emoji, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m4 := &MaskCoords{}
				_ = m4.Decode(d)
				m.MaskCoords = m4
			}
			if (flags & (1 << 2)) != 0 {
				m.Keywords = new(string)
				*m.Keywords, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersRenameStickerSet <--
type TLStickersRenameStickerSet struct {
	ClazzID    uint32           `json:"_id"`
	Stickerset *InputStickerSet `json:"stickerset"`
	Title      string           `json:"title"`
}

func (m *TLStickersRenameStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersRenameStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x124b1c00: func() error {
			x.PutClazzID(0x124b1c00)

			_ = m.Stickerset.Encode(x, layer)
			x.PutString(m.Title)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_renameStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_renameStickerSet, layer)
	}
}

// Decode <--
func (m *TLStickersRenameStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x124b1c00: func() (err error) {

			m1 := &InputStickerSet{}
			_ = m1.Decode(d)
			m.Stickerset = m1

			m.Title, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersDeleteStickerSet <--
type TLStickersDeleteStickerSet struct {
	ClazzID    uint32           `json:"_id"`
	Stickerset *InputStickerSet `json:"stickerset"`
}

func (m *TLStickersDeleteStickerSet) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersDeleteStickerSet) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x87704394: func() error {
			x.PutClazzID(0x87704394)

			_ = m.Stickerset.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_deleteStickerSet, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_deleteStickerSet, layer)
	}
}

// Decode <--
func (m *TLStickersDeleteStickerSet) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x87704394: func() (err error) {

			m1 := &InputStickerSet{}
			_ = m1.Decode(d)
			m.Stickerset = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStickersReplaceSticker <--
type TLStickersReplaceSticker struct {
	ClazzID    uint32               `json:"_id"`
	Sticker    *InputDocument       `json:"sticker"`
	NewSticker *InputStickerSetItem `json:"new_sticker"`
}

func (m *TLStickersReplaceSticker) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStickersReplaceSticker) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4696459a: func() error {
			x.PutClazzID(0x4696459a)

			_ = m.Sticker.Encode(x, layer)
			_ = m.NewSticker.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stickers_replaceSticker, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stickers_replaceSticker, layer)
	}
}

// Decode <--
func (m *TLStickersReplaceSticker) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4696459a: func() (err error) {

			m1 := &InputDocument{}
			_ = m1.Decode(d)
			m.Sticker = m1

			m2 := &InputStickerSetItem{}
			_ = m2.Decode(d)
			m.NewSticker = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetCallConfig <--
type TLPhoneGetCallConfig struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPhoneGetCallConfig) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetCallConfig) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x55451fa9: func() error {
			x.PutClazzID(0x55451fa9)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getCallConfig, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getCallConfig, layer)
	}
}

// Decode <--
func (m *TLPhoneGetCallConfig) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x55451fa9: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneRequestCall <--
type TLPhoneRequestCall struct {
	ClazzID        uint32             `json:"_id"`
	Video          bool               `json:"video"`
	UserId         *InputUser         `json:"user_id"`
	ConferenceCall *InputGroupCall    `json:"conference_call"`
	RandomId       int32              `json:"random_id"`
	GAHash         []byte             `json:"g_a_hash"`
	Protocol       *PhoneCallProtocol `json:"protocol"`
}

func (m *TLPhoneRequestCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneRequestCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa6c4600c: func() error {
			x.PutClazzID(0xa6c4600c)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Video == true {
					flags |= 1 << 0
				}

				if m.ConferenceCall != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.UserId.Encode(x, layer)
			if m.ConferenceCall != nil {
				_ = m.ConferenceCall.Encode(x, layer)
			}

			x.PutInt32(m.RandomId)
			x.PutBytes(m.GAHash)
			_ = m.Protocol.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_requestCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_requestCall, layer)
	}
}

// Decode <--
func (m *TLPhoneRequestCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa6c4600c: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Video = true
			}

			m3 := &InputUser{}
			_ = m3.Decode(d)
			m.UserId = m3

			if (flags & (1 << 1)) != 0 {
				m4 := &InputGroupCall{}
				_ = m4.Decode(d)
				m.ConferenceCall = m4
			}
			m.RandomId, err = d.Int32()
			m.GAHash, err = d.Bytes()

			m7 := &PhoneCallProtocol{}
			_ = m7.Decode(d)
			m.Protocol = m7

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneAcceptCall <--
type TLPhoneAcceptCall struct {
	ClazzID  uint32             `json:"_id"`
	Peer     *InputPhoneCall    `json:"peer"`
	GB       []byte             `json:"g_b"`
	Protocol *PhoneCallProtocol `json:"protocol"`
}

func (m *TLPhoneAcceptCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneAcceptCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3bd2b4a0: func() error {
			x.PutClazzID(0x3bd2b4a0)

			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.GB)
			_ = m.Protocol.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_acceptCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_acceptCall, layer)
	}
}

// Decode <--
func (m *TLPhoneAcceptCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3bd2b4a0: func() (err error) {

			m1 := &InputPhoneCall{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.GB, err = d.Bytes()

			m3 := &PhoneCallProtocol{}
			_ = m3.Decode(d)
			m.Protocol = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneConfirmCall <--
type TLPhoneConfirmCall struct {
	ClazzID        uint32             `json:"_id"`
	Peer           *InputPhoneCall    `json:"peer"`
	GA             []byte             `json:"g_a"`
	KeyFingerprint int64              `json:"key_fingerprint"`
	Protocol       *PhoneCallProtocol `json:"protocol"`
}

func (m *TLPhoneConfirmCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneConfirmCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2efe1722: func() error {
			x.PutClazzID(0x2efe1722)

			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.GA)
			x.PutInt64(m.KeyFingerprint)
			_ = m.Protocol.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_confirmCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_confirmCall, layer)
	}
}

// Decode <--
func (m *TLPhoneConfirmCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2efe1722: func() (err error) {

			m1 := &InputPhoneCall{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.GA, err = d.Bytes()
			m.KeyFingerprint, err = d.Int64()

			m4 := &PhoneCallProtocol{}
			_ = m4.Decode(d)
			m.Protocol = m4

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneReceivedCall <--
type TLPhoneReceivedCall struct {
	ClazzID uint32          `json:"_id"`
	Peer    *InputPhoneCall `json:"peer"`
}

func (m *TLPhoneReceivedCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneReceivedCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x17d54f61: func() error {
			x.PutClazzID(0x17d54f61)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_receivedCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_receivedCall, layer)
	}
}

// Decode <--
func (m *TLPhoneReceivedCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x17d54f61: func() (err error) {

			m1 := &InputPhoneCall{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneDiscardCall <--
type TLPhoneDiscardCall struct {
	ClazzID      uint32                  `json:"_id"`
	Video        bool                    `json:"video"`
	Peer         *InputPhoneCall         `json:"peer"`
	Duration     int32                   `json:"duration"`
	Reason       *PhoneCallDiscardReason `json:"reason"`
	ConnectionId int64                   `json:"connection_id"`
}

func (m *TLPhoneDiscardCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneDiscardCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb2cbc1c0: func() error {
			x.PutClazzID(0xb2cbc1c0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Video == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Duration)
			_ = m.Reason.Encode(x, layer)
			x.PutInt64(m.ConnectionId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_discardCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_discardCall, layer)
	}
}

// Decode <--
func (m *TLPhoneDiscardCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb2cbc1c0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Video = true
			}

			m3 := &InputPhoneCall{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.Duration, err = d.Int32()

			m5 := &PhoneCallDiscardReason{}
			_ = m5.Decode(d)
			m.Reason = m5

			m.ConnectionId, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSetCallRating <--
type TLPhoneSetCallRating struct {
	ClazzID        uint32          `json:"_id"`
	UserInitiative bool            `json:"user_initiative"`
	Peer           *InputPhoneCall `json:"peer"`
	Rating         int32           `json:"rating"`
	Comment        string          `json:"comment"`
}

func (m *TLPhoneSetCallRating) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSetCallRating) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x59ead627: func() error {
			x.PutClazzID(0x59ead627)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.UserInitiative == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Rating)
			x.PutString(m.Comment)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_setCallRating, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_setCallRating, layer)
	}
}

// Decode <--
func (m *TLPhoneSetCallRating) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x59ead627: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.UserInitiative = true
			}

			m3 := &InputPhoneCall{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.Rating, err = d.Int32()
			m.Comment, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSaveCallDebug <--
type TLPhoneSaveCallDebug struct {
	ClazzID uint32          `json:"_id"`
	Peer    *InputPhoneCall `json:"peer"`
	Debug   *DataJSON       `json:"debug"`
}

func (m *TLPhoneSaveCallDebug) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSaveCallDebug) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x277add7e: func() error {
			x.PutClazzID(0x277add7e)

			_ = m.Peer.Encode(x, layer)
			_ = m.Debug.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_saveCallDebug, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_saveCallDebug, layer)
	}
}

// Decode <--
func (m *TLPhoneSaveCallDebug) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x277add7e: func() (err error) {

			m1 := &InputPhoneCall{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &DataJSON{}
			_ = m2.Decode(d)
			m.Debug = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSendSignalingData <--
type TLPhoneSendSignalingData struct {
	ClazzID uint32          `json:"_id"`
	Peer    *InputPhoneCall `json:"peer"`
	Data    []byte          `json:"data"`
}

func (m *TLPhoneSendSignalingData) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSendSignalingData) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xff7a9383: func() error {
			x.PutClazzID(0xff7a9383)

			_ = m.Peer.Encode(x, layer)
			x.PutBytes(m.Data)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_sendSignalingData, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_sendSignalingData, layer)
	}
}

// Decode <--
func (m *TLPhoneSendSignalingData) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xff7a9383: func() (err error) {

			m1 := &InputPhoneCall{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Data, err = d.Bytes()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneCreateGroupCall <--
type TLPhoneCreateGroupCall struct {
	ClazzID      uint32     `json:"_id"`
	RtmpStream   bool       `json:"rtmp_stream"`
	Peer         *InputPeer `json:"peer"`
	RandomId     int32      `json:"random_id"`
	Title        *string    `json:"title"`
	ScheduleDate *int32     `json:"schedule_date"`
}

func (m *TLPhoneCreateGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneCreateGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x48cdc6d8: func() error {
			x.PutClazzID(0x48cdc6d8)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.RtmpStream == true {
					flags |= 1 << 2
				}

				if m.Title != nil {
					flags |= 1 << 0
				}
				if m.ScheduleDate != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.RandomId)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.ScheduleDate != nil {
				x.PutInt32(*m.ScheduleDate)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_createGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_createGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneCreateGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x48cdc6d8: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m.RtmpStream = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.RandomId, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.ScheduleDate = new(int32)
				*m.ScheduleDate, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneJoinGroupCall <--
type TLPhoneJoinGroupCall struct {
	ClazzID        uint32          `json:"_id"`
	Muted          bool            `json:"muted"`
	VideoStopped   bool            `json:"video_stopped"`
	Call           *InputGroupCall `json:"call"`
	JoinAs         *InputPeer      `json:"join_as"`
	InviteHash     *string         `json:"invite_hash"`
	KeyFingerprint *int64          `json:"key_fingerprint"`
	Params         *DataJSON       `json:"params"`
}

func (m *TLPhoneJoinGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneJoinGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd61e1df3: func() error {
			x.PutClazzID(0xd61e1df3)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Muted == true {
					flags |= 1 << 0
				}
				if m.VideoStopped == true {
					flags |= 1 << 2
				}

				if m.InviteHash != nil {
					flags |= 1 << 1
				}
				if m.KeyFingerprint != nil {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)
			_ = m.JoinAs.Encode(x, layer)
			if m.InviteHash != nil {
				x.PutString(*m.InviteHash)
			}

			if m.KeyFingerprint != nil {
				x.PutInt64(*m.KeyFingerprint)
			}

			_ = m.Params.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_joinGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_joinGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneJoinGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd61e1df3: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Muted = true
			}
			if (flags & (1 << 2)) != 0 {
				m.VideoStopped = true
			}

			m4 := &InputGroupCall{}
			_ = m4.Decode(d)
			m.Call = m4

			m5 := &InputPeer{}
			_ = m5.Decode(d)
			m.JoinAs = m5

			if (flags & (1 << 1)) != 0 {
				m.InviteHash = new(string)
				*m.InviteHash, err = d.String()
			}

			if (flags & (1 << 3)) != 0 {
				m.KeyFingerprint = new(int64)
				*m.KeyFingerprint, err = d.Int64()
			}

			m8 := &DataJSON{}
			_ = m8.Decode(d)
			m.Params = m8

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneLeaveGroupCall <--
type TLPhoneLeaveGroupCall struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
	Source  int32           `json:"source"`
}

func (m *TLPhoneLeaveGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneLeaveGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x500377f9: func() error {
			x.PutClazzID(0x500377f9)

			_ = m.Call.Encode(x, layer)
			x.PutInt32(m.Source)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_leaveGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_leaveGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneLeaveGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x500377f9: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			m.Source, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneInviteToGroupCall <--
type TLPhoneInviteToGroupCall struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
	Users   []*InputUser    `json:"users"`
}

func (m *TLPhoneInviteToGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneInviteToGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7b393160: func() error {
			x.PutClazzID(0x7b393160)

			_ = m.Call.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Users, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_inviteToGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_inviteToGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneInviteToGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7b393160: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputUser, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputUser)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Users = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneDiscardGroupCall <--
type TLPhoneDiscardGroupCall struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
}

func (m *TLPhoneDiscardGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneDiscardGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7a777135: func() error {
			x.PutClazzID(0x7a777135)

			_ = m.Call.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_discardGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_discardGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneDiscardGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7a777135: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneToggleGroupCallSettings <--
type TLPhoneToggleGroupCallSettings struct {
	ClazzID         uint32          `json:"_id"`
	ResetInviteHash bool            `json:"reset_invite_hash"`
	Call            *InputGroupCall `json:"call"`
	JoinMuted       *Bool           `json:"join_muted"`
}

func (m *TLPhoneToggleGroupCallSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneToggleGroupCallSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x74bbb43d: func() error {
			x.PutClazzID(0x74bbb43d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ResetInviteHash == true {
					flags |= 1 << 1
				}

				if m.JoinMuted != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)
			if m.JoinMuted != nil {
				_ = m.JoinMuted.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_toggleGroupCallSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_toggleGroupCallSettings, layer)
	}
}

// Decode <--
func (m *TLPhoneToggleGroupCallSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x74bbb43d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.ResetInviteHash = true
			}

			m3 := &InputGroupCall{}
			_ = m3.Decode(d)
			m.Call = m3

			if (flags & (1 << 0)) != 0 {
				m4 := &Bool{}
				_ = m4.Decode(d)
				m.JoinMuted = m4
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupCall <--
type TLPhoneGetGroupCall struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
	Limit   int32           `json:"limit"`
}

func (m *TLPhoneGetGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x41845db: func() error {
			x.PutClazzID(0x41845db)

			_ = m.Call.Encode(x, layer)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x41845db: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupParticipants <--
type TLPhoneGetGroupParticipants struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
	Ids     []*InputPeer    `json:"ids"`
	Sources []int32         `json:"sources"`
	Offset  string          `json:"offset"`
	Limit   int32           `json:"limit"`
}

func (m *TLPhoneGetGroupParticipants) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupParticipants) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc558d8ab: func() error {
			x.PutClazzID(0xc558d8ab)

			_ = m.Call.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Ids, layer)

			iface.EncodeInt32List(x, m.Sources)

			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupParticipants, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupParticipants, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupParticipants) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc558d8ab: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputPeer, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputPeer)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Ids = v2

			m.Sources, err = iface.DecodeInt32List(d)

			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneCheckGroupCall <--
type TLPhoneCheckGroupCall struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
	Sources []int32         `json:"sources"`
}

func (m *TLPhoneCheckGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneCheckGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb59cf977: func() error {
			x.PutClazzID(0xb59cf977)

			_ = m.Call.Encode(x, layer)

			iface.EncodeInt32List(x, m.Sources)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_checkGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_checkGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneCheckGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb59cf977: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			m.Sources, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneToggleGroupCallRecord <--
type TLPhoneToggleGroupCallRecord struct {
	ClazzID       uint32          `json:"_id"`
	Start         bool            `json:"start"`
	Video         bool            `json:"video"`
	Call          *InputGroupCall `json:"call"`
	Title         *string         `json:"title"`
	VideoPortrait *Bool           `json:"video_portrait"`
}

func (m *TLPhoneToggleGroupCallRecord) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneToggleGroupCallRecord) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf128c708: func() error {
			x.PutClazzID(0xf128c708)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Start == true {
					flags |= 1 << 0
				}
				if m.Video == true {
					flags |= 1 << 2
				}

				if m.Title != nil {
					flags |= 1 << 1
				}
				if m.VideoPortrait != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.VideoPortrait != nil {
				_ = m.VideoPortrait.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_toggleGroupCallRecord, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_toggleGroupCallRecord, layer)
	}
}

// Decode <--
func (m *TLPhoneToggleGroupCallRecord) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf128c708: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Start = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Video = true
			}

			m4 := &InputGroupCall{}
			_ = m4.Decode(d)
			m.Call = m4

			if (flags & (1 << 1)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m6 := &Bool{}
				_ = m6.Decode(d)
				m.VideoPortrait = m6
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneEditGroupCallParticipant <--
type TLPhoneEditGroupCallParticipant struct {
	ClazzID            uint32          `json:"_id"`
	Call               *InputGroupCall `json:"call"`
	Participant        *InputPeer      `json:"participant"`
	Muted              *Bool           `json:"muted"`
	Volume             *int32          `json:"volume"`
	RaiseHand          *Bool           `json:"raise_hand"`
	VideoStopped       *Bool           `json:"video_stopped"`
	VideoPaused        *Bool           `json:"video_paused"`
	PresentationPaused *Bool           `json:"presentation_paused"`
}

func (m *TLPhoneEditGroupCallParticipant) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneEditGroupCallParticipant) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa5273abf: func() error {
			x.PutClazzID(0xa5273abf)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Muted != nil {
					flags |= 1 << 0
				}
				if m.Volume != nil {
					flags |= 1 << 1
				}
				if m.RaiseHand != nil {
					flags |= 1 << 2
				}
				if m.VideoStopped != nil {
					flags |= 1 << 3
				}
				if m.VideoPaused != nil {
					flags |= 1 << 4
				}
				if m.PresentationPaused != nil {
					flags |= 1 << 5
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)
			_ = m.Participant.Encode(x, layer)
			if m.Muted != nil {
				_ = m.Muted.Encode(x, layer)
			}

			if m.Volume != nil {
				x.PutInt32(*m.Volume)
			}

			if m.RaiseHand != nil {
				_ = m.RaiseHand.Encode(x, layer)
			}

			if m.VideoStopped != nil {
				_ = m.VideoStopped.Encode(x, layer)
			}

			if m.VideoPaused != nil {
				_ = m.VideoPaused.Encode(x, layer)
			}

			if m.PresentationPaused != nil {
				_ = m.PresentationPaused.Encode(x, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_editGroupCallParticipant, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_editGroupCallParticipant, layer)
	}
}

// Decode <--
func (m *TLPhoneEditGroupCallParticipant) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa5273abf: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputGroupCall{}
			_ = m2.Decode(d)
			m.Call = m2

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Participant = m3

			if (flags & (1 << 0)) != 0 {
				m4 := &Bool{}
				_ = m4.Decode(d)
				m.Muted = m4
			}
			if (flags & (1 << 1)) != 0 {
				m.Volume = new(int32)
				*m.Volume, err = d.Int32()
			}
			if (flags & (1 << 2)) != 0 {
				m6 := &Bool{}
				_ = m6.Decode(d)
				m.RaiseHand = m6
			}
			if (flags & (1 << 3)) != 0 {
				m7 := &Bool{}
				_ = m7.Decode(d)
				m.VideoStopped = m7
			}
			if (flags & (1 << 4)) != 0 {
				m8 := &Bool{}
				_ = m8.Decode(d)
				m.VideoPaused = m8
			}
			if (flags & (1 << 5)) != 0 {
				m9 := &Bool{}
				_ = m9.Decode(d)
				m.PresentationPaused = m9
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneEditGroupCallTitle <--
type TLPhoneEditGroupCallTitle struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
	Title   string          `json:"title"`
}

func (m *TLPhoneEditGroupCallTitle) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneEditGroupCallTitle) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1ca6ac0a: func() error {
			x.PutClazzID(0x1ca6ac0a)

			_ = m.Call.Encode(x, layer)
			x.PutString(m.Title)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_editGroupCallTitle, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_editGroupCallTitle, layer)
	}
}

// Decode <--
func (m *TLPhoneEditGroupCallTitle) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1ca6ac0a: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			m.Title, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupCallJoinAs <--
type TLPhoneGetGroupCallJoinAs struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLPhoneGetGroupCallJoinAs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupCallJoinAs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xef7c213a: func() error {
			x.PutClazzID(0xef7c213a)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupCallJoinAs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupCallJoinAs, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupCallJoinAs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xef7c213a: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneExportGroupCallInvite <--
type TLPhoneExportGroupCallInvite struct {
	ClazzID       uint32          `json:"_id"`
	CanSelfUnmute bool            `json:"can_self_unmute"`
	Call          *InputGroupCall `json:"call"`
}

func (m *TLPhoneExportGroupCallInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneExportGroupCallInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe6aa647f: func() error {
			x.PutClazzID(0xe6aa647f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.CanSelfUnmute == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Call.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_exportGroupCallInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_exportGroupCallInvite, layer)
	}
}

// Decode <--
func (m *TLPhoneExportGroupCallInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe6aa647f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.CanSelfUnmute = true
			}

			m3 := &InputGroupCall{}
			_ = m3.Decode(d)
			m.Call = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneToggleGroupCallStartSubscription <--
type TLPhoneToggleGroupCallStartSubscription struct {
	ClazzID    uint32          `json:"_id"`
	Call       *InputGroupCall `json:"call"`
	Subscribed *Bool           `json:"subscribed"`
}

func (m *TLPhoneToggleGroupCallStartSubscription) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneToggleGroupCallStartSubscription) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x219c34e6: func() error {
			x.PutClazzID(0x219c34e6)

			_ = m.Call.Encode(x, layer)
			_ = m.Subscribed.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_toggleGroupCallStartSubscription, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_toggleGroupCallStartSubscription, layer)
	}
}

// Decode <--
func (m *TLPhoneToggleGroupCallStartSubscription) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x219c34e6: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Subscribed = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneStartScheduledGroupCall <--
type TLPhoneStartScheduledGroupCall struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
}

func (m *TLPhoneStartScheduledGroupCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneStartScheduledGroupCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5680e342: func() error {
			x.PutClazzID(0x5680e342)

			_ = m.Call.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_startScheduledGroupCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_startScheduledGroupCall, layer)
	}
}

// Decode <--
func (m *TLPhoneStartScheduledGroupCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5680e342: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSaveDefaultGroupCallJoinAs <--
type TLPhoneSaveDefaultGroupCallJoinAs struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	JoinAs  *InputPeer `json:"join_as"`
}

func (m *TLPhoneSaveDefaultGroupCallJoinAs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSaveDefaultGroupCallJoinAs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x575e1f8c: func() error {
			x.PutClazzID(0x575e1f8c)

			_ = m.Peer.Encode(x, layer)
			_ = m.JoinAs.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_saveDefaultGroupCallJoinAs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_saveDefaultGroupCallJoinAs, layer)
	}
}

// Decode <--
func (m *TLPhoneSaveDefaultGroupCallJoinAs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x575e1f8c: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.JoinAs = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneJoinGroupCallPresentation <--
type TLPhoneJoinGroupCallPresentation struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
	Params  *DataJSON       `json:"params"`
}

func (m *TLPhoneJoinGroupCallPresentation) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneJoinGroupCallPresentation) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcbea6bc4: func() error {
			x.PutClazzID(0xcbea6bc4)

			_ = m.Call.Encode(x, layer)
			_ = m.Params.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_joinGroupCallPresentation, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_joinGroupCallPresentation, layer)
	}
}

// Decode <--
func (m *TLPhoneJoinGroupCallPresentation) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcbea6bc4: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			m2 := &DataJSON{}
			_ = m2.Decode(d)
			m.Params = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneLeaveGroupCallPresentation <--
type TLPhoneLeaveGroupCallPresentation struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
}

func (m *TLPhoneLeaveGroupCallPresentation) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneLeaveGroupCallPresentation) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1c50d144: func() error {
			x.PutClazzID(0x1c50d144)

			_ = m.Call.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_leaveGroupCallPresentation, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_leaveGroupCallPresentation, layer)
	}
}

// Decode <--
func (m *TLPhoneLeaveGroupCallPresentation) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1c50d144: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupCallStreamChannels <--
type TLPhoneGetGroupCallStreamChannels struct {
	ClazzID uint32          `json:"_id"`
	Call    *InputGroupCall `json:"call"`
}

func (m *TLPhoneGetGroupCallStreamChannels) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupCallStreamChannels) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x1ab21940: func() error {
			x.PutClazzID(0x1ab21940)

			_ = m.Call.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupCallStreamChannels, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupCallStreamChannels, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupCallStreamChannels) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x1ab21940: func() (err error) {

			m1 := &InputGroupCall{}
			_ = m1.Decode(d)
			m.Call = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneGetGroupCallStreamRtmpUrl <--
type TLPhoneGetGroupCallStreamRtmpUrl struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Revoke  *Bool      `json:"revoke"`
}

func (m *TLPhoneGetGroupCallStreamRtmpUrl) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneGetGroupCallStreamRtmpUrl) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdeb3abbf: func() error {
			x.PutClazzID(0xdeb3abbf)

			_ = m.Peer.Encode(x, layer)
			_ = m.Revoke.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_getGroupCallStreamRtmpUrl, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_getGroupCallStreamRtmpUrl, layer)
	}
}

// Decode <--
func (m *TLPhoneGetGroupCallStreamRtmpUrl) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdeb3abbf: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Revoke = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneSaveCallLog <--
type TLPhoneSaveCallLog struct {
	ClazzID uint32          `json:"_id"`
	Peer    *InputPhoneCall `json:"peer"`
	File    *InputFile      `json:"file"`
}

func (m *TLPhoneSaveCallLog) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneSaveCallLog) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x41248786: func() error {
			x.PutClazzID(0x41248786)

			_ = m.Peer.Encode(x, layer)
			_ = m.File.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_saveCallLog, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_saveCallLog, layer)
	}
}

// Decode <--
func (m *TLPhoneSaveCallLog) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x41248786: func() (err error) {

			m1 := &InputPhoneCall{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputFile{}
			_ = m2.Decode(d)
			m.File = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPhoneCreateConferenceCall <--
type TLPhoneCreateConferenceCall struct {
	ClazzID        uint32          `json:"_id"`
	Peer           *InputPhoneCall `json:"peer"`
	KeyFingerprint int64           `json:"key_fingerprint"`
}

func (m *TLPhoneCreateConferenceCall) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPhoneCreateConferenceCall) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdfc909ab: func() error {
			x.PutClazzID(0xdfc909ab)

			_ = m.Peer.Encode(x, layer)
			x.PutInt64(m.KeyFingerprint)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_phone_createConferenceCall, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_phone_createConferenceCall, layer)
	}
}

// Decode <--
func (m *TLPhoneCreateConferenceCall) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdfc909ab: func() (err error) {

			m1 := &InputPhoneCall{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.KeyFingerprint, err = d.Int64()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLLangpackGetLangPack <--
type TLLangpackGetLangPack struct {
	ClazzID  uint32 `json:"_id"`
	LangPack string `json:"lang_pack"`
	LangCode string `json:"lang_code"`
}

func (m *TLLangpackGetLangPack) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLLangpackGetLangPack) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf2f2330a: func() error {
			x.PutClazzID(0xf2f2330a)

			x.PutString(m.LangPack)
			x.PutString(m.LangCode)

			return nil
		},
		0x9ab5c58e: func() error {
			x.PutClazzID(0x9ab5c58e)

			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_langpack_getLangPack, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_langpack_getLangPack, layer)
	}
}

// Decode <--
func (m *TLLangpackGetLangPack) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf2f2330a: func() (err error) {
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()

			return nil
		},
		0x9ab5c58e: func() (err error) {
			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLLangpackGetStrings <--
type TLLangpackGetStrings struct {
	ClazzID  uint32   `json:"_id"`
	LangPack string   `json:"lang_pack"`
	LangCode string   `json:"lang_code"`
	Keys     []string `json:"keys"`
}

func (m *TLLangpackGetStrings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLLangpackGetStrings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xefea3803: func() error {
			x.PutClazzID(0xefea3803)

			x.PutString(m.LangPack)
			x.PutString(m.LangCode)

			iface.EncodeStringList(x, m.Keys)

			return nil
		},
		0x2e1ee318: func() error {
			x.PutClazzID(0x2e1ee318)

			x.PutString(m.LangCode)

			iface.EncodeStringList(x, m.Keys)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_langpack_getStrings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_langpack_getStrings, layer)
	}
}

// Decode <--
func (m *TLLangpackGetStrings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xefea3803: func() (err error) {
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()

			m.Keys, err = iface.DecodeStringList(d)

			return nil
		},
		0x2e1ee318: func() (err error) {
			m.LangCode, err = d.String()

			m.Keys, err = iface.DecodeStringList(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLLangpackGetDifference <--
type TLLangpackGetDifference struct {
	ClazzID     uint32 `json:"_id"`
	LangPack    string `json:"lang_pack"`
	LangCode    string `json:"lang_code"`
	FromVersion int32  `json:"from_version"`
}

func (m *TLLangpackGetDifference) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLLangpackGetDifference) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xcd984aa5: func() error {
			x.PutClazzID(0xcd984aa5)

			x.PutString(m.LangPack)
			x.PutString(m.LangCode)
			x.PutInt32(m.FromVersion)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_langpack_getDifference, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_langpack_getDifference, layer)
	}
}

// Decode <--
func (m *TLLangpackGetDifference) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xcd984aa5: func() (err error) {
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()
			m.FromVersion, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLLangpackGetLanguages <--
type TLLangpackGetLanguages struct {
	ClazzID  uint32 `json:"_id"`
	LangPack string `json:"lang_pack"`
}

func (m *TLLangpackGetLanguages) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLLangpackGetLanguages) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x42c6978f: func() error {
			x.PutClazzID(0x42c6978f)

			x.PutString(m.LangPack)

			return nil
		},
		0x800fd57d: func() error {
			x.PutClazzID(0x800fd57d)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_langpack_getLanguages, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_langpack_getLanguages, layer)
	}
}

// Decode <--
func (m *TLLangpackGetLanguages) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x42c6978f: func() (err error) {
			m.LangPack, err = d.String()

			return nil
		},
		0x800fd57d: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLLangpackGetLanguage <--
type TLLangpackGetLanguage struct {
	ClazzID  uint32 `json:"_id"`
	LangPack string `json:"lang_pack"`
	LangCode string `json:"lang_code"`
}

func (m *TLLangpackGetLanguage) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLLangpackGetLanguage) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6a596502: func() error {
			x.PutClazzID(0x6a596502)

			x.PutString(m.LangPack)
			x.PutString(m.LangCode)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_langpack_getLanguage, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_langpack_getLanguage, layer)
	}
}

// Decode <--
func (m *TLLangpackGetLanguage) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6a596502: func() (err error) {
			m.LangPack, err = d.String()
			m.LangCode, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLFoldersEditPeerFolders <--
type TLFoldersEditPeerFolders struct {
	ClazzID     uint32             `json:"_id"`
	FolderPeers []*InputFolderPeer `json:"folder_peers"`
}

func (m *TLFoldersEditPeerFolders) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLFoldersEditPeerFolders) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6847d0ab: func() error {
			x.PutClazzID(0x6847d0ab)

			_ = iface.EncodeObjectList(x, m.FolderPeers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_folders_editPeerFolders, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_folders_editPeerFolders, layer)
	}
}

// Decode <--
func (m *TLFoldersEditPeerFolders) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6847d0ab: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputFolderPeer, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputFolderPeer)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.FolderPeers = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetBroadcastStats <--
type TLStatsGetBroadcastStats struct {
	ClazzID uint32        `json:"_id"`
	Dark    bool          `json:"dark"`
	Channel *InputChannel `json:"channel"`
}

func (m *TLStatsGetBroadcastStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetBroadcastStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xab42441a: func() error {
			x.PutClazzID(0xab42441a)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getBroadcastStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getBroadcastStats, layer)
	}
}

// Decode <--
func (m *TLStatsGetBroadcastStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xab42441a: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}

			m3 := &InputChannel{}
			_ = m3.Decode(d)
			m.Channel = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsLoadAsyncGraph <--
type TLStatsLoadAsyncGraph struct {
	ClazzID uint32 `json:"_id"`
	Token   string `json:"token"`
	X       *int64 `json:"x"`
}

func (m *TLStatsLoadAsyncGraph) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsLoadAsyncGraph) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x621d5fa0: func() error {
			x.PutClazzID(0x621d5fa0)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.X != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Token)
			if m.X != nil {
				x.PutInt64(*m.X)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_loadAsyncGraph, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_loadAsyncGraph, layer)
	}
}

// Decode <--
func (m *TLStatsLoadAsyncGraph) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x621d5fa0: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Token, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.X = new(int64)
				*m.X, err = d.Int64()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetMegagroupStats <--
type TLStatsGetMegagroupStats struct {
	ClazzID uint32        `json:"_id"`
	Dark    bool          `json:"dark"`
	Channel *InputChannel `json:"channel"`
}

func (m *TLStatsGetMegagroupStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetMegagroupStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xdcdf8607: func() error {
			x.PutClazzID(0xdcdf8607)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getMegagroupStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getMegagroupStats, layer)
	}
}

// Decode <--
func (m *TLStatsGetMegagroupStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xdcdf8607: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}

			m3 := &InputChannel{}
			_ = m3.Decode(d)
			m.Channel = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetMessagePublicForwards <--
type TLStatsGetMessagePublicForwards struct {
	ClazzID uint32        `json:"_id"`
	Channel *InputChannel `json:"channel"`
	MsgId   int32         `json:"msg_id"`
	Offset  string        `json:"offset"`
	Limit   int32         `json:"limit"`
}

func (m *TLStatsGetMessagePublicForwards) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetMessagePublicForwards) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5f150144: func() error {
			x.PutClazzID(0x5f150144)

			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.MsgId)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getMessagePublicForwards, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getMessagePublicForwards, layer)
	}
}

// Decode <--
func (m *TLStatsGetMessagePublicForwards) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5f150144: func() (err error) {

			m1 := &InputChannel{}
			_ = m1.Decode(d)
			m.Channel = m1

			m.MsgId, err = d.Int32()
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetMessageStats <--
type TLStatsGetMessageStats struct {
	ClazzID uint32        `json:"_id"`
	Dark    bool          `json:"dark"`
	Channel *InputChannel `json:"channel"`
	MsgId   int32         `json:"msg_id"`
}

func (m *TLStatsGetMessageStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetMessageStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb6e0a3f5: func() error {
			x.PutClazzID(0xb6e0a3f5)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Channel.Encode(x, layer)
			x.PutInt32(m.MsgId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getMessageStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getMessageStats, layer)
	}
}

// Decode <--
func (m *TLStatsGetMessageStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb6e0a3f5: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}

			m3 := &InputChannel{}
			_ = m3.Decode(d)
			m.Channel = m3

			m.MsgId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetStoryStats <--
type TLStatsGetStoryStats struct {
	ClazzID uint32     `json:"_id"`
	Dark    bool       `json:"dark"`
	Peer    *InputPeer `json:"peer"`
	Id      int32      `json:"id"`
}

func (m *TLStatsGetStoryStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetStoryStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x374fef40: func() error {
			x.PutClazzID(0x374fef40)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getStoryStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getStoryStats, layer)
	}
}

// Decode <--
func (m *TLStatsGetStoryStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x374fef40: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetStoryPublicForwards <--
type TLStatsGetStoryPublicForwards struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      int32      `json:"id"`
	Offset  string     `json:"offset"`
	Limit   int32      `json:"limit"`
}

func (m *TLStatsGetStoryPublicForwards) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetStoryPublicForwards) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa6437ef6: func() error {
			x.PutClazzID(0xa6437ef6)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getStoryPublicForwards, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getStoryPublicForwards, layer)
	}
}

// Decode <--
func (m *TLStatsGetStoryPublicForwards) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa6437ef6: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = d.Int32()
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetBroadcastRevenueStats <--
type TLStatsGetBroadcastRevenueStats struct {
	ClazzID uint32     `json:"_id"`
	Dark    bool       `json:"dark"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLStatsGetBroadcastRevenueStats) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetBroadcastRevenueStats) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xf788ee19: func() error {
			x.PutClazzID(0xf788ee19)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Dark == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getBroadcastRevenueStats, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getBroadcastRevenueStats, layer)
	}
}

// Decode <--
func (m *TLStatsGetBroadcastRevenueStats) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xf788ee19: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Dark = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetBroadcastRevenueWithdrawalUrl <--
type TLStatsGetBroadcastRevenueWithdrawalUrl struct {
	ClazzID  uint32                 `json:"_id"`
	Peer     *InputPeer             `json:"peer"`
	Password *InputCheckPasswordSRP `json:"password"`
}

func (m *TLStatsGetBroadcastRevenueWithdrawalUrl) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetBroadcastRevenueWithdrawalUrl) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9df4faad: func() error {
			x.PutClazzID(0x9df4faad)

			_ = m.Peer.Encode(x, layer)
			_ = m.Password.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getBroadcastRevenueWithdrawalUrl, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getBroadcastRevenueWithdrawalUrl, layer)
	}
}

// Decode <--
func (m *TLStatsGetBroadcastRevenueWithdrawalUrl) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9df4faad: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputCheckPasswordSRP{}
			_ = m2.Decode(d)
			m.Password = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStatsGetBroadcastRevenueTransactions <--
type TLStatsGetBroadcastRevenueTransactions struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Offset  int32      `json:"offset"`
	Limit   int32      `json:"limit"`
}

func (m *TLStatsGetBroadcastRevenueTransactions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStatsGetBroadcastRevenueTransactions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x70990b6d: func() error {
			x.PutClazzID(0x70990b6d)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stats_getBroadcastRevenueTransactions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stats_getBroadcastRevenueTransactions, layer)
	}
}

// Decode <--
func (m *TLStatsGetBroadcastRevenueTransactions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x70990b6d: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Offset, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsExportChatlistInvite <--
type TLChatlistsExportChatlistInvite struct {
	ClazzID  uint32         `json:"_id"`
	Chatlist *InputChatlist `json:"chatlist"`
	Title    string         `json:"title"`
	Peers    []*InputPeer   `json:"peers"`
}

func (m *TLChatlistsExportChatlistInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsExportChatlistInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x8472478e: func() error {
			x.PutClazzID(0x8472478e)

			_ = m.Chatlist.Encode(x, layer)
			x.PutString(m.Title)

			_ = iface.EncodeObjectList(x, m.Peers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_exportChatlistInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_exportChatlistInvite, layer)
	}
}

// Decode <--
func (m *TLChatlistsExportChatlistInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x8472478e: func() (err error) {

			m1 := &InputChatlist{}
			_ = m1.Decode(d)
			m.Chatlist = m1

			m.Title, err = d.String()
			c3, err2 := d.ClazzID()
			if c3 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 3, c3)
				return err2
			}
			l3, err3 := d.Int()
			v3 := make([]*InputPeer, l3)
			for i := 0; i < l3; i++ {
				vv := new(InputPeer)
				err3 = vv.Decode(d)
				_ = err3
				v3[i] = vv
			}
			m.Peers = v3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsDeleteExportedInvite <--
type TLChatlistsDeleteExportedInvite struct {
	ClazzID  uint32         `json:"_id"`
	Chatlist *InputChatlist `json:"chatlist"`
	Slug     string         `json:"slug"`
}

func (m *TLChatlistsDeleteExportedInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsDeleteExportedInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x719c5c5e: func() error {
			x.PutClazzID(0x719c5c5e)

			_ = m.Chatlist.Encode(x, layer)
			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_deleteExportedInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_deleteExportedInvite, layer)
	}
}

// Decode <--
func (m *TLChatlistsDeleteExportedInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x719c5c5e: func() (err error) {

			m1 := &InputChatlist{}
			_ = m1.Decode(d)
			m.Chatlist = m1

			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsEditExportedInvite <--
type TLChatlistsEditExportedInvite struct {
	ClazzID  uint32         `json:"_id"`
	Chatlist *InputChatlist `json:"chatlist"`
	Slug     string         `json:"slug"`
	Title    *string        `json:"title"`
	Peers    []*InputPeer   `json:"peers"`
}

func (m *TLChatlistsEditExportedInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsEditExportedInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x653db63d: func() error {
			x.PutClazzID(0x653db63d)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Title != nil {
					flags |= 1 << 1
				}
				if m.Peers != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Chatlist.Encode(x, layer)
			x.PutString(m.Slug)
			if m.Title != nil {
				x.PutString(*m.Title)
			}

			if m.Peers != nil {
				_ = iface.EncodeObjectList(x, m.Peers, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_editExportedInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_editExportedInvite, layer)
	}
}

// Decode <--
func (m *TLChatlistsEditExportedInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x653db63d: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputChatlist{}
			_ = m2.Decode(d)
			m.Chatlist = m2

			m.Slug, err = d.String()
			if (flags & (1 << 1)) != 0 {
				m.Title = new(string)
				*m.Title, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				c5, err2 := d.ClazzID()
				if c5 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
					return err2
				}
				l5, err3 := d.Int()
				v5 := make([]*InputPeer, l5)
				for i := 0; i < l5; i++ {
					vv := new(InputPeer)
					err3 = vv.Decode(d)
					_ = err3
					v5[i] = vv
				}
				m.Peers = v5
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsGetExportedInvites <--
type TLChatlistsGetExportedInvites struct {
	ClazzID  uint32         `json:"_id"`
	Chatlist *InputChatlist `json:"chatlist"`
}

func (m *TLChatlistsGetExportedInvites) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsGetExportedInvites) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xce03da83: func() error {
			x.PutClazzID(0xce03da83)

			_ = m.Chatlist.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_getExportedInvites, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_getExportedInvites, layer)
	}
}

// Decode <--
func (m *TLChatlistsGetExportedInvites) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xce03da83: func() (err error) {

			m1 := &InputChatlist{}
			_ = m1.Decode(d)
			m.Chatlist = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsCheckChatlistInvite <--
type TLChatlistsCheckChatlistInvite struct {
	ClazzID uint32 `json:"_id"`
	Slug    string `json:"slug"`
}

func (m *TLChatlistsCheckChatlistInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsCheckChatlistInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x41c10fff: func() error {
			x.PutClazzID(0x41c10fff)

			x.PutString(m.Slug)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_checkChatlistInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_checkChatlistInvite, layer)
	}
}

// Decode <--
func (m *TLChatlistsCheckChatlistInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x41c10fff: func() (err error) {
			m.Slug, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsJoinChatlistInvite <--
type TLChatlistsJoinChatlistInvite struct {
	ClazzID uint32       `json:"_id"`
	Slug    string       `json:"slug"`
	Peers   []*InputPeer `json:"peers"`
}

func (m *TLChatlistsJoinChatlistInvite) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsJoinChatlistInvite) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa6b1e39a: func() error {
			x.PutClazzID(0xa6b1e39a)

			x.PutString(m.Slug)

			_ = iface.EncodeObjectList(x, m.Peers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_joinChatlistInvite, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_joinChatlistInvite, layer)
	}
}

// Decode <--
func (m *TLChatlistsJoinChatlistInvite) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa6b1e39a: func() (err error) {
			m.Slug, err = d.String()
			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputPeer, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputPeer)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Peers = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsGetChatlistUpdates <--
type TLChatlistsGetChatlistUpdates struct {
	ClazzID  uint32         `json:"_id"`
	Chatlist *InputChatlist `json:"chatlist"`
}

func (m *TLChatlistsGetChatlistUpdates) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsGetChatlistUpdates) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x89419521: func() error {
			x.PutClazzID(0x89419521)

			_ = m.Chatlist.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_getChatlistUpdates, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_getChatlistUpdates, layer)
	}
}

// Decode <--
func (m *TLChatlistsGetChatlistUpdates) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x89419521: func() (err error) {

			m1 := &InputChatlist{}
			_ = m1.Decode(d)
			m.Chatlist = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsJoinChatlistUpdates <--
type TLChatlistsJoinChatlistUpdates struct {
	ClazzID  uint32         `json:"_id"`
	Chatlist *InputChatlist `json:"chatlist"`
	Peers    []*InputPeer   `json:"peers"`
}

func (m *TLChatlistsJoinChatlistUpdates) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsJoinChatlistUpdates) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe089f8f5: func() error {
			x.PutClazzID(0xe089f8f5)

			_ = m.Chatlist.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Peers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_joinChatlistUpdates, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_joinChatlistUpdates, layer)
	}
}

// Decode <--
func (m *TLChatlistsJoinChatlistUpdates) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe089f8f5: func() (err error) {

			m1 := &InputChatlist{}
			_ = m1.Decode(d)
			m.Chatlist = m1

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputPeer, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputPeer)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Peers = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsHideChatlistUpdates <--
type TLChatlistsHideChatlistUpdates struct {
	ClazzID  uint32         `json:"_id"`
	Chatlist *InputChatlist `json:"chatlist"`
}

func (m *TLChatlistsHideChatlistUpdates) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsHideChatlistUpdates) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x66e486fb: func() error {
			x.PutClazzID(0x66e486fb)

			_ = m.Chatlist.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_hideChatlistUpdates, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_hideChatlistUpdates, layer)
	}
}

// Decode <--
func (m *TLChatlistsHideChatlistUpdates) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x66e486fb: func() (err error) {

			m1 := &InputChatlist{}
			_ = m1.Decode(d)
			m.Chatlist = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsGetLeaveChatlistSuggestions <--
type TLChatlistsGetLeaveChatlistSuggestions struct {
	ClazzID  uint32         `json:"_id"`
	Chatlist *InputChatlist `json:"chatlist"`
}

func (m *TLChatlistsGetLeaveChatlistSuggestions) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsGetLeaveChatlistSuggestions) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xfdbcd714: func() error {
			x.PutClazzID(0xfdbcd714)

			_ = m.Chatlist.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_getLeaveChatlistSuggestions, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_getLeaveChatlistSuggestions, layer)
	}
}

// Decode <--
func (m *TLChatlistsGetLeaveChatlistSuggestions) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xfdbcd714: func() (err error) {

			m1 := &InputChatlist{}
			_ = m1.Decode(d)
			m.Chatlist = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLChatlistsLeaveChatlist <--
type TLChatlistsLeaveChatlist struct {
	ClazzID  uint32         `json:"_id"`
	Chatlist *InputChatlist `json:"chatlist"`
	Peers    []*InputPeer   `json:"peers"`
}

func (m *TLChatlistsLeaveChatlist) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLChatlistsLeaveChatlist) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x74fae13a: func() error {
			x.PutClazzID(0x74fae13a)

			_ = m.Chatlist.Encode(x, layer)

			_ = iface.EncodeObjectList(x, m.Peers, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_chatlists_leaveChatlist, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_chatlists_leaveChatlist, layer)
	}
}

// Decode <--
func (m *TLChatlistsLeaveChatlist) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x74fae13a: func() (err error) {

			m1 := &InputChatlist{}
			_ = m1.Decode(d)
			m.Chatlist = m1

			c2, err2 := d.ClazzID()
			if c2 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 2, c2)
				return err2
			}
			l2, err3 := d.Int()
			v2 := make([]*InputPeer, l2)
			for i := 0; i < l2; i++ {
				vv := new(InputPeer)
				err3 = vv.Decode(d)
				_ = err3
				v2[i] = vv
			}
			m.Peers = v2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesCanSendStory <--
type TLStoriesCanSendStory struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLStoriesCanSendStory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesCanSendStory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xc7dfdfdd: func() error {
			x.PutClazzID(0xc7dfdfdd)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_canSendStory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_canSendStory, layer)
	}
}

// Decode <--
func (m *TLStoriesCanSendStory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xc7dfdfdd: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesSendStory <--
type TLStoriesSendStory struct {
	ClazzID      uint32              `json:"_id"`
	Pinned       bool                `json:"pinned"`
	Noforwards   bool                `json:"noforwards"`
	FwdModified  bool                `json:"fwd_modified"`
	Peer         *InputPeer          `json:"peer"`
	Media        *InputMedia         `json:"media"`
	MediaAreas   []*MediaArea        `json:"media_areas"`
	Caption      *string             `json:"caption"`
	Entities     []*MessageEntity    `json:"entities"`
	PrivacyRules []*InputPrivacyRule `json:"privacy_rules"`
	RandomId     int64               `json:"random_id"`
	Period       *int32              `json:"period"`
	FwdFromId    *InputPeer          `json:"fwd_from_id"`
	FwdFromStory *int32              `json:"fwd_from_story"`
}

func (m *TLStoriesSendStory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesSendStory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe4e6694b: func() error {
			x.PutClazzID(0xe4e6694b)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Pinned == true {
					flags |= 1 << 2
				}
				if m.Noforwards == true {
					flags |= 1 << 4
				}
				if m.FwdModified == true {
					flags |= 1 << 7
				}

				if m.MediaAreas != nil {
					flags |= 1 << 5
				}
				if m.Caption != nil {
					flags |= 1 << 0
				}
				if m.Entities != nil {
					flags |= 1 << 1
				}

				if m.Period != nil {
					flags |= 1 << 3
				}
				if m.FwdFromId != nil {
					flags |= 1 << 6
				}
				if m.FwdFromStory != nil {
					flags |= 1 << 6
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			_ = m.Media.Encode(x, layer)
			if m.MediaAreas != nil {
				_ = iface.EncodeObjectList(x, m.MediaAreas, layer)
			}
			if m.Caption != nil {
				x.PutString(*m.Caption)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}

			_ = iface.EncodeObjectList(x, m.PrivacyRules, layer)

			x.PutInt64(m.RandomId)
			if m.Period != nil {
				x.PutInt32(*m.Period)
			}

			if m.FwdFromId != nil {
				_ = m.FwdFromId.Encode(x, layer)
			}

			if m.FwdFromStory != nil {
				x.PutInt32(*m.FwdFromStory)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_sendStory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_sendStory, layer)
	}
}

// Decode <--
func (m *TLStoriesSendStory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe4e6694b: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m.Pinned = true
			}
			if (flags & (1 << 4)) != 0 {
				m.Noforwards = true
			}
			if (flags & (1 << 7)) != 0 {
				m.FwdModified = true
			}

			m5 := &InputPeer{}
			_ = m5.Decode(d)
			m.Peer = m5

			m6 := &InputMedia{}
			_ = m6.Decode(d)
			m.Media = m6

			if (flags & (1 << 5)) != 0 {
				c7, err2 := d.ClazzID()
				if c7 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 7, c7)
					return err2
				}
				l7, err3 := d.Int()
				v7 := make([]*MediaArea, l7)
				for i := 0; i < l7; i++ {
					vv := new(MediaArea)
					err3 = vv.Decode(d)
					_ = err3
					v7[i] = vv
				}
				m.MediaAreas = v7
			}
			if (flags & (1 << 0)) != 0 {
				m.Caption = new(string)
				*m.Caption, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				c9, err2 := d.ClazzID()
				if c9 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 9, c9)
					return err2
				}
				l9, err3 := d.Int()
				v9 := make([]*MessageEntity, l9)
				for i := 0; i < l9; i++ {
					vv := new(MessageEntity)
					err3 = vv.Decode(d)
					_ = err3
					v9[i] = vv
				}
				m.Entities = v9
			}
			c10, err2 := d.ClazzID()
			if c10 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 10, c10)
				return err2
			}
			l10, err3 := d.Int()
			v10 := make([]*InputPrivacyRule, l10)
			for i := 0; i < l10; i++ {
				vv := new(InputPrivacyRule)
				err3 = vv.Decode(d)
				_ = err3
				v10[i] = vv
			}
			m.PrivacyRules = v10

			m.RandomId, err = d.Int64()
			if (flags & (1 << 3)) != 0 {
				m.Period = new(int32)
				*m.Period, err = d.Int32()
			}
			if (flags & (1 << 6)) != 0 {
				m13 := &InputPeer{}
				_ = m13.Decode(d)
				m.FwdFromId = m13
			}
			if (flags & (1 << 6)) != 0 {
				m.FwdFromStory = new(int32)
				*m.FwdFromStory, err = d.Int32()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesEditStory <--
type TLStoriesEditStory struct {
	ClazzID      uint32              `json:"_id"`
	Peer         *InputPeer          `json:"peer"`
	Id           int32               `json:"id"`
	Media        *InputMedia         `json:"media"`
	MediaAreas   []*MediaArea        `json:"media_areas"`
	Caption      *string             `json:"caption"`
	Entities     []*MessageEntity    `json:"entities"`
	PrivacyRules []*InputPrivacyRule `json:"privacy_rules"`
}

func (m *TLStoriesEditStory) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesEditStory) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb583ba46: func() error {
			x.PutClazzID(0xb583ba46)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Media != nil {
					flags |= 1 << 0
				}
				if m.MediaAreas != nil {
					flags |= 1 << 3
				}
				if m.Caption != nil {
					flags |= 1 << 1
				}
				if m.Entities != nil {
					flags |= 1 << 1
				}
				if m.PrivacyRules != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			if m.Media != nil {
				_ = m.Media.Encode(x, layer)
			}

			if m.MediaAreas != nil {
				_ = iface.EncodeObjectList(x, m.MediaAreas, layer)
			}
			if m.Caption != nil {
				x.PutString(*m.Caption)
			}

			if m.Entities != nil {
				_ = iface.EncodeObjectList(x, m.Entities, layer)
			}
			if m.PrivacyRules != nil {
				_ = iface.EncodeObjectList(x, m.PrivacyRules, layer)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_editStory, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_editStory, layer)
	}
}

// Decode <--
func (m *TLStoriesEditStory) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb583ba46: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags

			m2 := &InputPeer{}
			_ = m2.Decode(d)
			m.Peer = m2

			m.Id, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m4 := &InputMedia{}
				_ = m4.Decode(d)
				m.Media = m4
			}
			if (flags & (1 << 3)) != 0 {
				c5, err2 := d.ClazzID()
				if c5 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 5, c5)
					return err2
				}
				l5, err3 := d.Int()
				v5 := make([]*MediaArea, l5)
				for i := 0; i < l5; i++ {
					vv := new(MediaArea)
					err3 = vv.Decode(d)
					_ = err3
					v5[i] = vv
				}
				m.MediaAreas = v5
			}
			if (flags & (1 << 1)) != 0 {
				m.Caption = new(string)
				*m.Caption, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				c7, err2 := d.ClazzID()
				if c7 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 7, c7)
					return err2
				}
				l7, err3 := d.Int()
				v7 := make([]*MessageEntity, l7)
				for i := 0; i < l7; i++ {
					vv := new(MessageEntity)
					err3 = vv.Decode(d)
					_ = err3
					v7[i] = vv
				}
				m.Entities = v7
			}
			if (flags & (1 << 2)) != 0 {
				c8, err2 := d.ClazzID()
				if c8 != iface.ClazzID_vector {
					// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 8, c8)
					return err2
				}
				l8, err3 := d.Int()
				v8 := make([]*InputPrivacyRule, l8)
				for i := 0; i < l8; i++ {
					vv := new(InputPrivacyRule)
					err3 = vv.Decode(d)
					_ = err3
					v8[i] = vv
				}
				m.PrivacyRules = v8
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesDeleteStories <--
type TLStoriesDeleteStories struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLStoriesDeleteStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesDeleteStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xae59db5f: func() error {
			x.PutClazzID(0xae59db5f)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_deleteStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_deleteStories, layer)
	}
}

// Decode <--
func (m *TLStoriesDeleteStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xae59db5f: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesTogglePinned <--
type TLStoriesTogglePinned struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
	Pinned  *Bool      `json:"pinned"`
}

func (m *TLStoriesTogglePinned) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesTogglePinned) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9a75a1ef: func() error {
			x.PutClazzID(0x9a75a1ef)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			_ = m.Pinned.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_togglePinned, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_togglePinned, layer)
	}
}

// Decode <--
func (m *TLStoriesTogglePinned) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9a75a1ef: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			m3 := &Bool{}
			_ = m3.Decode(d)
			m.Pinned = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetAllStories <--
type TLStoriesGetAllStories struct {
	ClazzID uint32  `json:"_id"`
	Next    bool    `json:"next"`
	Hidden  bool    `json:"hidden"`
	State   *string `json:"state"`
}

func (m *TLStoriesGetAllStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetAllStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xeeb0d625: func() error {
			x.PutClazzID(0xeeb0d625)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Next == true {
					flags |= 1 << 1
				}
				if m.Hidden == true {
					flags |= 1 << 2
				}
				if m.State != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.State != nil {
				x.PutString(*m.State)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getAllStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getAllStories, layer)
	}
}

// Decode <--
func (m *TLStoriesGetAllStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xeeb0d625: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 1)) != 0 {
				m.Next = true
			}
			if (flags & (1 << 2)) != 0 {
				m.Hidden = true
			}
			if (flags & (1 << 0)) != 0 {
				m.State = new(string)
				*m.State, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetPinnedStories <--
type TLStoriesGetPinnedStories struct {
	ClazzID  uint32     `json:"_id"`
	Peer     *InputPeer `json:"peer"`
	OffsetId int32      `json:"offset_id"`
	Limit    int32      `json:"limit"`
}

func (m *TLStoriesGetPinnedStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetPinnedStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5821a5dc: func() error {
			x.PutClazzID(0x5821a5dc)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getPinnedStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getPinnedStories, layer)
	}
}

// Decode <--
func (m *TLStoriesGetPinnedStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5821a5dc: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.OffsetId, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetStoriesArchive <--
type TLStoriesGetStoriesArchive struct {
	ClazzID  uint32     `json:"_id"`
	Peer     *InputPeer `json:"peer"`
	OffsetId int32      `json:"offset_id"`
	Limit    int32      `json:"limit"`
}

func (m *TLStoriesGetStoriesArchive) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetStoriesArchive) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb4352016: func() error {
			x.PutClazzID(0xb4352016)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.OffsetId)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getStoriesArchive, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getStoriesArchive, layer)
	}
}

// Decode <--
func (m *TLStoriesGetStoriesArchive) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb4352016: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.OffsetId, err = d.Int32()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetStoriesByID <--
type TLStoriesGetStoriesByID struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLStoriesGetStoriesByID) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetStoriesByID) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5774ca74: func() error {
			x.PutClazzID(0x5774ca74)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getStoriesByID, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getStoriesByID, layer)
	}
}

// Decode <--
func (m *TLStoriesGetStoriesByID) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5774ca74: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesToggleAllStoriesHidden <--
type TLStoriesToggleAllStoriesHidden struct {
	ClazzID uint32 `json:"_id"`
	Hidden  *Bool  `json:"hidden"`
}

func (m *TLStoriesToggleAllStoriesHidden) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesToggleAllStoriesHidden) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7c2557c4: func() error {
			x.PutClazzID(0x7c2557c4)

			_ = m.Hidden.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_toggleAllStoriesHidden, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_toggleAllStoriesHidden, layer)
	}
}

// Decode <--
func (m *TLStoriesToggleAllStoriesHidden) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7c2557c4: func() (err error) {

			m1 := &Bool{}
			_ = m1.Decode(d)
			m.Hidden = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesReadStories <--
type TLStoriesReadStories struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	MaxId   int32      `json:"max_id"`
}

func (m *TLStoriesReadStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesReadStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa556dac8: func() error {
			x.PutClazzID(0xa556dac8)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.MaxId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_readStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_readStories, layer)
	}
}

// Decode <--
func (m *TLStoriesReadStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa556dac8: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.MaxId, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesIncrementStoryViews <--
type TLStoriesIncrementStoryViews struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLStoriesIncrementStoryViews) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesIncrementStoryViews) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb2028afb: func() error {
			x.PutClazzID(0xb2028afb)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_incrementStoryViews, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_incrementStoryViews, layer)
	}
}

// Decode <--
func (m *TLStoriesIncrementStoryViews) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb2028afb: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetStoryViewsList <--
type TLStoriesGetStoryViewsList struct {
	ClazzID        uint32     `json:"_id"`
	JustContacts   bool       `json:"just_contacts"`
	ReactionsFirst bool       `json:"reactions_first"`
	ForwardsFirst  bool       `json:"forwards_first"`
	Peer           *InputPeer `json:"peer"`
	Q              *string    `json:"q"`
	Id             int32      `json:"id"`
	Offset         string     `json:"offset"`
	Limit          int32      `json:"limit"`
}

func (m *TLStoriesGetStoryViewsList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetStoryViewsList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7ed23c57: func() error {
			x.PutClazzID(0x7ed23c57)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.JustContacts == true {
					flags |= 1 << 0
				}
				if m.ReactionsFirst == true {
					flags |= 1 << 2
				}
				if m.ForwardsFirst == true {
					flags |= 1 << 3
				}

				if m.Q != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			if m.Q != nil {
				x.PutString(*m.Q)
			}

			x.PutInt32(m.Id)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getStoryViewsList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getStoryViewsList, layer)
	}
}

// Decode <--
func (m *TLStoriesGetStoryViewsList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7ed23c57: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.JustContacts = true
			}
			if (flags & (1 << 2)) != 0 {
				m.ReactionsFirst = true
			}
			if (flags & (1 << 3)) != 0 {
				m.ForwardsFirst = true
			}

			m5 := &InputPeer{}
			_ = m5.Decode(d)
			m.Peer = m5

			if (flags & (1 << 1)) != 0 {
				m.Q = new(string)
				*m.Q, err = d.String()
			}

			m.Id, err = d.Int32()
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetStoriesViews <--
type TLStoriesGetStoriesViews struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLStoriesGetStoriesViews) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetStoriesViews) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x28e16cc8: func() error {
			x.PutClazzID(0x28e16cc8)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getStoriesViews, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getStoriesViews, layer)
	}
}

// Decode <--
func (m *TLStoriesGetStoriesViews) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x28e16cc8: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesExportStoryLink <--
type TLStoriesExportStoryLink struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      int32      `json:"id"`
}

func (m *TLStoriesExportStoryLink) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesExportStoryLink) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7b8def20: func() error {
			x.PutClazzID(0x7b8def20)

			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_exportStoryLink, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_exportStoryLink, layer)
	}
}

// Decode <--
func (m *TLStoriesExportStoryLink) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7b8def20: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesReport <--
type TLStoriesReport struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
	Option  []byte     `json:"option"`
	Message string     `json:"message"`
}

func (m *TLStoriesReport) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesReport) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x19d8eb45: func() error {
			x.PutClazzID(0x19d8eb45)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			x.PutBytes(m.Option)
			x.PutString(m.Message)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_report, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_report, layer)
	}
}

// Decode <--
func (m *TLStoriesReport) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x19d8eb45: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			m.Option, err = d.Bytes()
			m.Message, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesActivateStealthMode <--
type TLStoriesActivateStealthMode struct {
	ClazzID uint32 `json:"_id"`
	Past    bool   `json:"past"`
	Future  bool   `json:"future"`
}

func (m *TLStoriesActivateStealthMode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesActivateStealthMode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x57bbd166: func() error {
			x.PutClazzID(0x57bbd166)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Past == true {
					flags |= 1 << 0
				}
				if m.Future == true {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_activateStealthMode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_activateStealthMode, layer)
	}
}

// Decode <--
func (m *TLStoriesActivateStealthMode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x57bbd166: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Past = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Future = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesSendReaction <--
type TLStoriesSendReaction struct {
	ClazzID     uint32     `json:"_id"`
	AddToRecent bool       `json:"add_to_recent"`
	Peer        *InputPeer `json:"peer"`
	StoryId     int32      `json:"story_id"`
	Reaction    *Reaction  `json:"reaction"`
}

func (m *TLStoriesSendReaction) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesSendReaction) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x7fd736b2: func() error {
			x.PutClazzID(0x7fd736b2)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.AddToRecent == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.StoryId)
			_ = m.Reaction.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_sendReaction, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_sendReaction, layer)
	}
}

// Decode <--
func (m *TLStoriesSendReaction) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x7fd736b2: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.AddToRecent = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.StoryId, err = d.Int32()

			m5 := &Reaction{}
			_ = m5.Decode(d)
			m.Reaction = m5

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetPeerStories <--
type TLStoriesGetPeerStories struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLStoriesGetPeerStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetPeerStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2c4ada50: func() error {
			x.PutClazzID(0x2c4ada50)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getPeerStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getPeerStories, layer)
	}
}

// Decode <--
func (m *TLStoriesGetPeerStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2c4ada50: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetAllReadPeerStories <--
type TLStoriesGetAllReadPeerStories struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLStoriesGetAllReadPeerStories) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetAllReadPeerStories) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9b5ae7f9: func() error {
			x.PutClazzID(0x9b5ae7f9)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getAllReadPeerStories, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getAllReadPeerStories, layer)
	}
}

// Decode <--
func (m *TLStoriesGetAllReadPeerStories) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9b5ae7f9: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetPeerMaxIDs <--
type TLStoriesGetPeerMaxIDs struct {
	ClazzID uint32       `json:"_id"`
	Id      []*InputPeer `json:"id"`
}

func (m *TLStoriesGetPeerMaxIDs) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetPeerMaxIDs) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x535983c3: func() error {
			x.PutClazzID(0x535983c3)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getPeerMaxIDs, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getPeerMaxIDs, layer)
	}
}

// Decode <--
func (m *TLStoriesGetPeerMaxIDs) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x535983c3: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputPeer, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputPeer)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetChatsToSend <--
type TLStoriesGetChatsToSend struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLStoriesGetChatsToSend) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetChatsToSend) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa56a8b60: func() error {
			x.PutClazzID(0xa56a8b60)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getChatsToSend, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getChatsToSend, layer)
	}
}

// Decode <--
func (m *TLStoriesGetChatsToSend) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa56a8b60: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesTogglePeerStoriesHidden <--
type TLStoriesTogglePeerStoriesHidden struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Hidden  *Bool      `json:"hidden"`
}

func (m *TLStoriesTogglePeerStoriesHidden) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesTogglePeerStoriesHidden) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbd0415c4: func() error {
			x.PutClazzID(0xbd0415c4)

			_ = m.Peer.Encode(x, layer)
			_ = m.Hidden.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_togglePeerStoriesHidden, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_togglePeerStoriesHidden, layer)
	}
}

// Decode <--
func (m *TLStoriesTogglePeerStoriesHidden) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbd0415c4: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &Bool{}
			_ = m2.Decode(d)
			m.Hidden = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesGetStoryReactionsList <--
type TLStoriesGetStoryReactionsList struct {
	ClazzID       uint32     `json:"_id"`
	ForwardsFirst bool       `json:"forwards_first"`
	Peer          *InputPeer `json:"peer"`
	Id            int32      `json:"id"`
	Reaction      *Reaction  `json:"reaction"`
	Offset        *string    `json:"offset"`
	Limit         int32      `json:"limit"`
}

func (m *TLStoriesGetStoryReactionsList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesGetStoryReactionsList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb9b2881f: func() error {
			x.PutClazzID(0xb9b2881f)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.ForwardsFirst == true {
					flags |= 1 << 2
				}

				if m.Reaction != nil {
					flags |= 1 << 0
				}
				if m.Offset != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutInt32(m.Id)
			if m.Reaction != nil {
				_ = m.Reaction.Encode(x, layer)
			}

			if m.Offset != nil {
				x.PutString(*m.Offset)
			}

			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_getStoryReactionsList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_getStoryReactionsList, layer)
	}
}

// Decode <--
func (m *TLStoriesGetStoryReactionsList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb9b2881f: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 2)) != 0 {
				m.ForwardsFirst = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.Id, err = d.Int32()
			if (flags & (1 << 0)) != 0 {
				m5 := &Reaction{}
				_ = m5.Decode(d)
				m.Reaction = m5
			}
			if (flags & (1 << 1)) != 0 {
				m.Offset = new(string)
				*m.Offset, err = d.String()
			}

			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesTogglePinnedToTop <--
type TLStoriesTogglePinnedToTop struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	Id      []int32    `json:"id"`
}

func (m *TLStoriesTogglePinnedToTop) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesTogglePinnedToTop) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xb297e9b: func() error {
			x.PutClazzID(0xb297e9b)

			_ = m.Peer.Encode(x, layer)

			iface.EncodeInt32List(x, m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_togglePinnedToTop, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_togglePinnedToTop, layer)
	}
}

// Decode <--
func (m *TLStoriesTogglePinnedToTop) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xb297e9b: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m.Id, err = iface.DecodeInt32List(d)

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLStoriesSearchPosts <--
type TLStoriesSearchPosts struct {
	ClazzID uint32     `json:"_id"`
	Hashtag *string    `json:"hashtag"`
	Area    *MediaArea `json:"area"`
	Peer    *InputPeer `json:"peer"`
	Offset  string     `json:"offset"`
	Limit   int32      `json:"limit"`
}

func (m *TLStoriesSearchPosts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLStoriesSearchPosts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xd1810907: func() error {
			x.PutClazzID(0xd1810907)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Hashtag != nil {
					flags |= 1 << 0
				}
				if m.Area != nil {
					flags |= 1 << 1
				}
				if m.Peer != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Hashtag != nil {
				x.PutString(*m.Hashtag)
			}

			if m.Area != nil {
				_ = m.Area.Encode(x, layer)
			}

			if m.Peer != nil {
				_ = m.Peer.Encode(x, layer)
			}

			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_stories_searchPosts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_stories_searchPosts, layer)
	}
}

// Decode <--
func (m *TLStoriesSearchPosts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xd1810907: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Hashtag = new(string)
				*m.Hashtag, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m3 := &MediaArea{}
				_ = m3.Decode(d)
				m.Area = m3
			}
			if (flags & (1 << 2)) != 0 {
				m4 := &InputPeer{}
				_ = m4.Decode(d)
				m.Peer = m4
			}
			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPremiumGetBoostsList <--
type TLPremiumGetBoostsList struct {
	ClazzID uint32     `json:"_id"`
	Gifts   bool       `json:"gifts"`
	Peer    *InputPeer `json:"peer"`
	Offset  string     `json:"offset"`
	Limit   int32      `json:"limit"`
}

func (m *TLPremiumGetBoostsList) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPremiumGetBoostsList) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x60f67660: func() error {
			x.PutClazzID(0x60f67660)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Gifts == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			_ = m.Peer.Encode(x, layer)
			x.PutString(m.Offset)
			x.PutInt32(m.Limit)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_premium_getBoostsList, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_premium_getBoostsList, layer)
	}
}

// Decode <--
func (m *TLPremiumGetBoostsList) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x60f67660: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Gifts = true
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			m.Offset, err = d.String()
			m.Limit, err = d.Int32()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPremiumGetMyBoosts <--
type TLPremiumGetMyBoosts struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPremiumGetMyBoosts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPremiumGetMyBoosts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbe77b4a: func() error {
			x.PutClazzID(0xbe77b4a)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_premium_getMyBoosts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_premium_getMyBoosts, layer)
	}
}

// Decode <--
func (m *TLPremiumGetMyBoosts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbe77b4a: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPremiumApplyBoost <--
type TLPremiumApplyBoost struct {
	ClazzID uint32     `json:"_id"`
	Slots   []int32    `json:"slots"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLPremiumApplyBoost) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPremiumApplyBoost) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x6b7da746: func() error {
			x.PutClazzID(0x6b7da746)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Slots != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			if m.Slots != nil {
				iface.EncodeInt32List(x, m.Slots)
			}
			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_premium_applyBoost, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_premium_applyBoost, layer)
	}
}

// Decode <--
func (m *TLPremiumApplyBoost) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x6b7da746: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.Slots, err = iface.DecodeInt32List(d)
			}

			m3 := &InputPeer{}
			_ = m3.Decode(d)
			m.Peer = m3

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPremiumGetBoostsStatus <--
type TLPremiumGetBoostsStatus struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
}

func (m *TLPremiumGetBoostsStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPremiumGetBoostsStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x42f1f61: func() error {
			x.PutClazzID(0x42f1f61)

			_ = m.Peer.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_premium_getBoostsStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_premium_getBoostsStatus, layer)
	}
}

// Decode <--
func (m *TLPremiumGetBoostsStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x42f1f61: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPremiumGetUserBoosts <--
type TLPremiumGetUserBoosts struct {
	ClazzID uint32     `json:"_id"`
	Peer    *InputPeer `json:"peer"`
	UserId  *InputUser `json:"user_id"`
}

func (m *TLPremiumGetUserBoosts) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPremiumGetUserBoosts) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x39854d1f: func() error {
			x.PutClazzID(0x39854d1f)

			_ = m.Peer.Encode(x, layer)
			_ = m.UserId.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_premium_getUserBoosts, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_premium_getUserBoosts, layer)
	}
}

// Decode <--
func (m *TLPremiumGetUserBoosts) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x39854d1f: func() (err error) {

			m1 := &InputPeer{}
			_ = m1.Decode(d)
			m.Peer = m1

			m2 := &InputUser{}
			_ = m2.Decode(d)
			m.UserId = m2

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsIsEligibleToJoin <--
type TLSmsjobsIsEligibleToJoin struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLSmsjobsIsEligibleToJoin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsIsEligibleToJoin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xedc39d0: func() error {
			x.PutClazzID(0xedc39d0)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_isEligibleToJoin, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_isEligibleToJoin, layer)
	}
}

// Decode <--
func (m *TLSmsjobsIsEligibleToJoin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xedc39d0: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsJoin <--
type TLSmsjobsJoin struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLSmsjobsJoin) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsJoin) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa74ece2d: func() error {
			x.PutClazzID(0xa74ece2d)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_join, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_join, layer)
	}
}

// Decode <--
func (m *TLSmsjobsJoin) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa74ece2d: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsLeave <--
type TLSmsjobsLeave struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLSmsjobsLeave) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsLeave) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9898ad73: func() error {
			x.PutClazzID(0x9898ad73)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_leave, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_leave, layer)
	}
}

// Decode <--
func (m *TLSmsjobsLeave) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9898ad73: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsUpdateSettings <--
type TLSmsjobsUpdateSettings struct {
	ClazzID            uint32 `json:"_id"`
	AllowInternational bool   `json:"allow_international"`
}

func (m *TLSmsjobsUpdateSettings) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsUpdateSettings) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x93fa0bf: func() error {
			x.PutClazzID(0x93fa0bf)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.AllowInternational == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_updateSettings, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_updateSettings, layer)
	}
}

// Decode <--
func (m *TLSmsjobsUpdateSettings) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x93fa0bf: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			if (flags & (1 << 0)) != 0 {
				m.AllowInternational = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsGetStatus <--
type TLSmsjobsGetStatus struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLSmsjobsGetStatus) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsGetStatus) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x10a698e8: func() error {
			x.PutClazzID(0x10a698e8)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_getStatus, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_getStatus, layer)
	}
}

// Decode <--
func (m *TLSmsjobsGetStatus) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x10a698e8: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsGetSmsJob <--
type TLSmsjobsGetSmsJob struct {
	ClazzID uint32 `json:"_id"`
	JobId   string `json:"job_id"`
}

func (m *TLSmsjobsGetSmsJob) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsGetSmsJob) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x778d902f: func() error {
			x.PutClazzID(0x778d902f)

			x.PutString(m.JobId)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_getSmsJob, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_getSmsJob, layer)
	}
}

// Decode <--
func (m *TLSmsjobsGetSmsJob) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x778d902f: func() (err error) {
			m.JobId, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLSmsjobsFinishJob <--
type TLSmsjobsFinishJob struct {
	ClazzID uint32  `json:"_id"`
	JobId   string  `json:"job_id"`
	Error   *string `json:"error"`
}

func (m *TLSmsjobsFinishJob) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLSmsjobsFinishJob) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x4f1ebf24: func() error {
			x.PutClazzID(0x4f1ebf24)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Error != nil {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.JobId)
			if m.Error != nil {
				x.PutString(*m.Error)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_smsjobs_finishJob, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_smsjobs_finishJob, layer)
	}
}

// Decode <--
func (m *TLSmsjobsFinishJob) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x4f1ebf24: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.JobId, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.Error = new(string)
				*m.Error, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLFragmentGetCollectibleInfo <--
type TLFragmentGetCollectibleInfo struct {
	ClazzID     uint32            `json:"_id"`
	Collectible *InputCollectible `json:"collectible"`
}

func (m *TLFragmentGetCollectibleInfo) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLFragmentGetCollectibleInfo) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbe1e85ba: func() error {
			x.PutClazzID(0xbe1e85ba)

			_ = m.Collectible.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_fragment_getCollectibleInfo, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_fragment_getCollectibleInfo, layer)
	}
}

// Decode <--
func (m *TLFragmentGetCollectibleInfo) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbe1e85ba: func() (err error) {

			m1 := &InputCollectible{}
			_ = m1.Decode(d)
			m.Collectible = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPaymentsCanPurchasePremium <--
type TLPaymentsCanPurchasePremium struct {
	ClazzID uint32                    `json:"_id"`
	Purpose *InputStorePaymentPurpose `json:"purpose"`
}

func (m *TLPaymentsCanPurchasePremium) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPaymentsCanPurchasePremium) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x9fc19eb6: func() error {
			x.PutClazzID(0x9fc19eb6)

			_ = m.Purpose.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_payments_canPurchasePremium, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_payments_canPurchasePremium, layer)
	}
}

// Decode <--
func (m *TLPaymentsCanPurchasePremium) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x9fc19eb6: func() (err error) {

			m1 := &InputStorePaymentPurpose{}
			_ = m1.Decode(d)
			m.Purpose = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetIsPremiumRequiredToContact <--
type TLUsersGetIsPremiumRequiredToContact struct {
	ClazzID uint32       `json:"_id"`
	Id      []*InputUser `json:"id"`
}

func (m *TLUsersGetIsPremiumRequiredToContact) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetIsPremiumRequiredToContact) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xa622aa10: func() error {
			x.PutClazzID(0xa622aa10)

			_ = iface.EncodeObjectList(x, m.Id, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getIsPremiumRequiredToContact, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getIsPremiumRequiredToContact, layer)
	}
}

// Decode <--
func (m *TLUsersGetIsPremiumRequiredToContact) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xa622aa10: func() (err error) {
			c1, err2 := d.ClazzID()
			if c1 != iface.ClazzID_vector {
				// dBuf.err = fmt.Errorf("invalid ClazzID_vector, c%d: %d", 1, c1)
				return err2
			}
			l1, err3 := d.Int()
			v1 := make([]*InputUser, l1)
			for i := 0; i < l1; i++ {
				vv := new(InputUser)
				err3 = vv.Decode(d)
				_ = err3
				v1[i] = vv
			}
			m.Id = v1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLTestParseInputAppEvent <--
type TLTestParseInputAppEvent struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLTestParseInputAppEvent) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLTestParseInputAppEvent) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xbb0d87f1: func() error {
			x.PutClazzID(0xbb0d87f1)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_test_parseInputAppEvent, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_test_parseInputAppEvent, layer)
	}
}

// Decode <--
func (m *TLTestParseInputAppEvent) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xbb0d87f1: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedCreatePredefinedUser <--
type TLPredefinedCreatePredefinedUser struct {
	ClazzID   uint32  `json:"_id"`
	Phone     string  `json:"phone"`
	FirstName *string `json:"first_name"`
	LastName  *string `json:"last_name"`
	Username  *string `json:"username"`
	Code      string  `json:"code"`
	Verified  bool    `json:"verified"`
}

func (m *TLPredefinedCreatePredefinedUser) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedCreatePredefinedUser) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x23e2e31e: func() error {
			x.PutClazzID(0x23e2e31e)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FirstName != nil {
					flags |= 1 << 0
				}
				if m.LastName != nil {
					flags |= 1 << 1
				}
				if m.Username != nil {
					flags |= 1 << 2
				}

				if m.Verified == true {
					flags |= 1 << 3
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Phone)
			if m.FirstName != nil {
				x.PutString(*m.FirstName)
			}

			if m.LastName != nil {
				x.PutString(*m.LastName)
			}

			if m.Username != nil {
				x.PutString(*m.Username)
			}

			x.PutString(m.Code)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_createPredefinedUser, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_createPredefinedUser, layer)
	}
}

// Decode <--
func (m *TLPredefinedCreatePredefinedUser) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x23e2e31e: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Phone, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.FirstName = new(string)
				*m.FirstName, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.LastName = new(string)
				*m.LastName, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.Username = new(string)
				*m.Username, err = d.String()
			}

			m.Code, err = d.String()
			if (flags & (1 << 3)) != 0 {
				m.Verified = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedUpdatePredefinedUsername <--
type TLPredefinedUpdatePredefinedUsername struct {
	ClazzID  uint32 `json:"_id"`
	Phone    string `json:"phone"`
	Username string `json:"username"`
}

func (m *TLPredefinedUpdatePredefinedUsername) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedUpdatePredefinedUsername) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x12dc0d3a: func() error {
			x.PutClazzID(0x12dc0d3a)

			x.PutString(m.Phone)
			x.PutString(m.Username)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_updatePredefinedUsername, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_updatePredefinedUsername, layer)
	}
}

// Decode <--
func (m *TLPredefinedUpdatePredefinedUsername) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x12dc0d3a: func() (err error) {
			m.Phone, err = d.String()
			m.Username, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedUpdatePredefinedProfile <--
type TLPredefinedUpdatePredefinedProfile struct {
	ClazzID   uint32  `json:"_id"`
	Phone     string  `json:"phone"`
	FirstName *string `json:"first_name"`
	LastName  *string `json:"last_name"`
	About     *string `json:"about"`
}

func (m *TLPredefinedUpdatePredefinedProfile) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedUpdatePredefinedProfile) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x2cdcf945: func() error {
			x.PutClazzID(0x2cdcf945)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.FirstName != nil {
					flags |= 1 << 0
				}
				if m.LastName != nil {
					flags |= 1 << 1
				}
				if m.About != nil {
					flags |= 1 << 2
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Phone)
			if m.FirstName != nil {
				x.PutString(*m.FirstName)
			}

			if m.LastName != nil {
				x.PutString(*m.LastName)
			}

			if m.About != nil {
				x.PutString(*m.About)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_updatePredefinedProfile, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_updatePredefinedProfile, layer)
	}
}

// Decode <--
func (m *TLPredefinedUpdatePredefinedProfile) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x2cdcf945: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Phone, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.FirstName = new(string)
				*m.FirstName, err = d.String()
			}

			if (flags & (1 << 1)) != 0 {
				m.LastName = new(string)
				*m.LastName, err = d.String()
			}

			if (flags & (1 << 2)) != 0 {
				m.About = new(string)
				*m.About, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedUpdatePredefinedVerified <--
type TLPredefinedUpdatePredefinedVerified struct {
	ClazzID  uint32 `json:"_id"`
	Phone    string `json:"phone"`
	Verified bool   `json:"verified"`
}

func (m *TLPredefinedUpdatePredefinedVerified) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedUpdatePredefinedVerified) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x3f3528a9: func() error {
			x.PutClazzID(0x3f3528a9)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Verified == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Phone)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_updatePredefinedVerified, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_updatePredefinedVerified, layer)
	}
}

// Decode <--
func (m *TLPredefinedUpdatePredefinedVerified) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x3f3528a9: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Phone, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.Verified = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedUpdatePredefinedCode <--
type TLPredefinedUpdatePredefinedCode struct {
	ClazzID uint32 `json:"_id"`
	Phone   string `json:"phone"`
	Code    string `json:"code"`
}

func (m *TLPredefinedUpdatePredefinedCode) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedUpdatePredefinedCode) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe5361587: func() error {
			x.PutClazzID(0xe5361587)

			x.PutString(m.Phone)
			x.PutString(m.Code)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_updatePredefinedCode, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_updatePredefinedCode, layer)
	}
}

// Decode <--
func (m *TLPredefinedUpdatePredefinedCode) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe5361587: func() (err error) {
			m.Phone, err = d.String()
			m.Code, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedGetPredefinedUser <--
type TLPredefinedGetPredefinedUser struct {
	ClazzID uint32 `json:"_id"`
	Phone   string `json:"phone"`
}

func (m *TLPredefinedGetPredefinedUser) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedGetPredefinedUser) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5202a415: func() error {
			x.PutClazzID(0x5202a415)

			x.PutString(m.Phone)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_getPredefinedUser, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_getPredefinedUser, layer)
	}
}

// Decode <--
func (m *TLPredefinedGetPredefinedUser) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5202a415: func() (err error) {
			m.Phone, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLPredefinedGetPredefinedUsers <--
type TLPredefinedGetPredefinedUsers struct {
	ClazzID uint32 `json:"_id"`
}

func (m *TLPredefinedGetPredefinedUsers) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLPredefinedGetPredefinedUsers) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x29981ac4: func() error {
			x.PutClazzID(0x29981ac4)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_predefined_getPredefinedUsers, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_predefined_getPredefinedUsers, layer)
	}
}

// Decode <--
func (m *TLPredefinedGetPredefinedUsers) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x29981ac4: func() (err error) {

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLUsersGetMe <--
type TLUsersGetMe struct {
	ClazzID uint32 `json:"_id"`
	Id      int64  `json:"id"`
	Token   string `json:"token"`
}

func (m *TLUsersGetMe) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLUsersGetMe) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x31345712: func() error {
			x.PutClazzID(0x31345712)

			x.PutInt64(m.Id)
			x.PutString(m.Token)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_users_getMe, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_users_getMe, layer)
	}
}

// Decode <--
func (m *TLUsersGetMe) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x31345712: func() (err error) {
			m.Id, err = d.Int64()
			m.Token, err = d.String()

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAccountUpdateVerified <--
type TLAccountUpdateVerified struct {
	ClazzID  uint32 `json:"_id"`
	Id       int64  `json:"id"`
	Verified bool   `json:"verified"`
}

func (m *TLAccountUpdateVerified) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAccountUpdateVerified) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x15140971: func() error {
			x.PutClazzID(0x15140971)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Verified == true {
					flags |= 1 << 0
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutInt64(m.Id)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_account_updateVerified, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_account_updateVerified, layer)
	}
}

// Decode <--
func (m *TLAccountUpdateVerified) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x15140971: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Id, err = d.Int64()
			if (flags & (1 << 0)) != 0 {
				m.Verified = true
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLAuthToggleBan <--
type TLAuthToggleBan struct {
	ClazzID    uint32  `json:"_id"`
	Phone      string  `json:"phone"`
	Predefined bool    `json:"predefined"`
	Expires    *int32  `json:"expires"`
	Reason     *string `json:"reason"`
}

func (m *TLAuthToggleBan) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLAuthToggleBan) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0xe21f7938: func() error {
			x.PutClazzID(0xe21f7938)

			// set flags
			var getFlags = func() uint32 {
				var flags uint32 = 0

				if m.Predefined == true {
					flags |= 1 << 0
				}
				if m.Expires != nil {
					flags |= 1 << 1
				}
				if m.Reason != nil {
					flags |= 1 << 1
				}

				return flags
			}

			// set flags
			var flags = getFlags()
			x.PutUint32(flags)
			x.PutString(m.Phone)
			if m.Expires != nil {
				x.PutInt32(*m.Expires)
			}

			if m.Reason != nil {
				x.PutString(*m.Reason)
			}

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_auth_toggleBan, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_auth_toggleBan, layer)
	}
}

// Decode <--
func (m *TLAuthToggleBan) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0xe21f7938: func() (err error) {
			flags, _ := d.Uint32()
			_ = flags
			m.Phone, err = d.String()
			if (flags & (1 << 0)) != 0 {
				m.Predefined = true
			}
			if (flags & (1 << 1)) != 0 {
				m.Expires = new(int32)
				*m.Expires, err = d.Int32()
			}
			if (flags & (1 << 1)) != 0 {
				m.Reason = new(string)
				*m.Reason, err = d.String()
			}

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// TLBizInvokeBizDataRaw <--
type TLBizInvokeBizDataRaw struct {
	ClazzID uint32      `json:"_id"`
	BizData *BizDataRaw `json:"biz_data"`
}

func (m *TLBizInvokeBizDataRaw) String() string {
	wrapper := iface.WithNameWrapper{"", m}
	return wrapper.String()
}

// Encode <--
func (m *TLBizInvokeBizDataRaw) Encode(x *bin.Encoder, layer int32) error {
	var encodeF = map[uint32]func() error{
		0x5a191146: func() error {
			x.PutClazzID(0x5a191146)

			_ = m.BizData.Encode(x, layer)

			return nil
		},
	}

	clazzId := iface.GetClazzIDByName(ClazzName_biz_invokeBizDataRaw, int(layer))
	if f, ok := encodeF[clazzId]; ok {
		return f()
	} else {
		// TODO(@benqi): handle error
		return fmt.Errorf("not found clazzId by (%s, %d)", ClazzName_biz_invokeBizDataRaw, layer)
	}
}

// Decode <--
func (m *TLBizInvokeBizDataRaw) Decode(d *bin.Decoder) (err error) {
	var decodeF = map[uint32]func() error{
		0x5a191146: func() (err error) {

			m1 := &BizDataRaw{}
			_ = m1.Decode(d)
			m.BizData = m1

			return nil
		},
	}

	if m.ClazzID == 0 {
		m.ClazzID, _ = d.ClazzID()
	}
	if f, ok := decodeF[m.ClazzID]; ok {
		return f()
	} else {
		return fmt.Errorf("invalid constructor: %x", m.ClazzID)
	}
}

// Vector api result type
// ----------------------------------------------------------------------------
// VectorResList <--

// VectorSecureValue <--
type VectorSecureValue struct {
	Datas []*SecureValue `json:"datas"`
}

func (m *VectorSecureValue) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorSecureValue) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorSecureValue) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*SecureValue](d)

	return err
}

// VectorWallPaper <--
type VectorWallPaper struct {
	Datas []*WallPaper `json:"datas"`
}

func (m *VectorWallPaper) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorWallPaper) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorWallPaper) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*WallPaper](d)

	return err
}

// VectorUser <--
type VectorUser struct {
	Datas []*User `json:"datas"`
}

func (m *VectorUser) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorUser) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorUser) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*User](d)

	return err
}

// VectorRequirementToContact <--
type VectorRequirementToContact struct {
	Datas []*RequirementToContact `json:"datas"`
}

func (m *VectorRequirementToContact) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorRequirementToContact) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorRequirementToContact) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*RequirementToContact](d)

	return err
}

// VectorInt <--
type VectorInt struct {
	Datas []int32 `json:"datas"`
}

func (m *VectorInt) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorInt) Encode(x *bin.Encoder, layer int32) error {
	iface.EncodeInt32List(x, m.Datas)

	return nil
}

// Decode <--
func (m *VectorInt) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeInt32List(d)

	return err
}

// VectorContactStatus <--
type VectorContactStatus struct {
	Datas []*ContactStatus `json:"datas"`
}

func (m *VectorContactStatus) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorContactStatus) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorContactStatus) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*ContactStatus](d)

	return err
}

// VectorSavedContact <--
type VectorSavedContact struct {
	Datas []*SavedContact `json:"datas"`
}

func (m *VectorSavedContact) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorSavedContact) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorSavedContact) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*SavedContact](d)

	return err
}

// VectorReceivedNotifyMessage <--
type VectorReceivedNotifyMessage struct {
	Datas []*ReceivedNotifyMessage `json:"datas"`
}

func (m *VectorReceivedNotifyMessage) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorReceivedNotifyMessage) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorReceivedNotifyMessage) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*ReceivedNotifyMessage](d)

	return err
}

// VectorLong <--
type VectorLong struct {
	Datas []int64 `json:"datas"`
}

func (m *VectorLong) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorLong) Encode(x *bin.Encoder, layer int32) error {
	iface.EncodeInt64List(x, m.Datas)

	return nil
}

// Decode <--
func (m *VectorLong) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeInt64List(d)

	return err
}

// VectorStickerSetCovered <--
type VectorStickerSetCovered struct {
	Datas []*StickerSetCovered `json:"datas"`
}

func (m *VectorStickerSetCovered) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorStickerSetCovered) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorStickerSetCovered) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*StickerSetCovered](d)

	return err
}

// VectorMessageRange <--
type VectorMessageRange struct {
	Datas []*MessageRange `json:"datas"`
}

func (m *VectorMessageRange) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorMessageRange) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorMessageRange) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*MessageRange](d)

	return err
}

// VectorDialogPeer <--
type VectorDialogPeer struct {
	Datas []*DialogPeer `json:"datas"`
}

func (m *VectorDialogPeer) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorDialogPeer) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorDialogPeer) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*DialogPeer](d)

	return err
}

// VectorEmojiLanguage <--
type VectorEmojiLanguage struct {
	Datas []*EmojiLanguage `json:"datas"`
}

func (m *VectorEmojiLanguage) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorEmojiLanguage) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorEmojiLanguage) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*EmojiLanguage](d)

	return err
}

// VectorMessagesSearchCounter <--
type VectorMessagesSearchCounter struct {
	Datas []*MessagesSearchCounter `json:"datas"`
}

func (m *VectorMessagesSearchCounter) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorMessagesSearchCounter) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorMessagesSearchCounter) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*MessagesSearchCounter](d)

	return err
}

// VectorDialogFilterSuggested <--
type VectorDialogFilterSuggested struct {
	Datas []*DialogFilterSuggested `json:"datas"`
}

func (m *VectorDialogFilterSuggested) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorDialogFilterSuggested) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorDialogFilterSuggested) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*DialogFilterSuggested](d)

	return err
}

// VectorReadParticipantDate <--
type VectorReadParticipantDate struct {
	Datas []*ReadParticipantDate `json:"datas"`
}

func (m *VectorReadParticipantDate) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorReadParticipantDate) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorReadParticipantDate) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*ReadParticipantDate](d)

	return err
}

// VectorDocument <--
type VectorDocument struct {
	Datas []*Document `json:"datas"`
}

func (m *VectorDocument) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorDocument) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorDocument) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*Document](d)

	return err
}

// VectorFactCheck <--
type VectorFactCheck struct {
	Datas []*FactCheck `json:"datas"`
}

func (m *VectorFactCheck) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorFactCheck) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorFactCheck) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*FactCheck](d)

	return err
}

// VectorFileHash <--
type VectorFileHash struct {
	Datas []*FileHash `json:"datas"`
}

func (m *VectorFileHash) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorFileHash) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorFileHash) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*FileHash](d)

	return err
}

// VectorBotCommand <--
type VectorBotCommand struct {
	Datas []*BotCommand `json:"datas"`
}

func (m *VectorBotCommand) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorBotCommand) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorBotCommand) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*BotCommand](d)

	return err
}

// VectorBotPreviewMedia <--
type VectorBotPreviewMedia struct {
	Datas []*BotPreviewMedia `json:"datas"`
}

func (m *VectorBotPreviewMedia) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorBotPreviewMedia) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorBotPreviewMedia) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*BotPreviewMedia](d)

	return err
}

// VectorPremiumGiftCodeOption <--
type VectorPremiumGiftCodeOption struct {
	Datas []*PremiumGiftCodeOption `json:"datas"`
}

func (m *VectorPremiumGiftCodeOption) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorPremiumGiftCodeOption) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorPremiumGiftCodeOption) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*PremiumGiftCodeOption](d)

	return err
}

// VectorStarsTopupOption <--
type VectorStarsTopupOption struct {
	Datas []*StarsTopupOption `json:"datas"`
}

func (m *VectorStarsTopupOption) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorStarsTopupOption) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorStarsTopupOption) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*StarsTopupOption](d)

	return err
}

// VectorStarsGiftOption <--
type VectorStarsGiftOption struct {
	Datas []*StarsGiftOption `json:"datas"`
}

func (m *VectorStarsGiftOption) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorStarsGiftOption) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorStarsGiftOption) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*StarsGiftOption](d)

	return err
}

// VectorStarsGiveawayOption <--
type VectorStarsGiveawayOption struct {
	Datas []*StarsGiveawayOption `json:"datas"`
}

func (m *VectorStarsGiveawayOption) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorStarsGiveawayOption) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorStarsGiveawayOption) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*StarsGiveawayOption](d)

	return err
}

// VectorLangPackString <--
type VectorLangPackString struct {
	Datas []*LangPackString `json:"datas"`
}

func (m *VectorLangPackString) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorLangPackString) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorLangPackString) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*LangPackString](d)

	return err
}

// VectorLangPackLanguage <--
type VectorLangPackLanguage struct {
	Datas []*LangPackLanguage `json:"datas"`
}

func (m *VectorLangPackLanguage) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorLangPackLanguage) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorLangPackLanguage) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*LangPackLanguage](d)

	return err
}

// VectorPeer <--
type VectorPeer struct {
	Datas []*Peer `json:"datas"`
}

func (m *VectorPeer) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorPeer) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorPeer) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*Peer](d)

	return err
}

// VectorBool <--
type VectorBool struct {
	Datas []*Bool `json:"datas"`
}

func (m *VectorBool) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorBool) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorBool) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*Bool](d)

	return err
}

// VectorPredefinedUser <--
type VectorPredefinedUser struct {
	Datas []*PredefinedUser `json:"datas"`
}

func (m *VectorPredefinedUser) String() string {
	data, _ := json.Marshal(m)
	return string(data)
}

// Encode <--
func (m *VectorPredefinedUser) Encode(x *bin.Encoder, layer int32) error {
	_ = iface.EncodeObjectList(x, m.Datas, layer)

	return nil
}

// Decode <--
func (m *VectorPredefinedUser) Decode(d *bin.Decoder) (err error) {
	m.Datas, err = iface.DecodeObjectList[*PredefinedUser](d)

	return err
}

//--------------------------------------------------------------------------------------------
// rpc

type RPCBotMenu interface {
	MessagesGetAttachMenuBots(ctx context.Context, in *TLMessagesGetAttachMenuBots) (*AttachMenuBots, error)
	MessagesGetAttachMenuBot(ctx context.Context, in *TLMessagesGetAttachMenuBot) (*AttachMenuBotsBot, error)
	MessagesToggleBotInAttachMenu(ctx context.Context, in *TLMessagesToggleBotInAttachMenu) (*Bool, error)
}

type RPCTsf interface {
	HelpGetUserInfo(ctx context.Context, in *TLHelpGetUserInfo) (*HelpUserInfo, error)
	HelpEditUserInfo(ctx context.Context, in *TLHelpEditUserInfo) (*HelpUserInfo, error)
}

type RPCGiftCodes interface {
	PaymentsCheckGiftCode(ctx context.Context, in *TLPaymentsCheckGiftCode) (*PaymentsCheckedGiftCode, error)
	PaymentsApplyGiftCode(ctx context.Context, in *TLPaymentsApplyGiftCode) (*Updates, error)
}

type RPCTakeout interface {
	AccountInitTakeoutSession(ctx context.Context, in *TLAccountInitTakeoutSession) (*AccountTakeout, error)
	AccountFinishTakeoutSession(ctx context.Context, in *TLAccountFinishTakeoutSession) (*Bool, error)
	MessagesGetSplitRanges(ctx context.Context, in *TLMessagesGetSplitRanges) (*VectorMessageRange, error)
	ChannelsGetLeftChannels(ctx context.Context, in *TLChannelsGetLeftChannels) (*MessagesChats, error)
}

type RPCUserProfile interface {
	AccountUpdateProfile(ctx context.Context, in *TLAccountUpdateProfile) (*User, error)
	AccountUpdateStatus(ctx context.Context, in *TLAccountUpdateStatus) (*Bool, error)
	AccountUpdateBirthday(ctx context.Context, in *TLAccountUpdateBirthday) (*Bool, error)
	AccountUpdatePersonalChannel(ctx context.Context, in *TLAccountUpdatePersonalChannel) (*Bool, error)
	ContactsGetBirthdays(ctx context.Context, in *TLContactsGetBirthdays) (*ContactsContactBirthdays, error)
	PhotosUpdateProfilePhoto(ctx context.Context, in *TLPhotosUpdateProfilePhoto) (*PhotosPhoto, error)
	PhotosUploadProfilePhoto(ctx context.Context, in *TLPhotosUploadProfilePhoto) (*PhotosPhoto, error)
	PhotosDeletePhotos(ctx context.Context, in *TLPhotosDeletePhotos) (*VectorLong, error)
	PhotosGetUserPhotos(ctx context.Context, in *TLPhotosGetUserPhotos) (*PhotosPhotos, error)
	PhotosUploadContactProfilePhoto(ctx context.Context, in *TLPhotosUploadContactProfilePhoto) (*PhotosPhoto, error)
	AccountUpdateVerified(ctx context.Context, in *TLAccountUpdateVerified) (*User, error)
}

type RPCSeamless interface {
	AccountGetWebAuthorizations(ctx context.Context, in *TLAccountGetWebAuthorizations) (*AccountWebAuthorizations, error)
	AccountResetWebAuthorization(ctx context.Context, in *TLAccountResetWebAuthorization) (*Bool, error)
	AccountResetWebAuthorizations(ctx context.Context, in *TLAccountResetWebAuthorizations) (*Bool, error)
	MessagesRequestUrlAuth(ctx context.Context, in *TLMessagesRequestUrlAuth) (*UrlAuthResult, error)
	MessagesAcceptUrlAuth(ctx context.Context, in *TLMessagesAcceptUrlAuth) (*UrlAuthResult, error)
}

type RPCReactionNotification interface {
	AccountGetReactionsNotifySettings(ctx context.Context, in *TLAccountGetReactionsNotifySettings) (*ReactionsNotifySettings, error)
	AccountSetReactionsNotifySettings(ctx context.Context, in *TLAccountSetReactionsNotifySettings) (*ReactionsNotifySettings, error)
}

type RPCDialogs interface {
	MessagesGetDialogs(ctx context.Context, in *TLMessagesGetDialogs) (*MessagesDialogs, error)
	MessagesSetTyping(ctx context.Context, in *TLMessagesSetTyping) (*Bool, error)
	MessagesGetPeerSettings(ctx context.Context, in *TLMessagesGetPeerSettings) (*MessagesPeerSettings, error)
	MessagesGetPeerDialogs(ctx context.Context, in *TLMessagesGetPeerDialogs) (*MessagesPeerDialogs, error)
	MessagesToggleDialogPin(ctx context.Context, in *TLMessagesToggleDialogPin) (*Bool, error)
	MessagesReorderPinnedDialogs(ctx context.Context, in *TLMessagesReorderPinnedDialogs) (*Bool, error)
	MessagesGetPinnedDialogs(ctx context.Context, in *TLMessagesGetPinnedDialogs) (*MessagesPeerDialogs, error)
	MessagesSendScreenshotNotification(ctx context.Context, in *TLMessagesSendScreenshotNotification) (*Updates, error)
	MessagesMarkDialogUnread(ctx context.Context, in *TLMessagesMarkDialogUnread) (*Bool, error)
	MessagesGetDialogUnreadMarks(ctx context.Context, in *TLMessagesGetDialogUnreadMarks) (*VectorDialogPeer, error)
	MessagesGetOnlines(ctx context.Context, in *TLMessagesGetOnlines) (*ChatOnlines, error)
	MessagesHidePeerSettingsBar(ctx context.Context, in *TLMessagesHidePeerSettingsBar) (*Bool, error)
	MessagesSetHistoryTTL(ctx context.Context, in *TLMessagesSetHistoryTTL) (*Updates, error)
}

type RPCGifs interface {
	MessagesGetSavedGifs(ctx context.Context, in *TLMessagesGetSavedGifs) (*MessagesSavedGifs, error)
	MessagesSaveGif(ctx context.Context, in *TLMessagesSaveGif) (*Bool, error)
}

type RPCImportedChats interface {
	MessagesCheckHistoryImport(ctx context.Context, in *TLMessagesCheckHistoryImport) (*MessagesHistoryImportParsed, error)
	MessagesInitHistoryImport(ctx context.Context, in *TLMessagesInitHistoryImport) (*MessagesHistoryImport, error)
	MessagesUploadImportedMedia(ctx context.Context, in *TLMessagesUploadImportedMedia) (*MessageMedia, error)
	MessagesStartHistoryImport(ctx context.Context, in *TLMessagesStartHistoryImport) (*Bool, error)
	MessagesCheckHistoryImportPeer(ctx context.Context, in *TLMessagesCheckHistoryImportPeer) (*MessagesCheckedHistoryImportPeer, error)
}

type RPCReactions interface {
	MessagesSendReaction(ctx context.Context, in *TLMessagesSendReaction) (*Updates, error)
	MessagesGetMessagesReactions(ctx context.Context, in *TLMessagesGetMessagesReactions) (*Updates, error)
	MessagesGetMessageReactionsList(ctx context.Context, in *TLMessagesGetMessageReactionsList) (*MessagesMessageReactionsList, error)
	MessagesSetChatAvailableReactions(ctx context.Context, in *TLMessagesSetChatAvailableReactions) (*Updates, error)
	MessagesGetAvailableReactions(ctx context.Context, in *TLMessagesGetAvailableReactions) (*MessagesAvailableReactions, error)
	MessagesSetDefaultReaction(ctx context.Context, in *TLMessagesSetDefaultReaction) (*Bool, error)
	MessagesGetUnreadReactions(ctx context.Context, in *TLMessagesGetUnreadReactions) (*MessagesMessages, error)
	MessagesReadReactions(ctx context.Context, in *TLMessagesReadReactions) (*MessagesAffectedHistory, error)
	MessagesReportReaction(ctx context.Context, in *TLMessagesReportReaction) (*Bool, error)
	MessagesGetTopReactions(ctx context.Context, in *TLMessagesGetTopReactions) (*MessagesReactions, error)
	MessagesGetRecentReactions(ctx context.Context, in *TLMessagesGetRecentReactions) (*MessagesReactions, error)
	MessagesClearRecentReactions(ctx context.Context, in *TLMessagesClearRecentReactions) (*Bool, error)
	MessagesSendPaidReaction(ctx context.Context, in *TLMessagesSendPaidReaction) (*Updates, error)
	MessagesTogglePaidReactionPrivacy(ctx context.Context, in *TLMessagesTogglePaidReactionPrivacy) (*Bool, error)
	MessagesGetPaidReactionPrivacy(ctx context.Context, in *TLMessagesGetPaidReactionPrivacy) (*Updates, error)
}

type RPCQrCode interface {
	AuthExportLoginToken(ctx context.Context, in *TLAuthExportLoginToken) (*AuthLoginToken, error)
	AuthImportLoginToken(ctx context.Context, in *TLAuthImportLoginToken) (*AuthLoginToken, error)
	AuthAcceptLoginToken(ctx context.Context, in *TLAuthAcceptLoginToken) (*Authorization, error)
}

type RPCStatistics interface {
	StatsGetBroadcastStats(ctx context.Context, in *TLStatsGetBroadcastStats) (*StatsBroadcastStats, error)
	StatsLoadAsyncGraph(ctx context.Context, in *TLStatsLoadAsyncGraph) (*StatsGraph, error)
	StatsGetMegagroupStats(ctx context.Context, in *TLStatsGetMegagroupStats) (*StatsMegagroupStats, error)
	StatsGetMessagePublicForwards(ctx context.Context, in *TLStatsGetMessagePublicForwards) (*StatsPublicForwards, error)
	StatsGetMessageStats(ctx context.Context, in *TLStatsGetMessageStats) (*StatsMessageStats, error)
	StatsGetStoryStats(ctx context.Context, in *TLStatsGetStoryStats) (*StatsStoryStats, error)
	StatsGetStoryPublicForwards(ctx context.Context, in *TLStatsGetStoryPublicForwards) (*StatsPublicForwards, error)
}

type RPCEmojiStatus interface {
	AccountUpdateEmojiStatus(ctx context.Context, in *TLAccountUpdateEmojiStatus) (*Bool, error)
	AccountGetDefaultEmojiStatuses(ctx context.Context, in *TLAccountGetDefaultEmojiStatuses) (*AccountEmojiStatuses, error)
	AccountGetRecentEmojiStatuses(ctx context.Context, in *TLAccountGetRecentEmojiStatuses) (*AccountEmojiStatuses, error)
	AccountClearRecentEmojiStatuses(ctx context.Context, in *TLAccountClearRecentEmojiStatuses) (*Bool, error)
	AccountGetChannelDefaultEmojiStatuses(ctx context.Context, in *TLAccountGetChannelDefaultEmojiStatuses) (*AccountEmojiStatuses, error)
	AccountGetChannelRestrictedStatusEmojis(ctx context.Context, in *TLAccountGetChannelRestrictedStatusEmojis) (*EmojiList, error)
	AccountGetCollectibleEmojiStatuses(ctx context.Context, in *TLAccountGetCollectibleEmojiStatuses) (*AccountEmojiStatuses, error)
	ChannelsUpdateEmojiStatus(ctx context.Context, in *TLChannelsUpdateEmojiStatus) (*Updates, error)
	BotsUpdateUserEmojiStatus(ctx context.Context, in *TLBotsUpdateUserEmojiStatus) (*Bool, error)
	BotsToggleUserEmojiStatusPermission(ctx context.Context, in *TLBotsToggleUserEmojiStatusPermission) (*Bool, error)
}

type RPCBusinessConnectedBots interface {
	AccountUpdateConnectedBot(ctx context.Context, in *TLAccountUpdateConnectedBot) (*Updates, error)
	AccountGetConnectedBots(ctx context.Context, in *TLAccountGetConnectedBots) (*AccountConnectedBots, error)
	AccountGetBotBusinessConnection(ctx context.Context, in *TLAccountGetBotBusinessConnection) (*Updates, error)
	AccountToggleConnectedBotPaused(ctx context.Context, in *TLAccountToggleConnectedBotPaused) (*Bool, error)
	AccountDisablePeerConnectedBot(ctx context.Context, in *TLAccountDisablePeerConnectedBot) (*Bool, error)
}

type RPCScheduledMessages interface {
	MessagesGetScheduledHistory(ctx context.Context, in *TLMessagesGetScheduledHistory) (*MessagesMessages, error)
	MessagesGetScheduledMessages(ctx context.Context, in *TLMessagesGetScheduledMessages) (*MessagesMessages, error)
	MessagesSendScheduledMessages(ctx context.Context, in *TLMessagesSendScheduledMessages) (*Updates, error)
	MessagesDeleteScheduledMessages(ctx context.Context, in *TLMessagesDeleteScheduledMessages) (*Updates, error)
}

type RPCPromoData interface {
	HelpGetPromoData(ctx context.Context, in *TLHelpGetPromoData) (*HelpPromoData, error)
	HelpHidePromoData(ctx context.Context, in *TLHelpHidePromoData) (*Bool, error)
}

type RPCBotMenuButton interface {
	BotsSetBotMenuButton(ctx context.Context, in *TLBotsSetBotMenuButton) (*Bool, error)
	BotsGetBotMenuButton(ctx context.Context, in *TLBotsGetBotMenuButton) (*BotMenuButton, error)
}

type RPCBotAdminRight interface {
	BotsSetBotBroadcastDefaultAdminRights(ctx context.Context, in *TLBotsSetBotBroadcastDefaultAdminRights) (*Bool, error)
	BotsSetBotGroupDefaultAdminRights(ctx context.Context, in *TLBotsSetBotGroupDefaultAdminRights) (*Bool, error)
}

type RPCPredefined interface {
	PredefinedCreatePredefinedUser(ctx context.Context, in *TLPredefinedCreatePredefinedUser) (*PredefinedUser, error)
	PredefinedUpdatePredefinedUsername(ctx context.Context, in *TLPredefinedUpdatePredefinedUsername) (*PredefinedUser, error)
	PredefinedUpdatePredefinedProfile(ctx context.Context, in *TLPredefinedUpdatePredefinedProfile) (*PredefinedUser, error)
	PredefinedUpdatePredefinedVerified(ctx context.Context, in *TLPredefinedUpdatePredefinedVerified) (*PredefinedUser, error)
	PredefinedUpdatePredefinedCode(ctx context.Context, in *TLPredefinedUpdatePredefinedCode) (*PredefinedUser, error)
	PredefinedGetPredefinedUser(ctx context.Context, in *TLPredefinedGetPredefinedUser) (*PredefinedUser, error)
	PredefinedGetPredefinedUsers(ctx context.Context, in *TLPredefinedGetPredefinedUsers) (*VectorPredefinedUser, error)
}

type RPCTwoFa interface {
	AccountGetPassword(ctx context.Context, in *TLAccountGetPassword) (*AccountPassword, error)
	AccountGetPasswordSettings(ctx context.Context, in *TLAccountGetPasswordSettings) (*AccountPasswordSettings, error)
	AccountUpdatePasswordSettings(ctx context.Context, in *TLAccountUpdatePasswordSettings) (*Bool, error)
	AccountConfirmPasswordEmail(ctx context.Context, in *TLAccountConfirmPasswordEmail) (*Bool, error)
	AccountResendPasswordEmail(ctx context.Context, in *TLAccountResendPasswordEmail) (*Bool, error)
	AccountCancelPasswordEmail(ctx context.Context, in *TLAccountCancelPasswordEmail) (*Bool, error)
	AccountDeclinePasswordReset(ctx context.Context, in *TLAccountDeclinePasswordReset) (*Bool, error)
}

type RPCPaidMedia interface {
	MessagesGetExtendedMedia(ctx context.Context, in *TLMessagesGetExtendedMedia) (*Updates, error)
}

type RPCSavedMessageDialogs interface {
	MessagesGetSavedDialogs(ctx context.Context, in *TLMessagesGetSavedDialogs) (*MessagesSavedDialogs, error)
	MessagesGetSavedHistory(ctx context.Context, in *TLMessagesGetSavedHistory) (*MessagesMessages, error)
	MessagesDeleteSavedHistory(ctx context.Context, in *TLMessagesDeleteSavedHistory) (*MessagesAffectedHistory, error)
	MessagesGetPinnedSavedDialogs(ctx context.Context, in *TLMessagesGetPinnedSavedDialogs) (*MessagesSavedDialogs, error)
	MessagesToggleSavedDialogPin(ctx context.Context, in *TLMessagesToggleSavedDialogPin) (*Bool, error)
	MessagesReorderPinnedSavedDialogs(ctx context.Context, in *TLMessagesReorderPinnedSavedDialogs) (*Bool, error)
}

type RPCUpdates interface {
	UpdatesGetState(ctx context.Context, in *TLUpdatesGetState) (*UpdatesState, error)
	UpdatesGetDifference(ctx context.Context, in *TLUpdatesGetDifference) (*UpdatesDifference, error)
	UpdatesGetChannelDifference(ctx context.Context, in *TLUpdatesGetChannelDifference) (*UpdatesChannelDifference, error)
}

type RPCChannelAdRevenue interface {
	StatsGetBroadcastRevenueStats(ctx context.Context, in *TLStatsGetBroadcastRevenueStats) (*StatsBroadcastRevenueStats, error)
	StatsGetBroadcastRevenueWithdrawalUrl(ctx context.Context, in *TLStatsGetBroadcastRevenueWithdrawalUrl) (*StatsBroadcastRevenueWithdrawalUrl, error)
	StatsGetBroadcastRevenueTransactions(ctx context.Context, in *TLStatsGetBroadcastRevenueTransactions) (*StatsBroadcastRevenueTransactions, error)
}

type RPCtest interface {
	TestParseInputAppEvent(ctx context.Context, in *TLTestParseInputAppEvent) (*InputAppEvent, error)
}

type RPCBusinessOpeningHours interface {
	AccountUpdateBusinessWorkHours(ctx context.Context, in *TLAccountUpdateBusinessWorkHours) (*Bool, error)
}

type RPCEmoji interface {
	MessagesGetEmojiKeywords(ctx context.Context, in *TLMessagesGetEmojiKeywords) (*EmojiKeywordsDifference, error)
	MessagesGetEmojiKeywordsDifference(ctx context.Context, in *TLMessagesGetEmojiKeywordsDifference) (*EmojiKeywordsDifference, error)
	MessagesGetEmojiKeywordsLanguages(ctx context.Context, in *TLMessagesGetEmojiKeywordsLanguages) (*VectorEmojiLanguage, error)
	MessagesGetEmojiURL(ctx context.Context, in *TLMessagesGetEmojiURL) (*EmojiURL, error)
}

type RPCTranscription interface {
	MessagesTranscribeAudio(ctx context.Context, in *TLMessagesTranscribeAudio) (*MessagesTranscribedAudio, error)
	MessagesRateTranscribedAudio(ctx context.Context, in *TLMessagesRateTranscribedAudio) (*Bool, error)
}

type RPCConfiguration interface {
	HelpGetConfig(ctx context.Context, in *TLHelpGetConfig) (*Config, error)
	HelpGetNearestDc(ctx context.Context, in *TLHelpGetNearestDc) (*NearestDc, error)
	HelpGetAppUpdate(ctx context.Context, in *TLHelpGetAppUpdate) (*HelpAppUpdate, error)
	HelpGetInviteText(ctx context.Context, in *TLHelpGetInviteText) (*HelpInviteText, error)
	HelpGetSupport(ctx context.Context, in *TLHelpGetSupport) (*HelpSupport, error)
	HelpGetAppConfig(ctx context.Context, in *TLHelpGetAppConfig) (*HelpAppConfig, error)
	HelpGetSupportName(ctx context.Context, in *TLHelpGetSupportName) (*HelpSupportName, error)
	HelpDismissSuggestion(ctx context.Context, in *TLHelpDismissSuggestion) (*Bool, error)
	HelpGetCountriesList(ctx context.Context, in *TLHelpGetCountriesList) (*HelpCountriesList, error)
}

type RPCTimezones interface {
	HelpGetTimezonesList(ctx context.Context, in *TLHelpGetTimezonesList) (*HelpTimezonesList, error)
}

type RPCSponsoredMessages interface {
	AccountToggleSponsoredMessages(ctx context.Context, in *TLAccountToggleSponsoredMessages) (*Bool, error)
	ContactsGetSponsoredPeers(ctx context.Context, in *TLContactsGetSponsoredPeers) (*ContactsSponsoredPeers, error)
	MessagesViewSponsoredMessage(ctx context.Context, in *TLMessagesViewSponsoredMessage) (*Bool, error)
	MessagesClickSponsoredMessage(ctx context.Context, in *TLMessagesClickSponsoredMessage) (*Bool, error)
	MessagesReportSponsoredMessage(ctx context.Context, in *TLMessagesReportSponsoredMessage) (*ChannelsSponsoredMessageReportResult, error)
	MessagesGetSponsoredMessages(ctx context.Context, in *TLMessagesGetSponsoredMessages) (*MessagesSponsoredMessages, error)
	ChannelsRestrictSponsoredMessages(ctx context.Context, in *TLChannelsRestrictSponsoredMessages) (*Updates, error)
}

type RPCBusinessGreeting interface {
	AccountUpdateBusinessGreetingMessage(ctx context.Context, in *TLAccountUpdateBusinessGreetingMessage) (*Bool, error)
	AccountUpdateBusinessAwayMessage(ctx context.Context, in *TLAccountUpdateBusinessAwayMessage) (*Bool, error)
}

type RPCPolls interface {
	MessagesSendVote(ctx context.Context, in *TLMessagesSendVote) (*Updates, error)
	MessagesGetPollResults(ctx context.Context, in *TLMessagesGetPollResults) (*Updates, error)
	MessagesGetPollVotes(ctx context.Context, in *TLMessagesGetPollVotes) (*MessagesVotesList, error)
}

type RPCFolders interface {
	MessagesGetDialogFilters(ctx context.Context, in *TLMessagesGetDialogFilters) (*MessagesDialogFilters, error)
	MessagesGetSuggestedDialogFilters(ctx context.Context, in *TLMessagesGetSuggestedDialogFilters) (*VectorDialogFilterSuggested, error)
	MessagesUpdateDialogFilter(ctx context.Context, in *TLMessagesUpdateDialogFilter) (*Bool, error)
	MessagesUpdateDialogFiltersOrder(ctx context.Context, in *TLMessagesUpdateDialogFiltersOrder) (*Bool, error)
	FoldersEditPeerFolders(ctx context.Context, in *TLFoldersEditPeerFolders) (*Updates, error)
	ChatlistsExportChatlistInvite(ctx context.Context, in *TLChatlistsExportChatlistInvite) (*ChatlistsExportedChatlistInvite, error)
	ChatlistsDeleteExportedInvite(ctx context.Context, in *TLChatlistsDeleteExportedInvite) (*Bool, error)
	ChatlistsEditExportedInvite(ctx context.Context, in *TLChatlistsEditExportedInvite) (*ExportedChatlistInvite, error)
	ChatlistsGetExportedInvites(ctx context.Context, in *TLChatlistsGetExportedInvites) (*ChatlistsExportedInvites, error)
	ChatlistsCheckChatlistInvite(ctx context.Context, in *TLChatlistsCheckChatlistInvite) (*ChatlistsChatlistInvite, error)
	ChatlistsJoinChatlistInvite(ctx context.Context, in *TLChatlistsJoinChatlistInvite) (*Updates, error)
	ChatlistsGetChatlistUpdates(ctx context.Context, in *TLChatlistsGetChatlistUpdates) (*ChatlistsChatlistUpdates, error)
	ChatlistsJoinChatlistUpdates(ctx context.Context, in *TLChatlistsJoinChatlistUpdates) (*Updates, error)
	ChatlistsHideChatlistUpdates(ctx context.Context, in *TLChatlistsHideChatlistUpdates) (*Bool, error)
	ChatlistsGetLeaveChatlistSuggestions(ctx context.Context, in *TLChatlistsGetLeaveChatlistSuggestions) (*VectorPeer, error)
	ChatlistsLeaveChatlist(ctx context.Context, in *TLChatlistsLeaveChatlist) (*Updates, error)
}

type RPCMiscellaneous interface {
	HelpSaveAppLog(ctx context.Context, in *TLHelpSaveAppLog) (*Bool, error)
}

type RPCBoosts interface {
	ChannelsSetBoostsToUnblockRestrictions(ctx context.Context, in *TLChannelsSetBoostsToUnblockRestrictions) (*Updates, error)
	PremiumGetBoostsList(ctx context.Context, in *TLPremiumGetBoostsList) (*PremiumBoostsList, error)
	PremiumGetMyBoosts(ctx context.Context, in *TLPremiumGetMyBoosts) (*PremiumMyBoosts, error)
	PremiumApplyBoost(ctx context.Context, in *TLPremiumApplyBoost) (*PremiumMyBoosts, error)
	PremiumGetBoostsStatus(ctx context.Context, in *TLPremiumGetBoostsStatus) (*PremiumBoostsStatus, error)
	PremiumGetUserBoosts(ctx context.Context, in *TLPremiumGetUserBoosts) (*PremiumBoostsList, error)
}

type RPCGroupCalls interface {
	PhoneCreateGroupCall(ctx context.Context, in *TLPhoneCreateGroupCall) (*Updates, error)
	PhoneJoinGroupCall(ctx context.Context, in *TLPhoneJoinGroupCall) (*Updates, error)
	PhoneLeaveGroupCall(ctx context.Context, in *TLPhoneLeaveGroupCall) (*Updates, error)
	PhoneInviteToGroupCall(ctx context.Context, in *TLPhoneInviteToGroupCall) (*Updates, error)
	PhoneDiscardGroupCall(ctx context.Context, in *TLPhoneDiscardGroupCall) (*Updates, error)
	PhoneToggleGroupCallSettings(ctx context.Context, in *TLPhoneToggleGroupCallSettings) (*Updates, error)
	PhoneGetGroupCall(ctx context.Context, in *TLPhoneGetGroupCall) (*PhoneGroupCall, error)
	PhoneGetGroupParticipants(ctx context.Context, in *TLPhoneGetGroupParticipants) (*PhoneGroupParticipants, error)
	PhoneCheckGroupCall(ctx context.Context, in *TLPhoneCheckGroupCall) (*VectorInt, error)
	PhoneToggleGroupCallRecord(ctx context.Context, in *TLPhoneToggleGroupCallRecord) (*Updates, error)
	PhoneEditGroupCallParticipant(ctx context.Context, in *TLPhoneEditGroupCallParticipant) (*Updates, error)
	PhoneEditGroupCallTitle(ctx context.Context, in *TLPhoneEditGroupCallTitle) (*Updates, error)
	PhoneGetGroupCallJoinAs(ctx context.Context, in *TLPhoneGetGroupCallJoinAs) (*PhoneJoinAsPeers, error)
	PhoneExportGroupCallInvite(ctx context.Context, in *TLPhoneExportGroupCallInvite) (*PhoneExportedGroupCallInvite, error)
	PhoneToggleGroupCallStartSubscription(ctx context.Context, in *TLPhoneToggleGroupCallStartSubscription) (*Updates, error)
	PhoneStartScheduledGroupCall(ctx context.Context, in *TLPhoneStartScheduledGroupCall) (*Updates, error)
	PhoneSaveDefaultGroupCallJoinAs(ctx context.Context, in *TLPhoneSaveDefaultGroupCallJoinAs) (*Bool, error)
	PhoneJoinGroupCallPresentation(ctx context.Context, in *TLPhoneJoinGroupCallPresentation) (*Updates, error)
	PhoneLeaveGroupCallPresentation(ctx context.Context, in *TLPhoneLeaveGroupCallPresentation) (*Updates, error)
	PhoneGetGroupCallStreamChannels(ctx context.Context, in *TLPhoneGetGroupCallStreamChannels) (*PhoneGroupCallStreamChannels, error)
	PhoneGetGroupCallStreamRtmpUrl(ctx context.Context, in *TLPhoneGetGroupCallStreamRtmpUrl) (*PhoneGroupCallStreamRtmpUrl, error)
}

type RPCPrivacySettings interface {
	AccountGetPrivacy(ctx context.Context, in *TLAccountGetPrivacy) (*AccountPrivacyRules, error)
	AccountSetPrivacy(ctx context.Context, in *TLAccountSetPrivacy) (*AccountPrivacyRules, error)
	AccountGetGlobalPrivacySettings(ctx context.Context, in *TLAccountGetGlobalPrivacySettings) (*GlobalPrivacySettings, error)
	AccountSetGlobalPrivacySettings(ctx context.Context, in *TLAccountSetGlobalPrivacySettings) (*GlobalPrivacySettings, error)
	UsersGetRequirementsToContact(ctx context.Context, in *TLUsersGetRequirementsToContact) (*VectorRequirementToContact, error)
	MessagesSetDefaultHistoryTTL(ctx context.Context, in *TLMessagesSetDefaultHistoryTTL) (*Bool, error)
	MessagesGetDefaultHistoryTTL(ctx context.Context, in *TLMessagesGetDefaultHistoryTTL) (*DefaultHistoryTTL, error)
	UsersGetIsPremiumRequiredToContact(ctx context.Context, in *TLUsersGetIsPremiumRequiredToContact) (*VectorBool, error)
}

type RPCUsernames interface {
	AccountCheckUsername(ctx context.Context, in *TLAccountCheckUsername) (*Bool, error)
	AccountUpdateUsername(ctx context.Context, in *TLAccountUpdateUsername) (*User, error)
	ContactsResolveUsername(ctx context.Context, in *TLContactsResolveUsername) (*ContactsResolvedPeer, error)
	ChannelsCheckUsername(ctx context.Context, in *TLChannelsCheckUsername) (*Bool, error)
	ChannelsUpdateUsername(ctx context.Context, in *TLChannelsUpdateUsername) (*Bool, error)
}

type RPCFragment interface {
	AccountReorderUsernames(ctx context.Context, in *TLAccountReorderUsernames) (*Bool, error)
	AccountToggleUsername(ctx context.Context, in *TLAccountToggleUsername) (*Bool, error)
	ChannelsReorderUsernames(ctx context.Context, in *TLChannelsReorderUsernames) (*Bool, error)
	ChannelsToggleUsername(ctx context.Context, in *TLChannelsToggleUsername) (*Bool, error)
	ChannelsDeactivateAllUsernames(ctx context.Context, in *TLChannelsDeactivateAllUsernames) (*Bool, error)
	BotsReorderUsernames(ctx context.Context, in *TLBotsReorderUsernames) (*Bool, error)
	BotsToggleUsername(ctx context.Context, in *TLBotsToggleUsername) (*Bool, error)
}

type RPCAutosave interface {
	AccountGetAutoSaveSettings(ctx context.Context, in *TLAccountGetAutoSaveSettings) (*AccountAutoSaveSettings, error)
	AccountSaveAutoSaveSettings(ctx context.Context, in *TLAccountSaveAutoSaveSettings) (*Bool, error)
	AccountDeleteAutoSaveExceptions(ctx context.Context, in *TLAccountDeleteAutoSaveExceptions) (*Bool, error)
}

type RPCBusinessLocation interface {
	AccountUpdateBusinessLocation(ctx context.Context, in *TLAccountUpdateBusinessLocation) (*Bool, error)
}

type RPCBusinessIntro interface {
	AccountUpdateBusinessIntro(ctx context.Context, in *TLAccountUpdateBusinessIntro) (*Bool, error)
}

type RPCMessages interface {
	MessagesGetMessages(ctx context.Context, in *TLMessagesGetMessages) (*MessagesMessages, error)
	MessagesGetHistory(ctx context.Context, in *TLMessagesGetHistory) (*MessagesMessages, error)
	MessagesSearch(ctx context.Context, in *TLMessagesSearch) (*MessagesMessages, error)
	MessagesReadHistory(ctx context.Context, in *TLMessagesReadHistory) (*MessagesAffectedMessages, error)
	MessagesDeleteHistory(ctx context.Context, in *TLMessagesDeleteHistory) (*MessagesAffectedHistory, error)
	MessagesDeleteMessages(ctx context.Context, in *TLMessagesDeleteMessages) (*MessagesAffectedMessages, error)
	MessagesReceivedMessages(ctx context.Context, in *TLMessagesReceivedMessages) (*VectorReceivedNotifyMessage, error)
	MessagesSendMessage(ctx context.Context, in *TLMessagesSendMessage) (*Updates, error)
	MessagesSendMedia(ctx context.Context, in *TLMessagesSendMedia) (*Updates, error)
	MessagesForwardMessages(ctx context.Context, in *TLMessagesForwardMessages) (*Updates, error)
	MessagesReadMessageContents(ctx context.Context, in *TLMessagesReadMessageContents) (*MessagesAffectedMessages, error)
	MessagesGetMessagesViews(ctx context.Context, in *TLMessagesGetMessagesViews) (*MessagesMessageViews, error)
	MessagesSearchGlobal(ctx context.Context, in *TLMessagesSearchGlobal) (*MessagesMessages, error)
	MessagesGetMessageEditData(ctx context.Context, in *TLMessagesGetMessageEditData) (*MessagesMessageEditData, error)
	MessagesEditMessage(ctx context.Context, in *TLMessagesEditMessage) (*Updates, error)
	MessagesGetUnreadMentions(ctx context.Context, in *TLMessagesGetUnreadMentions) (*MessagesMessages, error)
	MessagesReadMentions(ctx context.Context, in *TLMessagesReadMentions) (*MessagesAffectedHistory, error)
	MessagesGetRecentLocations(ctx context.Context, in *TLMessagesGetRecentLocations) (*MessagesMessages, error)
	MessagesSendMultiMedia(ctx context.Context, in *TLMessagesSendMultiMedia) (*Updates, error)
	MessagesUpdatePinnedMessage(ctx context.Context, in *TLMessagesUpdatePinnedMessage) (*Updates, error)
	MessagesGetSearchCounters(ctx context.Context, in *TLMessagesGetSearchCounters) (*VectorMessagesSearchCounter, error)
	MessagesUnpinAllMessages(ctx context.Context, in *TLMessagesUnpinAllMessages) (*MessagesAffectedHistory, error)
	MessagesGetSearchResultsCalendar(ctx context.Context, in *TLMessagesGetSearchResultsCalendar) (*MessagesSearchResultsCalendar, error)
	MessagesGetSearchResultsPositions(ctx context.Context, in *TLMessagesGetSearchResultsPositions) (*MessagesSearchResultsPositions, error)
	MessagesToggleNoForwards(ctx context.Context, in *TLMessagesToggleNoForwards) (*Updates, error)
	MessagesSaveDefaultSendAs(ctx context.Context, in *TLMessagesSaveDefaultSendAs) (*Bool, error)
	MessagesSearchSentMedia(ctx context.Context, in *TLMessagesSearchSentMedia) (*MessagesMessages, error)
	MessagesGetOutboxReadDate(ctx context.Context, in *TLMessagesGetOutboxReadDate) (*OutboxReadDate, error)
	MessagesReportMessagesDelivery(ctx context.Context, in *TLMessagesReportMessagesDelivery) (*Bool, error)
	ChannelsGetSendAs(ctx context.Context, in *TLChannelsGetSendAs) (*ChannelsSendAsPeers, error)
	ChannelsSearchPosts(ctx context.Context, in *TLChannelsSearchPosts) (*MessagesMessages, error)
}

type RPCChats interface {
	MessagesGetChats(ctx context.Context, in *TLMessagesGetChats) (*MessagesChats, error)
	MessagesGetFullChat(ctx context.Context, in *TLMessagesGetFullChat) (*MessagesChatFull, error)
	MessagesEditChatTitle(ctx context.Context, in *TLMessagesEditChatTitle) (*Updates, error)
	MessagesEditChatPhoto(ctx context.Context, in *TLMessagesEditChatPhoto) (*Updates, error)
	MessagesAddChatUser(ctx context.Context, in *TLMessagesAddChatUser) (*MessagesInvitedUsers, error)
	MessagesDeleteChatUser(ctx context.Context, in *TLMessagesDeleteChatUser) (*Updates, error)
	MessagesCreateChat(ctx context.Context, in *TLMessagesCreateChat) (*MessagesInvitedUsers, error)
	MessagesEditChatAdmin(ctx context.Context, in *TLMessagesEditChatAdmin) (*Bool, error)
	MessagesMigrateChat(ctx context.Context, in *TLMessagesMigrateChat) (*Updates, error)
	MessagesGetCommonChats(ctx context.Context, in *TLMessagesGetCommonChats) (*MessagesChats, error)
	MessagesEditChatAbout(ctx context.Context, in *TLMessagesEditChatAbout) (*Bool, error)
	MessagesEditChatDefaultBannedRights(ctx context.Context, in *TLMessagesEditChatDefaultBannedRights) (*Updates, error)
	MessagesDeleteChat(ctx context.Context, in *TLMessagesDeleteChat) (*Bool, error)
	MessagesGetMessageReadParticipants(ctx context.Context, in *TLMessagesGetMessageReadParticipants) (*VectorReadParticipantDate, error)
	ChannelsConvertToGigagroup(ctx context.Context, in *TLChannelsConvertToGigagroup) (*Updates, error)
	ChannelsSetEmojiStickers(ctx context.Context, in *TLChannelsSetEmojiStickers) (*Bool, error)
}

type RPCWallpapers interface {
	AccountGetWallPapers(ctx context.Context, in *TLAccountGetWallPapers) (*AccountWallPapers, error)
	AccountGetWallPaper(ctx context.Context, in *TLAccountGetWallPaper) (*WallPaper, error)
	AccountUploadWallPaper(ctx context.Context, in *TLAccountUploadWallPaper) (*WallPaper, error)
	AccountSaveWallPaper(ctx context.Context, in *TLAccountSaveWallPaper) (*Bool, error)
	AccountInstallWallPaper(ctx context.Context, in *TLAccountInstallWallPaper) (*Bool, error)
	AccountResetWallPapers(ctx context.Context, in *TLAccountResetWallPapers) (*Bool, error)
	AccountGetMultiWallPapers(ctx context.Context, in *TLAccountGetMultiWallPapers) (*VectorWallPaper, error)
	MessagesSetChatWallPaper(ctx context.Context, in *TLMessagesSetChatWallPaper) (*Updates, error)
}

type RPCGames interface {
	MessagesSetGameScore(ctx context.Context, in *TLMessagesSetGameScore) (*Updates, error)
	MessagesSetInlineGameScore(ctx context.Context, in *TLMessagesSetInlineGameScore) (*Bool, error)
	MessagesGetGameHighScores(ctx context.Context, in *TLMessagesGetGameHighScores) (*MessagesHighScores, error)
	MessagesGetInlineGameHighScores(ctx context.Context, in *TLMessagesGetInlineGameHighScores) (*MessagesHighScores, error)
}

type RPCChannels interface {
	ChannelsReadHistory(ctx context.Context, in *TLChannelsReadHistory) (*Bool, error)
	ChannelsDeleteMessages(ctx context.Context, in *TLChannelsDeleteMessages) (*MessagesAffectedMessages, error)
	ChannelsGetMessages(ctx context.Context, in *TLChannelsGetMessages) (*MessagesMessages, error)
	ChannelsGetParticipants(ctx context.Context, in *TLChannelsGetParticipants) (*ChannelsChannelParticipants, error)
	ChannelsGetParticipant(ctx context.Context, in *TLChannelsGetParticipant) (*ChannelsChannelParticipant, error)
	ChannelsGetChannels(ctx context.Context, in *TLChannelsGetChannels) (*MessagesChats, error)
	ChannelsGetFullChannel(ctx context.Context, in *TLChannelsGetFullChannel) (*MessagesChatFull, error)
	ChannelsCreateChannel(ctx context.Context, in *TLChannelsCreateChannel) (*Updates, error)
	ChannelsEditAdmin(ctx context.Context, in *TLChannelsEditAdmin) (*Updates, error)
	ChannelsEditTitle(ctx context.Context, in *TLChannelsEditTitle) (*Updates, error)
	ChannelsEditPhoto(ctx context.Context, in *TLChannelsEditPhoto) (*Updates, error)
	ChannelsJoinChannel(ctx context.Context, in *TLChannelsJoinChannel) (*Updates, error)
	ChannelsLeaveChannel(ctx context.Context, in *TLChannelsLeaveChannel) (*Updates, error)
	ChannelsInviteToChannel(ctx context.Context, in *TLChannelsInviteToChannel) (*MessagesInvitedUsers, error)
	ChannelsDeleteChannel(ctx context.Context, in *TLChannelsDeleteChannel) (*Updates, error)
	ChannelsExportMessageLink(ctx context.Context, in *TLChannelsExportMessageLink) (*ExportedMessageLink, error)
	ChannelsToggleSignatures(ctx context.Context, in *TLChannelsToggleSignatures) (*Updates, error)
	ChannelsGetAdminedPublicChannels(ctx context.Context, in *TLChannelsGetAdminedPublicChannels) (*MessagesChats, error)
	ChannelsEditBanned(ctx context.Context, in *TLChannelsEditBanned) (*Updates, error)
	ChannelsGetAdminLog(ctx context.Context, in *TLChannelsGetAdminLog) (*ChannelsAdminLogResults, error)
	ChannelsSetStickers(ctx context.Context, in *TLChannelsSetStickers) (*Bool, error)
	ChannelsReadMessageContents(ctx context.Context, in *TLChannelsReadMessageContents) (*Bool, error)
	ChannelsDeleteHistory(ctx context.Context, in *TLChannelsDeleteHistory) (*Updates, error)
	ChannelsTogglePreHistoryHidden(ctx context.Context, in *TLChannelsTogglePreHistoryHidden) (*Updates, error)
	ChannelsGetGroupsForDiscussion(ctx context.Context, in *TLChannelsGetGroupsForDiscussion) (*MessagesChats, error)
	ChannelsSetDiscussionGroup(ctx context.Context, in *TLChannelsSetDiscussionGroup) (*Bool, error)
	ChannelsEditCreator(ctx context.Context, in *TLChannelsEditCreator) (*Updates, error)
	ChannelsEditLocation(ctx context.Context, in *TLChannelsEditLocation) (*Bool, error)
	ChannelsToggleSlowMode(ctx context.Context, in *TLChannelsToggleSlowMode) (*Updates, error)
	ChannelsGetInactiveChannels(ctx context.Context, in *TLChannelsGetInactiveChannels) (*MessagesInactiveChats, error)
	ChannelsDeleteParticipantHistory(ctx context.Context, in *TLChannelsDeleteParticipantHistory) (*MessagesAffectedHistory, error)
	ChannelsToggleParticipantsHidden(ctx context.Context, in *TLChannelsToggleParticipantsHidden) (*Updates, error)
}

type RPCDeepLinks interface {
	MessagesStartBot(ctx context.Context, in *TLMessagesStartBot) (*Updates, error)
	HelpGetRecentMeUrls(ctx context.Context, in *TLHelpGetRecentMeUrls) (*HelpRecentMeUrls, error)
	HelpGetDeepLinkInfo(ctx context.Context, in *TLHelpGetDeepLinkInfo) (*HelpDeepLinkInfo, error)
}

type RPCPremium interface {
	HelpGetPremiumPromo(ctx context.Context, in *TLHelpGetPremiumPromo) (*HelpPremiumPromo, error)
	PaymentsAssignAppStoreTransaction(ctx context.Context, in *TLPaymentsAssignAppStoreTransaction) (*Updates, error)
	PaymentsAssignPlayMarketTransaction(ctx context.Context, in *TLPaymentsAssignPlayMarketTransaction) (*Updates, error)
	PaymentsCanPurchaseStore(ctx context.Context, in *TLPaymentsCanPurchaseStore) (*Bool, error)
	PaymentsCanPurchasePremium(ctx context.Context, in *TLPaymentsCanPurchasePremium) (*Bool, error)
}

type RPCNsfw interface {
	AccountSetContentSettings(ctx context.Context, in *TLAccountSetContentSettings) (*Bool, error)
	AccountGetContentSettings(ctx context.Context, in *TLAccountGetContentSettings) (*AccountContentSettings, error)
}

type RPCCustomEmojis interface {
	AccountGetDefaultProfilePhotoEmojis(ctx context.Context, in *TLAccountGetDefaultProfilePhotoEmojis) (*EmojiList, error)
	AccountGetDefaultGroupPhotoEmojis(ctx context.Context, in *TLAccountGetDefaultGroupPhotoEmojis) (*EmojiList, error)
	MessagesGetCustomEmojiDocuments(ctx context.Context, in *TLMessagesGetCustomEmojiDocuments) (*VectorDocument, error)
	MessagesGetEmojiStickers(ctx context.Context, in *TLMessagesGetEmojiStickers) (*MessagesAllStickers, error)
	MessagesGetFeaturedEmojiStickers(ctx context.Context, in *TLMessagesGetFeaturedEmojiStickers) (*MessagesFeaturedStickers, error)
	MessagesSearchCustomEmoji(ctx context.Context, in *TLMessagesSearchCustomEmoji) (*EmojiList, error)
}

type RPCChatInvites interface {
	MessagesExportChatInvite(ctx context.Context, in *TLMessagesExportChatInvite) (*ExportedChatInvite, error)
	MessagesCheckChatInvite(ctx context.Context, in *TLMessagesCheckChatInvite) (*ChatInvite, error)
	MessagesImportChatInvite(ctx context.Context, in *TLMessagesImportChatInvite) (*Updates, error)
	MessagesGetExportedChatInvites(ctx context.Context, in *TLMessagesGetExportedChatInvites) (*MessagesExportedChatInvites, error)
	MessagesGetExportedChatInvite(ctx context.Context, in *TLMessagesGetExportedChatInvite) (*MessagesExportedChatInvite, error)
	MessagesEditExportedChatInvite(ctx context.Context, in *TLMessagesEditExportedChatInvite) (*MessagesExportedChatInvite, error)
	MessagesDeleteRevokedExportedChatInvites(ctx context.Context, in *TLMessagesDeleteRevokedExportedChatInvites) (*Bool, error)
	MessagesDeleteExportedChatInvite(ctx context.Context, in *TLMessagesDeleteExportedChatInvite) (*Bool, error)
	MessagesGetAdminsWithInvites(ctx context.Context, in *TLMessagesGetAdminsWithInvites) (*MessagesChatAdminsWithInvites, error)
	MessagesGetChatInviteImporters(ctx context.Context, in *TLMessagesGetChatInviteImporters) (*MessagesChatInviteImporters, error)
	MessagesHideChatJoinRequest(ctx context.Context, in *TLMessagesHideChatJoinRequest) (*Updates, error)
	MessagesHideAllChatJoinRequests(ctx context.Context, in *TLMessagesHideAllChatJoinRequests) (*Updates, error)
	ChannelsToggleJoinToSend(ctx context.Context, in *TLChannelsToggleJoinToSend) (*Updates, error)
	ChannelsToggleJoinRequest(ctx context.Context, in *TLChannelsToggleJoinRequest) (*Updates, error)
}

type RPCBusinessQuickReply interface {
	MessagesGetQuickReplies(ctx context.Context, in *TLMessagesGetQuickReplies) (*MessagesQuickReplies, error)
	MessagesReorderQuickReplies(ctx context.Context, in *TLMessagesReorderQuickReplies) (*Bool, error)
	MessagesCheckQuickReplyShortcut(ctx context.Context, in *TLMessagesCheckQuickReplyShortcut) (*Bool, error)
	MessagesEditQuickReplyShortcut(ctx context.Context, in *TLMessagesEditQuickReplyShortcut) (*Bool, error)
	MessagesDeleteQuickReplyShortcut(ctx context.Context, in *TLMessagesDeleteQuickReplyShortcut) (*Bool, error)
	MessagesGetQuickReplyMessages(ctx context.Context, in *TLMessagesGetQuickReplyMessages) (*MessagesMessages, error)
	MessagesSendQuickReplyMessages(ctx context.Context, in *TLMessagesSendQuickReplyMessages) (*Updates, error)
	MessagesDeleteQuickReplyMessages(ctx context.Context, in *TLMessagesDeleteQuickReplyMessages) (*Updates, error)
}

type RPCPreparedInlineMessages interface {
	MessagesSavePreparedInlineMessage(ctx context.Context, in *TLMessagesSavePreparedInlineMessage) (*MessagesBotPreparedInlineMessage, error)
	MessagesGetPreparedInlineMessage(ctx context.Context, in *TLMessagesGetPreparedInlineMessage) (*MessagesPreparedInlineMessage, error)
}

type RPCAuthorization interface {
	AuthSendCode(ctx context.Context, in *TLAuthSendCode) (*AuthSentCode, error)
	AuthSignUp(ctx context.Context, in *TLAuthSignUp) (*AuthAuthorization, error)
	AuthSignIn(ctx context.Context, in *TLAuthSignIn) (*AuthAuthorization, error)
	AuthLogOut(ctx context.Context, in *TLAuthLogOut) (*AuthLoggedOut, error)
	AuthResetAuthorizations(ctx context.Context, in *TLAuthResetAuthorizations) (*Bool, error)
	AuthExportAuthorization(ctx context.Context, in *TLAuthExportAuthorization) (*AuthExportedAuthorization, error)
	AuthImportAuthorization(ctx context.Context, in *TLAuthImportAuthorization) (*AuthAuthorization, error)
	AuthBindTempAuthKey(ctx context.Context, in *TLAuthBindTempAuthKey) (*Bool, error)
	AuthImportBotAuthorization(ctx context.Context, in *TLAuthImportBotAuthorization) (*AuthAuthorization, error)
	AuthCheckPassword(ctx context.Context, in *TLAuthCheckPassword) (*AuthAuthorization, error)
	AuthRequestPasswordRecovery(ctx context.Context, in *TLAuthRequestPasswordRecovery) (*AuthPasswordRecovery, error)
	AuthRecoverPassword(ctx context.Context, in *TLAuthRecoverPassword) (*AuthAuthorization, error)
	AuthResendCode(ctx context.Context, in *TLAuthResendCode) (*AuthSentCode, error)
	AuthCancelCode(ctx context.Context, in *TLAuthCancelCode) (*Bool, error)
	AuthDropTempAuthKeys(ctx context.Context, in *TLAuthDropTempAuthKeys) (*Bool, error)
	AuthCheckRecoveryPassword(ctx context.Context, in *TLAuthCheckRecoveryPassword) (*Bool, error)
	AuthImportWebTokenAuthorization(ctx context.Context, in *TLAuthImportWebTokenAuthorization) (*AuthAuthorization, error)
	AuthRequestFirebaseSms(ctx context.Context, in *TLAuthRequestFirebaseSms) (*Bool, error)
	AuthResetLoginEmail(ctx context.Context, in *TLAuthResetLoginEmail) (*AuthSentCode, error)
	AuthReportMissingCode(ctx context.Context, in *TLAuthReportMissingCode) (*Bool, error)
	AccountSendVerifyEmailCode(ctx context.Context, in *TLAccountSendVerifyEmailCode) (*AccountSentEmailCode, error)
	AccountVerifyEmail(ctx context.Context, in *TLAccountVerifyEmail) (*AccountEmailVerified, error)
	AccountResetPassword(ctx context.Context, in *TLAccountResetPassword) (*AccountResetPasswordResult, error)
	AccountSetAuthorizationTTL(ctx context.Context, in *TLAccountSetAuthorizationTTL) (*Bool, error)
	AccountChangeAuthorizationSettings(ctx context.Context, in *TLAccountChangeAuthorizationSettings) (*Bool, error)
	AccountInvalidateSignInCodes(ctx context.Context, in *TLAccountInvalidateSignInCodes) (*Bool, error)
	AuthToggleBan(ctx context.Context, in *TLAuthToggleBan) (*PredefinedUser, error)
}

type RPCAutoDownload interface {
	AccountGetAutoDownloadSettings(ctx context.Context, in *TLAccountGetAutoDownloadSettings) (*AccountAutoDownloadSettings, error)
	AccountSaveAutoDownloadSettings(ctx context.Context, in *TLAccountSaveAutoDownloadSettings) (*Bool, error)
}

type RPCThemes interface {
	AccountUploadTheme(ctx context.Context, in *TLAccountUploadTheme) (*Document, error)
	AccountCreateTheme(ctx context.Context, in *TLAccountCreateTheme) (*Theme, error)
	AccountUpdateTheme(ctx context.Context, in *TLAccountUpdateTheme) (*Theme, error)
	AccountSaveTheme(ctx context.Context, in *TLAccountSaveTheme) (*Bool, error)
	AccountInstallTheme(ctx context.Context, in *TLAccountInstallTheme) (*Bool, error)
	AccountGetTheme(ctx context.Context, in *TLAccountGetTheme) (*Theme, error)
	AccountGetThemes(ctx context.Context, in *TLAccountGetThemes) (*AccountThemes, error)
	AccountGetChatThemes(ctx context.Context, in *TLAccountGetChatThemes) (*AccountThemes, error)
	MessagesSetChatTheme(ctx context.Context, in *TLMessagesSetChatTheme) (*Updates, error)
}

type RPCAccentColors interface {
	AccountUpdateColor(ctx context.Context, in *TLAccountUpdateColor) (*Bool, error)
	AccountGetDefaultBackgroundEmojis(ctx context.Context, in *TLAccountGetDefaultBackgroundEmojis) (*EmojiList, error)
	HelpGetPeerColors(ctx context.Context, in *TLHelpGetPeerColors) (*HelpPeerColors, error)
	HelpGetPeerProfileColors(ctx context.Context, in *TLHelpGetPeerProfileColors) (*HelpPeerColors, error)
	ChannelsUpdateColor(ctx context.Context, in *TLChannelsUpdateColor) (*Updates, error)
}

type RPCPaidMessage interface {
	AccountAddNoPaidMessagesException(ctx context.Context, in *TLAccountAddNoPaidMessagesException) (*Bool, error)
	AccountGetPaidMessagesRevenue(ctx context.Context, in *TLAccountGetPaidMessagesRevenue) (*AccountPaidMessagesRevenue, error)
	ChannelsUpdatePaidMessagesPrice(ctx context.Context, in *TLChannelsUpdatePaidMessagesPrice) (*Updates, error)
}

type RPCMessageThreads interface {
	ContactsBlockFromReplies(ctx context.Context, in *TLContactsBlockFromReplies) (*Updates, error)
	MessagesGetReplies(ctx context.Context, in *TLMessagesGetReplies) (*MessagesMessages, error)
	MessagesGetDiscussionMessage(ctx context.Context, in *TLMessagesGetDiscussionMessage) (*MessagesDiscussionMessage, error)
	MessagesReadDiscussion(ctx context.Context, in *TLMessagesReadDiscussion) (*Bool, error)
}

type RPCEmojiCategories interface {
	MessagesGetEmojiGroups(ctx context.Context, in *TLMessagesGetEmojiGroups) (*MessagesEmojiGroups, error)
	MessagesGetEmojiStatusGroups(ctx context.Context, in *TLMessagesGetEmojiStatusGroups) (*MessagesEmojiGroups, error)
	MessagesGetEmojiProfilePhotoGroups(ctx context.Context, in *TLMessagesGetEmojiProfilePhotoGroups) (*MessagesEmojiGroups, error)
	MessagesGetEmojiStickerGroups(ctx context.Context, in *TLMessagesGetEmojiStickerGroups) (*MessagesEmojiGroups, error)
}

type RPCMainMiniBotApps interface {
	MessagesRequestMainWebView(ctx context.Context, in *TLMessagesRequestMainWebView) (*WebViewResult, error)
	BotsGetPopularAppBots(ctx context.Context, in *TLBotsGetPopularAppBots) (*BotsPopularAppBots, error)
	BotsAddPreviewMedia(ctx context.Context, in *TLBotsAddPreviewMedia) (*BotPreviewMedia, error)
	BotsEditPreviewMedia(ctx context.Context, in *TLBotsEditPreviewMedia) (*BotPreviewMedia, error)
	BotsDeletePreviewMedia(ctx context.Context, in *TLBotsDeletePreviewMedia) (*Bool, error)
	BotsReorderPreviewMedias(ctx context.Context, in *TLBotsReorderPreviewMedias) (*Bool, error)
	BotsGetPreviewInfo(ctx context.Context, in *TLBotsGetPreviewInfo) (*BotsPreviewInfo, error)
	BotsGetPreviewMedias(ctx context.Context, in *TLBotsGetPreviewMedias) (*VectorBotPreviewMedia, error)
}

type RPCPassport interface {
	AccountGetAuthorizations(ctx context.Context, in *TLAccountGetAuthorizations) (*AccountAuthorizations, error)
	AccountGetAllSecureValues(ctx context.Context, in *TLAccountGetAllSecureValues) (*VectorSecureValue, error)
	AccountGetSecureValue(ctx context.Context, in *TLAccountGetSecureValue) (*VectorSecureValue, error)
	AccountSaveSecureValue(ctx context.Context, in *TLAccountSaveSecureValue) (*SecureValue, error)
	AccountDeleteSecureValue(ctx context.Context, in *TLAccountDeleteSecureValue) (*Bool, error)
	AccountGetAuthorizationForm(ctx context.Context, in *TLAccountGetAuthorizationForm) (*AccountAuthorizationForm, error)
	AccountAcceptAuthorization(ctx context.Context, in *TLAccountAcceptAuthorization) (*Bool, error)
	AccountSendVerifyPhoneCode(ctx context.Context, in *TLAccountSendVerifyPhoneCode) (*AuthSentCode, error)
	AccountVerifyPhone(ctx context.Context, in *TLAccountVerifyPhone) (*Bool, error)
	UsersSetSecureValueErrors(ctx context.Context, in *TLUsersSetSecureValueErrors) (*Bool, error)
	HelpGetPassportConfig(ctx context.Context, in *TLHelpGetPassportConfig) (*HelpPassportConfig, error)
}

type RPCAntiSpam interface {
	ChannelsToggleAntiSpam(ctx context.Context, in *TLChannelsToggleAntiSpam) (*Updates, error)
	ChannelsReportAntiSpamFalsePositive(ctx context.Context, in *TLChannelsReportAntiSpamFalsePositive) (*Bool, error)
}

type RPCForums interface {
	ChannelsToggleForum(ctx context.Context, in *TLChannelsToggleForum) (*Updates, error)
	ChannelsCreateForumTopic(ctx context.Context, in *TLChannelsCreateForumTopic) (*Updates, error)
	ChannelsGetForumTopics(ctx context.Context, in *TLChannelsGetForumTopics) (*MessagesForumTopics, error)
	ChannelsGetForumTopicsByID(ctx context.Context, in *TLChannelsGetForumTopicsByID) (*MessagesForumTopics, error)
	ChannelsEditForumTopic(ctx context.Context, in *TLChannelsEditForumTopic) (*Updates, error)
	ChannelsUpdatePinnedForumTopic(ctx context.Context, in *TLChannelsUpdatePinnedForumTopic) (*Updates, error)
	ChannelsDeleteTopicHistory(ctx context.Context, in *TLChannelsDeleteTopicHistory) (*MessagesAffectedHistory, error)
	ChannelsReorderPinnedForumTopics(ctx context.Context, in *TLChannelsReorderPinnedForumTopics) (*Updates, error)
	ChannelsToggleViewForumAsMessages(ctx context.Context, in *TLChannelsToggleViewForumAsMessages) (*Updates, error)
}

type RPCContacts interface {
	AccountGetContactSignUpNotification(ctx context.Context, in *TLAccountGetContactSignUpNotification) (*Bool, error)
	AccountSetContactSignUpNotification(ctx context.Context, in *TLAccountSetContactSignUpNotification) (*Bool, error)
	ContactsGetContactIDs(ctx context.Context, in *TLContactsGetContactIDs) (*VectorInt, error)
	ContactsGetStatuses(ctx context.Context, in *TLContactsGetStatuses) (*VectorContactStatus, error)
	ContactsGetContacts(ctx context.Context, in *TLContactsGetContacts) (*ContactsContacts, error)
	ContactsImportContacts(ctx context.Context, in *TLContactsImportContacts) (*ContactsImportedContacts, error)
	ContactsDeleteContacts(ctx context.Context, in *TLContactsDeleteContacts) (*Updates, error)
	ContactsDeleteByPhones(ctx context.Context, in *TLContactsDeleteByPhones) (*Bool, error)
	ContactsBlock(ctx context.Context, in *TLContactsBlock) (*Bool, error)
	ContactsUnblock(ctx context.Context, in *TLContactsUnblock) (*Bool, error)
	ContactsGetBlocked(ctx context.Context, in *TLContactsGetBlocked) (*ContactsBlocked, error)
	ContactsSearch(ctx context.Context, in *TLContactsSearch) (*ContactsFound, error)
	ContactsGetTopPeers(ctx context.Context, in *TLContactsGetTopPeers) (*ContactsTopPeers, error)
	ContactsResetTopPeerRating(ctx context.Context, in *TLContactsResetTopPeerRating) (*Bool, error)
	ContactsResetSaved(ctx context.Context, in *TLContactsResetSaved) (*Bool, error)
	ContactsGetSaved(ctx context.Context, in *TLContactsGetSaved) (*VectorSavedContact, error)
	ContactsToggleTopPeers(ctx context.Context, in *TLContactsToggleTopPeers) (*Bool, error)
	ContactsAddContact(ctx context.Context, in *TLContactsAddContact) (*Updates, error)
	ContactsAcceptContact(ctx context.Context, in *TLContactsAcceptContact) (*Updates, error)
	ContactsGetLocated(ctx context.Context, in *TLContactsGetLocated) (*Updates, error)
	ContactsEditCloseFriends(ctx context.Context, in *TLContactsEditCloseFriends) (*Bool, error)
	ContactsSetBlocked(ctx context.Context, in *TLContactsSetBlocked) (*Bool, error)
}

type RPCDrafts interface {
	MessagesSaveDraft(ctx context.Context, in *TLMessagesSaveDraft) (*Bool, error)
	MessagesGetAllDrafts(ctx context.Context, in *TLMessagesGetAllDrafts) (*Updates, error)
	MessagesClearAllDrafts(ctx context.Context, in *TLMessagesClearAllDrafts) (*Bool, error)
}

type RPCMessageEffects interface {
	MessagesGetAvailableEffects(ctx context.Context, in *TLMessagesGetAvailableEffects) (*MessagesAvailableEffects, error)
}

type RPCFactChecks interface {
	MessagesEditFactCheck(ctx context.Context, in *TLMessagesEditFactCheck) (*Updates, error)
	MessagesDeleteFactCheck(ctx context.Context, in *TLMessagesDeleteFactCheck) (*Updates, error)
	MessagesGetFactCheck(ctx context.Context, in *TLMessagesGetFactCheck) (*VectorFactCheck, error)
}

type RPCTos interface {
	HelpGetTermsOfServiceUpdate(ctx context.Context, in *TLHelpGetTermsOfServiceUpdate) (*HelpTermsOfServiceUpdate, error)
	HelpAcceptTermsOfService(ctx context.Context, in *TLHelpAcceptTermsOfService) (*Bool, error)
}

type RPCStars interface {
	PaymentsGetStarsTopupOptions(ctx context.Context, in *TLPaymentsGetStarsTopupOptions) (*VectorStarsTopupOption, error)
	PaymentsGetStarsStatus(ctx context.Context, in *TLPaymentsGetStarsStatus) (*PaymentsStarsStatus, error)
	PaymentsGetStarsTransactions(ctx context.Context, in *TLPaymentsGetStarsTransactions) (*PaymentsStarsStatus, error)
	PaymentsSendStarsForm(ctx context.Context, in *TLPaymentsSendStarsForm) (*PaymentsPaymentResult, error)
	PaymentsRefundStarsCharge(ctx context.Context, in *TLPaymentsRefundStarsCharge) (*Updates, error)
	PaymentsGetStarsRevenueStats(ctx context.Context, in *TLPaymentsGetStarsRevenueStats) (*PaymentsStarsRevenueStats, error)
	PaymentsGetStarsRevenueWithdrawalUrl(ctx context.Context, in *TLPaymentsGetStarsRevenueWithdrawalUrl) (*PaymentsStarsRevenueWithdrawalUrl, error)
	PaymentsGetStarsRevenueAdsAccountUrl(ctx context.Context, in *TLPaymentsGetStarsRevenueAdsAccountUrl) (*PaymentsStarsRevenueAdsAccountUrl, error)
	PaymentsGetStarsTransactionsByID(ctx context.Context, in *TLPaymentsGetStarsTransactionsByID) (*PaymentsStarsStatus, error)
	PaymentsGetStarsGiftOptions(ctx context.Context, in *TLPaymentsGetStarsGiftOptions) (*VectorStarsGiftOption, error)
}

type RPCReports interface {
	AccountReportPeer(ctx context.Context, in *TLAccountReportPeer) (*Bool, error)
	AccountReportProfilePhoto(ctx context.Context, in *TLAccountReportProfilePhoto) (*Bool, error)
	MessagesReportSpam(ctx context.Context, in *TLMessagesReportSpam) (*Bool, error)
	MessagesReport(ctx context.Context, in *TLMessagesReport) (*ReportResult, error)
	MessagesReportEncryptedSpam(ctx context.Context, in *TLMessagesReportEncryptedSpam) (*Bool, error)
	ChannelsReportSpam(ctx context.Context, in *TLChannelsReportSpam) (*Bool, error)
}

type RPCFolderTags interface {
	MessagesToggleDialogFilterTags(ctx context.Context, in *TLMessagesToggleDialogFilterTags) (*Bool, error)
}

type RPCChannelRecommendations interface {
	ChannelsGetChannelRecommendations(ctx context.Context, in *TLChannelsGetChannelRecommendations) (*MessagesChats, error)
}

type RPCAffiliatePrograms interface {
	BotsUpdateStarRefProgram(ctx context.Context, in *TLBotsUpdateStarRefProgram) (*StarRefProgram, error)
	PaymentsGetConnectedStarRefBots(ctx context.Context, in *TLPaymentsGetConnectedStarRefBots) (*PaymentsConnectedStarRefBots, error)
	PaymentsGetConnectedStarRefBot(ctx context.Context, in *TLPaymentsGetConnectedStarRefBot) (*PaymentsConnectedStarRefBots, error)
	PaymentsGetSuggestedStarRefBots(ctx context.Context, in *TLPaymentsGetSuggestedStarRefBots) (*PaymentsSuggestedStarRefBots, error)
	PaymentsConnectStarRefBot(ctx context.Context, in *TLPaymentsConnectStarRefBot) (*PaymentsConnectedStarRefBots, error)
	PaymentsEditConnectedStarRefBot(ctx context.Context, in *TLPaymentsEditConnectedStarRefBot) (*PaymentsConnectedStarRefBots, error)
}

type RPCGifts interface {
	PaymentsGetStarGifts(ctx context.Context, in *TLPaymentsGetStarGifts) (*PaymentsStarGifts, error)
	PaymentsSaveStarGift(ctx context.Context, in *TLPaymentsSaveStarGift) (*Bool, error)
	PaymentsConvertStarGift(ctx context.Context, in *TLPaymentsConvertStarGift) (*Bool, error)
	PaymentsGetStarGiftUpgradePreview(ctx context.Context, in *TLPaymentsGetStarGiftUpgradePreview) (*PaymentsStarGiftUpgradePreview, error)
	PaymentsUpgradeStarGift(ctx context.Context, in *TLPaymentsUpgradeStarGift) (*Updates, error)
	PaymentsTransferStarGift(ctx context.Context, in *TLPaymentsTransferStarGift) (*Updates, error)
	PaymentsGetUniqueStarGift(ctx context.Context, in *TLPaymentsGetUniqueStarGift) (*PaymentsUniqueStarGift, error)
	PaymentsGetSavedStarGifts(ctx context.Context, in *TLPaymentsGetSavedStarGifts) (*PaymentsSavedStarGifts, error)
	PaymentsGetSavedStarGift(ctx context.Context, in *TLPaymentsGetSavedStarGift) (*PaymentsSavedStarGifts, error)
	PaymentsGetStarGiftWithdrawalUrl(ctx context.Context, in *TLPaymentsGetStarGiftWithdrawalUrl) (*PaymentsStarGiftWithdrawalUrl, error)
	PaymentsToggleChatStarGiftNotifications(ctx context.Context, in *TLPaymentsToggleChatStarGiftNotifications) (*Bool, error)
	PaymentsToggleStarGiftsPinnedToTop(ctx context.Context, in *TLPaymentsToggleStarGiftsPinnedToTop) (*Bool, error)
}

type RPCTranslation interface {
	MessagesTranslateText(ctx context.Context, in *TLMessagesTranslateText) (*MessagesTranslatedText, error)
	MessagesTogglePeerTranslations(ctx context.Context, in *TLMessagesTogglePeerTranslations) (*Bool, error)
}

type RPCVoipCalls interface {
	MessagesDeletePhoneCallHistory(ctx context.Context, in *TLMessagesDeletePhoneCallHistory) (*MessagesAffectedFoundMessages, error)
	PhoneGetCallConfig(ctx context.Context, in *TLPhoneGetCallConfig) (*DataJSON, error)
	PhoneRequestCall(ctx context.Context, in *TLPhoneRequestCall) (*PhonePhoneCall, error)
	PhoneAcceptCall(ctx context.Context, in *TLPhoneAcceptCall) (*PhonePhoneCall, error)
	PhoneConfirmCall(ctx context.Context, in *TLPhoneConfirmCall) (*PhonePhoneCall, error)
	PhoneReceivedCall(ctx context.Context, in *TLPhoneReceivedCall) (*Bool, error)
	PhoneDiscardCall(ctx context.Context, in *TLPhoneDiscardCall) (*Updates, error)
	PhoneSetCallRating(ctx context.Context, in *TLPhoneSetCallRating) (*Updates, error)
	PhoneSaveCallDebug(ctx context.Context, in *TLPhoneSaveCallDebug) (*Bool, error)
	PhoneSendSignalingData(ctx context.Context, in *TLPhoneSendSignalingData) (*Bool, error)
	PhoneSaveCallLog(ctx context.Context, in *TLPhoneSaveCallLog) (*Bool, error)
	PhoneCreateConferenceCall(ctx context.Context, in *TLPhoneCreateConferenceCall) (*PhonePhoneCall, error)
}

type RPCMiniBotApps interface {
	MessagesRequestWebView(ctx context.Context, in *TLMessagesRequestWebView) (*WebViewResult, error)
	MessagesProlongWebView(ctx context.Context, in *TLMessagesProlongWebView) (*Bool, error)
	MessagesRequestSimpleWebView(ctx context.Context, in *TLMessagesRequestSimpleWebView) (*WebViewResult, error)
	MessagesSendWebViewResultMessage(ctx context.Context, in *TLMessagesSendWebViewResultMessage) (*WebViewMessageSent, error)
	MessagesSendWebViewData(ctx context.Context, in *TLMessagesSendWebViewData) (*Updates, error)
	MessagesGetBotApp(ctx context.Context, in *TLMessagesGetBotApp) (*MessagesBotApp, error)
	MessagesRequestAppWebView(ctx context.Context, in *TLMessagesRequestAppWebView) (*WebViewResult, error)
	BotsCanSendMessage(ctx context.Context, in *TLBotsCanSendMessage) (*Bool, error)
	BotsAllowSendMessage(ctx context.Context, in *TLBotsAllowSendMessage) (*Updates, error)
	BotsInvokeWebViewCustomMethod(ctx context.Context, in *TLBotsInvokeWebViewCustomMethod) (*DataJSON, error)
	BotsCheckDownloadFileParams(ctx context.Context, in *TLBotsCheckDownloadFileParams) (*Bool, error)
}

type RPCNotification interface {
	AccountRegisterDevice(ctx context.Context, in *TLAccountRegisterDevice) (*Bool, error)
	AccountUnregisterDevice(ctx context.Context, in *TLAccountUnregisterDevice) (*Bool, error)
	AccountUpdateNotifySettings(ctx context.Context, in *TLAccountUpdateNotifySettings) (*Bool, error)
	AccountGetNotifySettings(ctx context.Context, in *TLAccountGetNotifySettings) (*PeerNotifySettings, error)
	AccountResetNotifySettings(ctx context.Context, in *TLAccountResetNotifySettings) (*Bool, error)
	AccountUpdateDeviceLocked(ctx context.Context, in *TLAccountUpdateDeviceLocked) (*Bool, error)
	AccountGetNotifyExceptions(ctx context.Context, in *TLAccountGetNotifyExceptions) (*Updates, error)
}

type RPCBusinessChatLinks interface {
	AccountCreateBusinessChatLink(ctx context.Context, in *TLAccountCreateBusinessChatLink) (*BusinessChatLink, error)
	AccountEditBusinessChatLink(ctx context.Context, in *TLAccountEditBusinessChatLink) (*BusinessChatLink, error)
	AccountDeleteBusinessChatLink(ctx context.Context, in *TLAccountDeleteBusinessChatLink) (*Bool, error)
	AccountGetBusinessChatLinks(ctx context.Context, in *TLAccountGetBusinessChatLinks) (*AccountBusinessChatLinks, error)
	AccountResolveBusinessChatLink(ctx context.Context, in *TLAccountResolveBusinessChatLink) (*AccountResolvedBusinessChatLinks, error)
}

type RPCUsers interface {
	UsersGetUsers(ctx context.Context, in *TLUsersGetUsers) (*VectorUser, error)
	UsersGetFullUser(ctx context.Context, in *TLUsersGetFullUser) (*UsersUserFull, error)
	ContactsResolvePhone(ctx context.Context, in *TLContactsResolvePhone) (*ContactsResolvedPeer, error)
	UsersGetMe(ctx context.Context, in *TLUsersGetMe) (*User, error)
}

type RPCStickers interface {
	MessagesGetStickers(ctx context.Context, in *TLMessagesGetStickers) (*MessagesStickers, error)
	MessagesGetAllStickers(ctx context.Context, in *TLMessagesGetAllStickers) (*MessagesAllStickers, error)
	MessagesGetStickerSet(ctx context.Context, in *TLMessagesGetStickerSet) (*MessagesStickerSet, error)
	MessagesInstallStickerSet(ctx context.Context, in *TLMessagesInstallStickerSet) (*MessagesStickerSetInstallResult, error)
	MessagesUninstallStickerSet(ctx context.Context, in *TLMessagesUninstallStickerSet) (*Bool, error)
	MessagesReorderStickerSets(ctx context.Context, in *TLMessagesReorderStickerSets) (*Bool, error)
	MessagesGetFeaturedStickers(ctx context.Context, in *TLMessagesGetFeaturedStickers) (*MessagesFeaturedStickers, error)
	MessagesReadFeaturedStickers(ctx context.Context, in *TLMessagesReadFeaturedStickers) (*Bool, error)
	MessagesGetRecentStickers(ctx context.Context, in *TLMessagesGetRecentStickers) (*MessagesRecentStickers, error)
	MessagesSaveRecentSticker(ctx context.Context, in *TLMessagesSaveRecentSticker) (*Bool, error)
	MessagesClearRecentStickers(ctx context.Context, in *TLMessagesClearRecentStickers) (*Bool, error)
	MessagesGetArchivedStickers(ctx context.Context, in *TLMessagesGetArchivedStickers) (*MessagesArchivedStickers, error)
	MessagesGetMaskStickers(ctx context.Context, in *TLMessagesGetMaskStickers) (*MessagesAllStickers, error)
	MessagesGetAttachedStickers(ctx context.Context, in *TLMessagesGetAttachedStickers) (*VectorStickerSetCovered, error)
	MessagesGetFavedStickers(ctx context.Context, in *TLMessagesGetFavedStickers) (*MessagesFavedStickers, error)
	MessagesFaveSticker(ctx context.Context, in *TLMessagesFaveSticker) (*Bool, error)
	MessagesSearchStickerSets(ctx context.Context, in *TLMessagesSearchStickerSets) (*MessagesFoundStickerSets, error)
	MessagesToggleStickerSets(ctx context.Context, in *TLMessagesToggleStickerSets) (*Bool, error)
	MessagesGetOldFeaturedStickers(ctx context.Context, in *TLMessagesGetOldFeaturedStickers) (*MessagesFeaturedStickers, error)
	MessagesSearchEmojiStickerSets(ctx context.Context, in *TLMessagesSearchEmojiStickerSets) (*MessagesFoundStickerSets, error)
	MessagesGetMyStickers(ctx context.Context, in *TLMessagesGetMyStickers) (*MessagesMyStickers, error)
	MessagesSearchStickers(ctx context.Context, in *TLMessagesSearchStickers) (*MessagesFoundStickers, error)
	StickersCreateStickerSet(ctx context.Context, in *TLStickersCreateStickerSet) (*MessagesStickerSet, error)
	StickersRemoveStickerFromSet(ctx context.Context, in *TLStickersRemoveStickerFromSet) (*MessagesStickerSet, error)
	StickersChangeStickerPosition(ctx context.Context, in *TLStickersChangeStickerPosition) (*MessagesStickerSet, error)
	StickersAddStickerToSet(ctx context.Context, in *TLStickersAddStickerToSet) (*MessagesStickerSet, error)
	StickersSetStickerSetThumb(ctx context.Context, in *TLStickersSetStickerSetThumb) (*MessagesStickerSet, error)
	StickersCheckShortName(ctx context.Context, in *TLStickersCheckShortName) (*Bool, error)
	StickersSuggestShortName(ctx context.Context, in *TLStickersSuggestShortName) (*StickersSuggestedShortName, error)
	StickersChangeSticker(ctx context.Context, in *TLStickersChangeSticker) (*MessagesStickerSet, error)
	StickersRenameStickerSet(ctx context.Context, in *TLStickersRenameStickerSet) (*MessagesStickerSet, error)
	StickersDeleteStickerSet(ctx context.Context, in *TLStickersDeleteStickerSet) (*Bool, error)
	StickersReplaceSticker(ctx context.Context, in *TLStickersReplaceSticker) (*MessagesStickerSet, error)
}

type RPCInternalBot interface {
	HelpSetBotUpdatesStatus(ctx context.Context, in *TLHelpSetBotUpdatesStatus) (*Bool, error)
	BotsSendCustomRequest(ctx context.Context, in *TLBotsSendCustomRequest) (*DataJSON, error)
	BotsAnswerWebhookJSONQuery(ctx context.Context, in *TLBotsAnswerWebhookJSONQuery) (*Bool, error)
}

type RPCGiveaways interface {
	PaymentsGetPremiumGiftCodeOptions(ctx context.Context, in *TLPaymentsGetPremiumGiftCodeOptions) (*VectorPremiumGiftCodeOption, error)
	PaymentsGetGiveawayInfo(ctx context.Context, in *TLPaymentsGetGiveawayInfo) (*PaymentsGiveawayInfo, error)
	PaymentsLaunchPrepaidGiveaway(ctx context.Context, in *TLPaymentsLaunchPrepaidGiveaway) (*Updates, error)
	PaymentsGetStarsGiveawayOptions(ctx context.Context, in *TLPaymentsGetStarsGiveawayOptions) (*VectorStarsGiveawayOption, error)
}

type RPCRingtone interface {
	AccountGetSavedRingtones(ctx context.Context, in *TLAccountGetSavedRingtones) (*AccountSavedRingtones, error)
	AccountSaveRingtone(ctx context.Context, in *TLAccountSaveRingtone) (*AccountSavedRingtone, error)
	AccountUploadRingtone(ctx context.Context, in *TLAccountUploadRingtone) (*Document, error)
}

type RPCProfileLinks interface {
	ContactsExportContactToken(ctx context.Context, in *TLContactsExportContactToken) (*ExportedContactToken, error)
	ContactsImportContactToken(ctx context.Context, in *TLContactsImportContactToken) (*User, error)
}

type RPCSecretChats interface {
	MessagesGetDhConfig(ctx context.Context, in *TLMessagesGetDhConfig) (*MessagesDhConfig, error)
	MessagesRequestEncryption(ctx context.Context, in *TLMessagesRequestEncryption) (*EncryptedChat, error)
	MessagesAcceptEncryption(ctx context.Context, in *TLMessagesAcceptEncryption) (*EncryptedChat, error)
	MessagesDiscardEncryption(ctx context.Context, in *TLMessagesDiscardEncryption) (*Bool, error)
	MessagesSetEncryptedTyping(ctx context.Context, in *TLMessagesSetEncryptedTyping) (*Bool, error)
	MessagesReadEncryptedHistory(ctx context.Context, in *TLMessagesReadEncryptedHistory) (*Bool, error)
	MessagesSendEncrypted(ctx context.Context, in *TLMessagesSendEncrypted) (*MessagesSentEncryptedMessage, error)
	MessagesSendEncryptedFile(ctx context.Context, in *TLMessagesSendEncryptedFile) (*MessagesSentEncryptedMessage, error)
	MessagesSendEncryptedService(ctx context.Context, in *TLMessagesSendEncryptedService) (*MessagesSentEncryptedMessage, error)
	MessagesReceivedQueue(ctx context.Context, in *TLMessagesReceivedQueue) (*VectorLong, error)
}

type RPCFiles interface {
	MessagesGetDocumentByHash(ctx context.Context, in *TLMessagesGetDocumentByHash) (*Document, error)
	MessagesUploadMedia(ctx context.Context, in *TLMessagesUploadMedia) (*MessageMedia, error)
	MessagesUploadEncryptedFile(ctx context.Context, in *TLMessagesUploadEncryptedFile) (*EncryptedFile, error)
	UploadSaveFilePart(ctx context.Context, in *TLUploadSaveFilePart) (*Bool, error)
	UploadGetFile(ctx context.Context, in *TLUploadGetFile) (*UploadFile, error)
	UploadSaveBigFilePart(ctx context.Context, in *TLUploadSaveBigFilePart) (*Bool, error)
	UploadGetWebFile(ctx context.Context, in *TLUploadGetWebFile) (*UploadWebFile, error)
	UploadGetCdnFile(ctx context.Context, in *TLUploadGetCdnFile) (*UploadCdnFile, error)
	UploadReuploadCdnFile(ctx context.Context, in *TLUploadReuploadCdnFile) (*VectorFileHash, error)
	UploadGetCdnFileHashes(ctx context.Context, in *TLUploadGetCdnFileHashes) (*VectorFileHash, error)
	UploadGetFileHashes(ctx context.Context, in *TLUploadGetFileHashes) (*VectorFileHash, error)
	HelpGetCdnConfig(ctx context.Context, in *TLHelpGetCdnConfig) (*CdnConfig, error)
}

type RPCSavedMessageTags interface {
	MessagesGetSavedReactionTags(ctx context.Context, in *TLMessagesGetSavedReactionTags) (*MessagesSavedReactionTags, error)
	MessagesUpdateSavedReactionTag(ctx context.Context, in *TLMessagesUpdateSavedReactionTag) (*Bool, error)
	MessagesGetDefaultTagReactions(ctx context.Context, in *TLMessagesGetDefaultTagReactions) (*MessagesReactions, error)
}

type RPCStarSubscriptions interface {
	PaymentsGetStarsSubscriptions(ctx context.Context, in *TLPaymentsGetStarsSubscriptions) (*PaymentsStarsStatus, error)
	PaymentsChangeStarsSubscription(ctx context.Context, in *TLPaymentsChangeStarsSubscription) (*Bool, error)
	PaymentsFulfillStarsSubscription(ctx context.Context, in *TLPaymentsFulfillStarsSubscription) (*Bool, error)
	PaymentsBotCancelStarsSubscription(ctx context.Context, in *TLPaymentsBotCancelStarsSubscription) (*Bool, error)
}

type RPCLangpack interface {
	LangpackGetLangPack(ctx context.Context, in *TLLangpackGetLangPack) (*LangPackDifference, error)
	LangpackGetStrings(ctx context.Context, in *TLLangpackGetStrings) (*VectorLangPackString, error)
	LangpackGetDifference(ctx context.Context, in *TLLangpackGetDifference) (*LangPackDifference, error)
	LangpackGetLanguages(ctx context.Context, in *TLLangpackGetLanguages) (*VectorLangPackLanguage, error)
	LangpackGetLanguage(ctx context.Context, in *TLLangpackGetLanguage) (*LangPackLanguage, error)
}

type RPCFragmentCollectibles interface {
	FragmentGetCollectibleInfo(ctx context.Context, in *TLFragmentGetCollectibleInfo) (*FragmentCollectibleInfo, error)
}

type RPCPayments interface {
	AccountGetTmpPassword(ctx context.Context, in *TLAccountGetTmpPassword) (*AccountTmpPassword, error)
	MessagesSetBotShippingResults(ctx context.Context, in *TLMessagesSetBotShippingResults) (*Bool, error)
	MessagesSetBotPrecheckoutResults(ctx context.Context, in *TLMessagesSetBotPrecheckoutResults) (*Bool, error)
	PaymentsGetPaymentForm(ctx context.Context, in *TLPaymentsGetPaymentForm) (*PaymentsPaymentForm, error)
	PaymentsGetPaymentReceipt(ctx context.Context, in *TLPaymentsGetPaymentReceipt) (*PaymentsPaymentReceipt, error)
	PaymentsValidateRequestedInfo(ctx context.Context, in *TLPaymentsValidateRequestedInfo) (*PaymentsValidatedRequestedInfo, error)
	PaymentsSendPaymentForm(ctx context.Context, in *TLPaymentsSendPaymentForm) (*PaymentsPaymentResult, error)
	PaymentsGetSavedInfo(ctx context.Context, in *TLPaymentsGetSavedInfo) (*PaymentsSavedInfo, error)
	PaymentsClearSavedInfo(ctx context.Context, in *TLPaymentsClearSavedInfo) (*Bool, error)
	PaymentsGetBankCardData(ctx context.Context, in *TLPaymentsGetBankCardData) (*PaymentsBankCardData, error)
	PaymentsExportInvoice(ctx context.Context, in *TLPaymentsExportInvoice) (*PaymentsExportedInvoice, error)
}

type RPCbiz interface {
	BizInvokeBizDataRaw(ctx context.Context, in *TLBizInvokeBizDataRaw) (*BizDataRaw, error)
}

type RPCWebPage interface {
	MessagesGetWebPagePreview(ctx context.Context, in *TLMessagesGetWebPagePreview) (*MessagesWebPagePreview, error)
	MessagesGetWebPage(ctx context.Context, in *TLMessagesGetWebPage) (*MessagesWebPage, error)
}

type RPCInlineBot interface {
	MessagesGetInlineBotResults(ctx context.Context, in *TLMessagesGetInlineBotResults) (*MessagesBotResults, error)
	MessagesSetInlineBotResults(ctx context.Context, in *TLMessagesSetInlineBotResults) (*Bool, error)
	MessagesSendInlineBotResult(ctx context.Context, in *TLMessagesSendInlineBotResult) (*Updates, error)
	MessagesEditInlineBotMessage(ctx context.Context, in *TLMessagesEditInlineBotMessage) (*Bool, error)
	MessagesGetBotCallbackAnswer(ctx context.Context, in *TLMessagesGetBotCallbackAnswer) (*MessagesBotCallbackAnswer, error)
	MessagesSetBotCallbackAnswer(ctx context.Context, in *TLMessagesSetBotCallbackAnswer) (*Bool, error)
	MessagesSendBotRequestedPeer(ctx context.Context, in *TLMessagesSendBotRequestedPeer) (*Updates, error)
}

type RPCBots interface {
	BotsSetBotCommands(ctx context.Context, in *TLBotsSetBotCommands) (*Bool, error)
	BotsResetBotCommands(ctx context.Context, in *TLBotsResetBotCommands) (*Bool, error)
	BotsGetBotCommands(ctx context.Context, in *TLBotsGetBotCommands) (*VectorBotCommand, error)
	BotsSetBotInfo(ctx context.Context, in *TLBotsSetBotInfo) (*Bool, error)
	BotsGetBotInfo(ctx context.Context, in *TLBotsGetBotInfo) (*BotsBotInfo, error)
	BotsGetAdminedBots(ctx context.Context, in *TLBotsGetAdminedBots) (*VectorUser, error)
	BotsSetCustomVerification(ctx context.Context, in *TLBotsSetCustomVerification) (*Bool, error)
	BotsGetBotRecommendations(ctx context.Context, in *TLBotsGetBotRecommendations) (*UsersUsers, error)
}

type RPCStories interface {
	StoriesCanSendStory(ctx context.Context, in *TLStoriesCanSendStory) (*Bool, error)
	StoriesSendStory(ctx context.Context, in *TLStoriesSendStory) (*Updates, error)
	StoriesEditStory(ctx context.Context, in *TLStoriesEditStory) (*Updates, error)
	StoriesDeleteStories(ctx context.Context, in *TLStoriesDeleteStories) (*VectorInt, error)
	StoriesTogglePinned(ctx context.Context, in *TLStoriesTogglePinned) (*VectorInt, error)
	StoriesGetAllStories(ctx context.Context, in *TLStoriesGetAllStories) (*StoriesAllStories, error)
	StoriesGetPinnedStories(ctx context.Context, in *TLStoriesGetPinnedStories) (*StoriesStories, error)
	StoriesGetStoriesArchive(ctx context.Context, in *TLStoriesGetStoriesArchive) (*StoriesStories, error)
	StoriesGetStoriesByID(ctx context.Context, in *TLStoriesGetStoriesByID) (*StoriesStories, error)
	StoriesToggleAllStoriesHidden(ctx context.Context, in *TLStoriesToggleAllStoriesHidden) (*Bool, error)
	StoriesReadStories(ctx context.Context, in *TLStoriesReadStories) (*VectorInt, error)
	StoriesIncrementStoryViews(ctx context.Context, in *TLStoriesIncrementStoryViews) (*Bool, error)
	StoriesGetStoryViewsList(ctx context.Context, in *TLStoriesGetStoryViewsList) (*StoriesStoryViewsList, error)
	StoriesGetStoriesViews(ctx context.Context, in *TLStoriesGetStoriesViews) (*StoriesStoryViews, error)
	StoriesExportStoryLink(ctx context.Context, in *TLStoriesExportStoryLink) (*ExportedStoryLink, error)
	StoriesReport(ctx context.Context, in *TLStoriesReport) (*ReportResult, error)
	StoriesActivateStealthMode(ctx context.Context, in *TLStoriesActivateStealthMode) (*Updates, error)
	StoriesSendReaction(ctx context.Context, in *TLStoriesSendReaction) (*Updates, error)
	StoriesGetPeerStories(ctx context.Context, in *TLStoriesGetPeerStories) (*StoriesPeerStories, error)
	StoriesGetAllReadPeerStories(ctx context.Context, in *TLStoriesGetAllReadPeerStories) (*Updates, error)
	StoriesGetPeerMaxIDs(ctx context.Context, in *TLStoriesGetPeerMaxIDs) (*VectorInt, error)
	StoriesGetChatsToSend(ctx context.Context, in *TLStoriesGetChatsToSend) (*MessagesChats, error)
	StoriesTogglePeerStoriesHidden(ctx context.Context, in *TLStoriesTogglePeerStoriesHidden) (*Bool, error)
	StoriesGetStoryReactionsList(ctx context.Context, in *TLStoriesGetStoryReactionsList) (*StoriesStoryReactionsList, error)
	StoriesTogglePinnedToTop(ctx context.Context, in *TLStoriesTogglePinnedToTop) (*Bool, error)
	StoriesSearchPosts(ctx context.Context, in *TLStoriesSearchPosts) (*StoriesFoundStories, error)
}

type RPCSmsjobs interface {
	SmsjobsIsEligibleToJoin(ctx context.Context, in *TLSmsjobsIsEligibleToJoin) (*SmsjobsEligibilityToJoin, error)
	SmsjobsJoin(ctx context.Context, in *TLSmsjobsJoin) (*Bool, error)
	SmsjobsLeave(ctx context.Context, in *TLSmsjobsLeave) (*Bool, error)
	SmsjobsUpdateSettings(ctx context.Context, in *TLSmsjobsUpdateSettings) (*Bool, error)
	SmsjobsGetStatus(ctx context.Context, in *TLSmsjobsGetStatus) (*SmsjobsStatus, error)
	SmsjobsGetSmsJob(ctx context.Context, in *TLSmsjobsGetSmsJob) (*SmsJob, error)
	SmsjobsFinishJob(ctx context.Context, in *TLSmsjobsFinishJob) (*Bool, error)
}

type RPCAccount interface {
	AccountDeleteAccount(ctx context.Context, in *TLAccountDeleteAccount) (*Bool, error)
	AccountGetAccountTTL(ctx context.Context, in *TLAccountGetAccountTTL) (*AccountDaysTTL, error)
	AccountSetAccountTTL(ctx context.Context, in *TLAccountSetAccountTTL) (*Bool, error)
	AccountSendChangePhoneCode(ctx context.Context, in *TLAccountSendChangePhoneCode) (*AuthSentCode, error)
	AccountChangePhone(ctx context.Context, in *TLAccountChangePhone) (*User, error)
	AccountResetAuthorization(ctx context.Context, in *TLAccountResetAuthorization) (*Bool, error)
	AccountSendConfirmPhoneCode(ctx context.Context, in *TLAccountSendConfirmPhoneCode) (*AuthSentCode, error)
	AccountConfirmPhone(ctx context.Context, in *TLAccountConfirmPhone) (*Bool, error)
}
